<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scars of Ash</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="root"></div>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
  <script src="gamedata.js"></script>
  <script type="text/babel">
    const { useState, useReducer, useEffect, useCallback, useRef } = React;

    // ============= SPRITE REACT COMPONENTS =============
    // AnimatedSprite component - cycles through animation frames
    // Frame rate guide: idle=250ms (4fps), walk=166ms (6fps), battle=125ms (8fps)
    const AnimatedSprite = ({
      frames,           // Array of preloaded Image objects
      frameRate = 250,  // ms per frame - default to idle speed (4fps)
      size = 48,
      flip = false,
      filter = 'none',
      playing = true
    }) => {
      const [frameIndex, setFrameIndex] = React.useState(0);

      React.useEffect(() => {
        if (!playing || !frames || frames.length <= 1) return;
        const interval = setInterval(() => {
          setFrameIndex(i => (i + 1) % frames.length);
        }, frameRate);
        return () => clearInterval(interval);
      }, [frames, frameRate, playing]);

      if (!frames || frames.length === 0) {
        return null;
      }

      const currentFrame = frames[frameIndex % frames.length];

      return (
        <img
          src={currentFrame.src}
          alt="sprite"
          width={size}
          height={size}
          style={{
            imageRendering: 'pixelated',
            transform: flip ? 'scaleX(-1)' : 'none',
            filter: filter
          }}
        />
      );
    };

    // Player sprite facing different directions (16x16 scaled up) - SVG fallback version
    // Each appearance has a distinct silhouette
    const FallbackPlayerSprite = ({ direction = 'down', appearance = 'other' }) => {
      const px = 3; // pixel size (3 = 48px total)
      const palette = PLAYER_PALETTES[appearance] || PLAYER_PALETTES.other;
      const { skin, hair, cloak, cloakLight, pants, outline } = palette;

      // MALE: Short hair, broader shoulders, blue/teal cloak
      const maleSprites = {
        down: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Short spiky hair */}
            <rect x={5*px} y={1*px} width={6*px} height={2*px} fill={hair}/>
            <rect x={4*px} y={2*px} width={1*px} height={1*px} fill={hair}/>
            <rect x={11*px} y={2*px} width={1*px} height={1*px} fill={hair}/>
            <rect x={6*px} y={0*px} width={1*px} height={1*px} fill={hair}/>
            <rect x={9*px} y={0*px} width={1*px} height={1*px} fill={hair}/>
            {/* Face */}
            <rect x={5*px} y={3*px} width={6*px} height={4*px} fill={skin}/>
            {/* Eyes */}
            <rect x={6*px} y={4*px} width={1*px} height={2*px} fill={outline}/>
            <rect x={9*px} y={4*px} width={1*px} height={2*px} fill={outline}/>
            {/* Broad shoulders/cloak */}
            <rect x={3*px} y={7*px} width={10*px} height={5*px} fill={cloak}/>
            <rect x={2*px} y={8*px} width={1*px} height={3*px} fill={cloak}/>
            <rect x={13*px} y={8*px} width={1*px} height={3*px} fill={cloak}/>
            <rect x={7*px} y={8*px} width={2*px} height={2*px} fill={cloakLight}/>
            {/* Pants */}
            <rect x={5*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={9*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            {/* Feet */}
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        ),
        up: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Short hair back */}
            <rect x={5*px} y={1*px} width={6*px} height={3*px} fill={hair}/>
            <rect x={4*px} y={2*px} width={1*px} height={2*px} fill={hair}/>
            <rect x={11*px} y={2*px} width={1*px} height={2*px} fill={hair}/>
            {/* Neck */}
            <rect x={6*px} y={4*px} width={4*px} height={3*px} fill={skin}/>
            {/* Broad shoulders/cloak */}
            <rect x={3*px} y={7*px} width={10*px} height={5*px} fill={cloak}/>
            <rect x={2*px} y={8*px} width={1*px} height={3*px} fill={cloak}/>
            <rect x={13*px} y={8*px} width={1*px} height={3*px} fill={cloak}/>
            {/* Pants */}
            <rect x={5*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={9*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            {/* Feet */}
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        ),
        left: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Short hair */}
            <rect x={6*px} y={1*px} width={4*px} height={2*px} fill={hair}/>
            <rect x={5*px} y={2*px} width={1*px} height={2*px} fill={hair}/>
            <rect x={7*px} y={0*px} width={1*px} height={1*px} fill={hair}/>
            {/* Face */}
            <rect x={5*px} y={3*px} width={4*px} height={4*px} fill={skin}/>
            <rect x={5*px} y={4*px} width={1*px} height={2*px} fill={outline}/>
            {/* Broad cloak */}
            <rect x={4*px} y={7*px} width={7*px} height={5*px} fill={cloak}/>
            <rect x={3*px} y={8*px} width={1*px} height={3*px} fill={cloak}/>
            {/* Pants */}
            <rect x={5*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={8*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={8*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        ),
        right: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Short hair */}
            <rect x={6*px} y={1*px} width={4*px} height={2*px} fill={hair}/>
            <rect x={10*px} y={2*px} width={1*px} height={2*px} fill={hair}/>
            <rect x={8*px} y={0*px} width={1*px} height={1*px} fill={hair}/>
            {/* Face */}
            <rect x={7*px} y={3*px} width={4*px} height={4*px} fill={skin}/>
            <rect x={10*px} y={4*px} width={1*px} height={2*px} fill={outline}/>
            {/* Broad cloak */}
            <rect x={5*px} y={7*px} width={7*px} height={5*px} fill={cloak}/>
            <rect x={12*px} y={8*px} width={1*px} height={3*px} fill={cloak}/>
            {/* Pants */}
            <rect x={6*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={9*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={6*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        )
      };

      // FEMALE: Long hair with ponytail, red/maroon cloak, slender frame
      const femaleSprites = {
        down: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Long hair with side strands */}
            <rect x={5*px} y={1*px} width={6*px} height={3*px} fill={hair}/>
            <rect x={4*px} y={2*px} width={1*px} height={5*px} fill={hair}/>
            <rect x={11*px} y={2*px} width={1*px} height={5*px} fill={hair}/>
            {/* Face */}
            <rect x={5*px} y={4*px} width={6*px} height={4*px} fill={skin}/>
            {/* Eyes */}
            <rect x={6*px} y={5*px} width={1*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={5*px} width={1*px} height={1*px} fill={outline}/>
            {/* Slender cloak */}
            <rect x={4*px} y={8*px} width={8*px} height={4*px} fill={cloak}/>
            <rect x={7*px} y={9*px} width={2*px} height={2*px} fill={cloakLight}/>
            {/* Pants */}
            <rect x={5*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={9*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            {/* Feet */}
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        ),
        up: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Long hair with ponytail */}
            <rect x={5*px} y={1*px} width={6*px} height={4*px} fill={hair}/>
            <rect x={4*px} y={2*px} width={1*px} height={4*px} fill={hair}/>
            <rect x={11*px} y={2*px} width={1*px} height={4*px} fill={hair}/>
            {/* Ponytail down back */}
            <rect x={7*px} y={5*px} width={2*px} height={5*px} fill={hair}/>
            <rect x={7*px} y={10*px} width={2*px} height={2*px} fill={hair}/>
            {/* Slender cloak */}
            <rect x={4*px} y={8*px} width={8*px} height={4*px} fill={cloak}/>
            {/* Pants */}
            <rect x={5*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={9*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            {/* Feet */}
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        ),
        left: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Long hair */}
            <rect x={6*px} y={1*px} width={4*px} height={3*px} fill={hair}/>
            <rect x={5*px} y={2*px} width={1*px} height={5*px} fill={hair}/>
            {/* Ponytail behind */}
            <rect x={10*px} y={3*px} width={2*px} height={2*px} fill={hair}/>
            <rect x={11*px} y={5*px} width={2*px} height={4*px} fill={hair}/>
            {/* Face */}
            <rect x={6*px} y={4*px} width={4*px} height={4*px} fill={skin}/>
            <rect x={6*px} y={5*px} width={1*px} height={1*px} fill={outline}/>
            {/* Slender cloak */}
            <rect x={5*px} y={8*px} width={6*px} height={4*px} fill={cloak}/>
            {/* Pants */}
            <rect x={6*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={9*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={6*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        ),
        right: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Long hair */}
            <rect x={6*px} y={1*px} width={4*px} height={3*px} fill={hair}/>
            <rect x={10*px} y={2*px} width={1*px} height={5*px} fill={hair}/>
            {/* Ponytail behind */}
            <rect x={4*px} y={3*px} width={2*px} height={2*px} fill={hair}/>
            <rect x={3*px} y={5*px} width={2*px} height={4*px} fill={hair}/>
            {/* Face */}
            <rect x={6*px} y={4*px} width={4*px} height={4*px} fill={skin}/>
            <rect x={9*px} y={5*px} width={1*px} height={1*px} fill={outline}/>
            {/* Slender cloak */}
            <rect x={5*px} y={8*px} width={6*px} height={4*px} fill={cloak}/>
            {/* Pants */}
            <rect x={5*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={8*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={8*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        )
      };

      // OTHER: Hooded figure, purple/gray cloak, face obscured
      const otherSprites = {
        down: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Hood */}
            <rect x={4*px} y={0*px} width={8*px} height={3*px} fill={cloak}/>
            <rect x={3*px} y={1*px} width={1*px} height={4*px} fill={cloak}/>
            <rect x={12*px} y={1*px} width={1*px} height={4*px} fill={cloak}/>
            <rect x={4*px} y={3*px} width={8*px} height={2*px} fill={cloak}/>
            {/* Shadowed face */}
            <rect x={5*px} y={5*px} width={6*px} height={3*px} fill={skin}/>
            {/* Glowing eyes in shadow */}
            <rect x={6*px} y={6*px} width={1*px} height={1*px} fill={cloakLight}/>
            <rect x={9*px} y={6*px} width={1*px} height={1*px} fill={cloakLight}/>
            {/* Cloak body */}
            <rect x={3*px} y={8*px} width={10*px} height={5*px} fill={cloak}/>
            <rect x={6*px} y={9*px} width={4*px} height={2*px} fill={cloakLight}/>
            {/* Legs peek out */}
            <rect x={5*px} y={13*px} width={2*px} height={2*px} fill={pants}/>
            <rect x={9*px} y={13*px} width={2*px} height={2*px} fill={pants}/>
            {/* Feet */}
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        ),
        up: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Hood back */}
            <rect x={4*px} y={0*px} width={8*px} height={5*px} fill={cloak}/>
            <rect x={3*px} y={1*px} width={1*px} height={5*px} fill={cloak}/>
            <rect x={12*px} y={1*px} width={1*px} height={5*px} fill={cloak}/>
            {/* Hood interior visible */}
            <rect x={5*px} y={2*px} width={6*px} height={3*px} fill={hair}/>
            {/* Cloak body */}
            <rect x={3*px} y={6*px} width={10*px} height={7*px} fill={cloak}/>
            <rect x={6*px} y={8*px} width={4*px} height={3*px} fill={cloakLight}/>
            {/* Legs peek out */}
            <rect x={5*px} y={13*px} width={2*px} height={2*px} fill={pants}/>
            <rect x={9*px} y={13*px} width={2*px} height={2*px} fill={pants}/>
            {/* Feet */}
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        ),
        left: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Hood side */}
            <rect x={5*px} y={0*px} width={6*px} height={4*px} fill={cloak}/>
            <rect x={4*px} y={1*px} width={1*px} height={5*px} fill={cloak}/>
            <rect x={11*px} y={2*px} width={1*px} height={3*px} fill={cloak}/>
            {/* Shadowed face peek */}
            <rect x={5*px} y={4*px} width={3*px} height={3*px} fill={skin}/>
            <rect x={5*px} y={5*px} width={1*px} height={1*px} fill={cloakLight}/>
            {/* Cloak body */}
            <rect x={4*px} y={7*px} width={7*px} height={6*px} fill={cloak}/>
            <rect x={6*px} y={9*px} width={3*px} height={2*px} fill={cloakLight}/>
            {/* Legs */}
            <rect x={5*px} y={13*px} width={2*px} height={2*px} fill={pants}/>
            <rect x={8*px} y={13*px} width={2*px} height={2*px} fill={pants}/>
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={8*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        ),
        right: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Hood side */}
            <rect x={5*px} y={0*px} width={6*px} height={4*px} fill={cloak}/>
            <rect x={4*px} y={2*px} width={1*px} height={3*px} fill={cloak}/>
            <rect x={11*px} y={1*px} width={1*px} height={5*px} fill={cloak}/>
            {/* Shadowed face peek */}
            <rect x={8*px} y={4*px} width={3*px} height={3*px} fill={skin}/>
            <rect x={10*px} y={5*px} width={1*px} height={1*px} fill={cloakLight}/>
            {/* Cloak body */}
            <rect x={5*px} y={7*px} width={7*px} height={6*px} fill={cloak}/>
            <rect x={7*px} y={9*px} width={3*px} height={2*px} fill={cloakLight}/>
            {/* Legs */}
            <rect x={6*px} y={13*px} width={2*px} height={2*px} fill={pants}/>
            <rect x={9*px} y={13*px} width={2*px} height={2*px} fill={pants}/>
            <rect x={6*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={outline}/>
          </svg>
        )
      };

      // Select sprite set based on appearance
      const spriteSet = appearance === 'male' ? maleSprites :
                        appearance === 'female' ? femaleSprites :
                        otherSprites;

      return spriteSet[direction] || spriteSet.down;
    };

    // Main player sprite component
    // Idle: SVG fallback (always correct art, always static)
    // Walk: PNG animation at 4fps, except north (SVG fallback due to art issues)
    const PlayerSprite = ({ direction = 'down', appearance = 'other', isMoving = false }) => {
      // When idle, use SVG (correct directional art, no cycling animation)
      if (!isMoving) {
        return <FallbackPlayerSprite direction={direction} appearance={appearance} />;
      }

      // North-walk PNGs have wrong proportions — use SVG fallback
      if (direction === 'up') {
        return <FallbackPlayerSprite direction={direction} appearance={appearance} />;
      }

      // When walking (south/east/west), use PNG walk animation
      const frames = preloadedSprites.player[appearance]?.[direction]?.walk;
      if (frames && frames.length > 0) {
        return (
          <AnimatedSprite
            frames={frames}
            frameRate={250}
            size={48}
            playing={true}
          />
        );
      }

      // PNG walk frames unavailable — SVG fallback
      return <FallbackPlayerSprite direction={direction} appearance={appearance} />;
    };

    // Creature sprites - SVG fallback version
    const FallbackCreatureSprite = ({ type, size = 48, isEnemy = false }) => {
      const px = size / 16;

      const sprites = {
        fire: ( // Cindrath - flame creature
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body */}
            <rect x={4*px} y={8*px} width={8*px} height={6*px} fill="#c53030"/>
            <rect x={5*px} y={7*px} width={6*px} height={1*px} fill="#c53030"/>
            {/* Inner glow */}
            <rect x={5*px} y={9*px} width={6*px} height={4*px} fill="#ed8936"/>
            <rect x={6*px} y={10*px} width={4*px} height={2*px} fill="#f6e05e"/>
            {/* Eyes */}
            <rect x={5*px} y={9*px} width={2*px} height={2*px} fill="#1a1a2e"/>
            <rect x={9*px} y={9*px} width={2*px} height={2*px} fill="#1a1a2e"/>
            {/* Flames on head */}
            <rect x={6*px} y={4*px} width={1*px} height={3*px} fill="#ed8936"/>
            <rect x={8*px} y={3*px} width={1*px} height={4*px} fill="#f6ad55"/>
            <rect x={9*px} y={5*px} width={1*px} height={2*px} fill="#ed8936"/>
            <rect x={7*px} y={2*px} width={2*px} height={2*px} fill="#f6e05e"/>
            {/* Feet */}
            <rect x={4*px} y={14*px} width={2*px} height={2*px} fill="#742a2a"/>
            <rect x={10*px} y={14*px} width={2*px} height={2*px} fill="#742a2a"/>
          </svg>
        ),
        water: ( // Marshveil - water creature
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body - rounded blob */}
            <rect x={3*px} y={6*px} width={10*px} height={8*px} fill="#2b6cb0"/>
            <rect x={4*px} y={5*px} width={8*px} height={1*px} fill="#2b6cb0"/>
            <rect x={4*px} y={14*px} width={8*px} height={1*px} fill="#2b6cb0"/>
            {/* Inner shine */}
            <rect x={4*px} y={7*px} width={8*px} height={6*px} fill="#4299e1"/>
            <rect x={5*px} y={8*px} width={4*px} height={3*px} fill="#63b3ed"/>
            {/* Eyes */}
            <rect x={5*px} y={8*px} width={2*px} height={3*px} fill="#1a1a2e"/>
            <rect x={9*px} y={8*px} width={2*px} height={3*px} fill="#1a1a2e"/>
            <rect x={5*px} y={8*px} width={1*px} height={1*px} fill="#e8e8e8"/>
            <rect x={9*px} y={8*px} width={1*px} height={1*px} fill="#e8e8e8"/>
            {/* Fins/frills */}
            <rect x={1*px} y={8*px} width={2*px} height={4*px} fill="#4299e1"/>
            <rect x={13*px} y={8*px} width={2*px} height={4*px} fill="#4299e1"/>
            {/* Water drops */}
            <rect x={7*px} y={3*px} width={2*px} height={2*px} fill="#90cdf4"/>
          </svg>
        ),
        grass: ( // Thornwick - plant creature
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body */}
            <rect x={4*px} y={8*px} width={8*px} height={6*px} fill="#276749"/>
            <rect x={5*px} y={7*px} width={6*px} height={1*px} fill="#276749"/>
            {/* Inner */}
            <rect x={5*px} y={9*px} width={6*px} height={4*px} fill="#38a169"/>
            {/* Eyes */}
            <rect x={5*px} y={9*px} width={2*px} height={2*px} fill="#c53030"/>
            <rect x={9*px} y={9*px} width={2*px} height={2*px} fill="#c53030"/>
            {/* Leaves/thorns on top */}
            <rect x={5*px} y={4*px} width={2*px} height={3*px} fill="#48bb78"/>
            <rect x={7*px} y={2*px} width={2*px} height={5*px} fill="#68d391"/>
            <rect x={9*px} y={4*px} width={2*px} height={3*px} fill="#48bb78"/>
            {/* Thorns */}
            <rect x={3*px} y={10*px} width={1*px} height={2*px} fill="#68d391"/>
            <rect x={12*px} y={10*px} width={1*px} height={2*px} fill="#68d391"/>
            {/* Roots/feet */}
            <rect x={4*px} y={14*px} width={2*px} height={2*px} fill="#1c4532"/>
            <rect x={10*px} y={14*px} width={2*px} height={2*px} fill="#1c4532"/>
          </svg>
        ),
        boss: ( // Obsidian Hound
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body */}
            <rect x={2*px} y={8*px} width={12*px} height={5*px} fill="#1a1a2e"/>
            <rect x={3*px} y={7*px} width={10*px} height={1*px} fill="#1a1a2e"/>
            {/* Head */}
            <rect x={10*px} y={4*px} width={5*px} height={5*px} fill="#2d3748"/>
            <rect x={11*px} y={3*px} width={3*px} height={1*px} fill="#2d3748"/>
            {/* Ears */}
            <rect x={11*px} y={1*px} width={1*px} height={2*px} fill="#2d3748"/>
            <rect x={14*px} y={1*px} width={1*px} height={2*px} fill="#2d3748"/>
            {/* Eyes - glowing */}
            <rect x={11*px} y={5*px} width={2*px} height={2*px} fill="#f56565"/>
            <rect x={12*px} y={5*px} width={1*px} height={1*px} fill="#feb2b2"/>
            {/* Snout */}
            <rect x={14*px} y={6*px} width={2*px} height={2*px} fill="#4a5568"/>
            {/* Legs */}
            <rect x={3*px} y={13*px} width={2*px} height={3*px} fill="#1a1a2e"/>
            <rect x={6*px} y={13*px} width={2*px} height={3*px} fill="#1a1a2e"/>
            <rect x={9*px} y={13*px} width={2*px} height={3*px} fill="#1a1a2e"/>
            <rect x={12*px} y={13*px} width={2*px} height={3*px} fill="#1a1a2e"/>
            {/* Fire markings */}
            <rect x={4*px} y={9*px} width={1*px} height={2*px} fill="#ed8936"/>
            <rect x={7*px} y={8*px} width={1*px} height={3*px} fill="#f6ad55"/>
            {/* Tail */}
            <rect x={0*px} y={7*px} width={2*px} height={2*px} fill="#2d3748"/>
          </svg>
        ),
        dark: ( // Umbravine - dark vine creature
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body */}
            <rect x={4*px} y={8*px} width={8*px} height={6*px} fill="#2d2040"/>
            <rect x={5*px} y={7*px} width={6*px} height={1*px} fill="#2d2040"/>
            {/* Inner glow */}
            <rect x={5*px} y={9*px} width={6*px} height={4*px} fill="#4a3060"/>
            {/* Eyes - glowing violet */}
            <rect x={5*px} y={9*px} width={2*px} height={2*px} fill="#9f7aea"/>
            <rect x={9*px} y={9*px} width={2*px} height={2*px} fill="#9f7aea"/>
            <rect x={6*px} y={9*px} width={1*px} height={1*px} fill="#e9d8fd"/>
            <rect x={10*px} y={9*px} width={1*px} height={1*px} fill="#e9d8fd"/>
            {/* Vine tendrils */}
            <rect x={3*px} y={5*px} width={1*px} height={4*px} fill="#553c9a"/>
            <rect x={2*px} y={4*px} width={1*px} height={2*px} fill="#553c9a"/>
            <rect x={12*px} y={5*px} width={1*px} height={4*px} fill="#553c9a"/>
            <rect x={13*px} y={4*px} width={1*px} height={2*px} fill="#553c9a"/>
            {/* Top vines */}
            <rect x={6*px} y={3*px} width={1*px} height={4*px} fill="#6b46c1"/>
            <rect x={9*px} y={4*px} width={1*px} height={3*px} fill="#6b46c1"/>
            <rect x={7*px} y={2*px} width={2*px} height={2*px} fill="#805ad5"/>
            {/* Roots/feet */}
            <rect x={4*px} y={14*px} width={2*px} height={2*px} fill="#1a1030"/>
            <rect x={10*px} y={14*px} width={2*px} height={2*px} fill="#1a1030"/>
          </svg>
        ),
        light: ( // Solrath - light creature
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body */}
            <rect x={4*px} y={8*px} width={8*px} height={6*px} fill="#d69e2e"/>
            <rect x={5*px} y={7*px} width={6*px} height={1*px} fill="#d69e2e"/>
            {/* Inner glow */}
            <rect x={5*px} y={9*px} width={6*px} height={4*px} fill="#ecc94b"/>
            <rect x={6*px} y={10*px} width={4*px} height={2*px} fill="#faf089"/>
            {/* Eyes */}
            <rect x={5*px} y={9*px} width={2*px} height={2*px} fill="#1a1a2e"/>
            <rect x={9*px} y={9*px} width={2*px} height={2*px} fill="#1a1a2e"/>
            {/* Radiating light rays */}
            <rect x={7*px} y={1*px} width={2*px} height={5*px} fill="#faf089"/>
            <rect x={2*px} y={6*px} width={3*px} height={2*px} fill="#f6e05e"/>
            <rect x={11*px} y={6*px} width={3*px} height={2*px} fill="#f6e05e"/>
            <rect x={3*px} y={3*px} width={2*px} height={2*px} fill="#f6e05e"/>
            <rect x={11*px} y={3*px} width={2*px} height={2*px} fill="#f6e05e"/>
            {/* Warm glow halo */}
            <rect x={6*px} y={3*px} width={4*px} height={1*px} fill="#fefcbf"/>
            {/* Feet */}
            <rect x={4*px} y={14*px} width={2*px} height={2*px} fill="#b7791f"/>
            <rect x={10*px} y={14*px} width={2*px} height={2*px} fill="#b7791f"/>
          </svg>
        ),
        hollowWarden: ( // Hollow Warden - corrupted dark/light hybrid
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body - fractured */}
            <rect x={2*px} y={7*px} width={12*px} height={7*px} fill="#1a1020"/>
            <rect x={3*px} y={6*px} width={10*px} height={1*px} fill="#1a1020"/>
            {/* Corruption cracks */}
            <rect x={4*px} y={8*px} width={1*px} height={4*px} fill="#553c9a"/>
            <rect x={8*px} y={7*px} width={1*px} height={5*px} fill="#9f7aea"/>
            <rect x={11*px} y={9*px} width={1*px} height={3*px} fill="#553c9a"/>
            {/* Head */}
            <rect x={5*px} y={2*px} width={6*px} height={5*px} fill="#2d2040"/>
            {/* Eyes - one dark, one light */}
            <rect x={6*px} y={4*px} width={2*px} height={2*px} fill="#9f7aea"/>
            <rect x={10*px} y={4*px} width={2*px} height={2*px} fill="#faf089"/>
            {/* Crown of fractured light */}
            <rect x={6*px} y={0*px} width={1*px} height={2*px} fill="#f6e05e"/>
            <rect x={8*px} y={0*px} width={1*px} height={3*px} fill="#faf089"/>
            <rect x={10*px} y={1*px} width={1*px} height={2*px} fill="#f6e05e"/>
            {/* Arms/appendages */}
            <rect x={0*px} y={9*px} width={2*px} height={3*px} fill="#2d2040"/>
            <rect x={14*px} y={9*px} width={2*px} height={3*px} fill="#2d2040"/>
            {/* Legs */}
            <rect x={4*px} y={14*px} width={2*px} height={2*px} fill="#1a1020"/>
            <rect x={10*px} y={14*px} width={2*px} height={2*px} fill="#1a1020"/>
          </svg>
        )
      };

      return sprites[type] || sprites.fire;
    };

    // Main creature sprite component - uses PNG if available, falls back to SVG
    // Now supports 4-frame idle animations
    const CreatureSprite = ({ type, size = 48, isEnemy = false, scarCount = 0, isHollowed = false, bossPhase = 1, animated = true }) => {
      // Determine which sprite variant to use
      const useHollowed = isHollowed || scarCount >= SCAR_THRESHOLD_HOLLOWED;

      // Check if we have PNG sprite frames loaded for this type
      const isBossType = type === 'boss' || type === 'hollowWarden';
      let frames = null;

      if (isBossType) {
        const phaseKey = bossPhase === 2 ? 'phase2' : 'phase1';
        frames = preloadedSprites.creatures[type]?.[phaseKey]?.idle;
      } else {
        const variant = useHollowed ? 'hollowed' : 'base';
        frames = preloadedSprites.creatures[type]?.[variant]?.idle;
        // Fall back to base if hollowed not available
        if (!frames && useHollowed) {
          frames = preloadedSprites.creatures[type]?.base?.idle;
        }
      }

      // If PNG sprite frames are available, render animated sprite
      // Battle animations use 8fps (125ms) for more dynamic feel
      if (frames && frames.length > 0) {
        return (
          <AnimatedSprite
            frames={frames}
            frameRate={125}
            size={size}
            flip={isEnemy}
            filter={useHollowed && !isBossType ? 'saturate(0.5) brightness(0.8)' : 'none'}
            playing={animated}
          />
        );
      }

      // Fall back to SVG sprite (no animation)
      return <FallbackCreatureSprite type={type} size={size} isEnemy={isEnemy} />;
    };

    // Tile components - area-aware for distinct visual styles
    const GrassTile = ({ area = 'ashenPath' }) => {
      const palette = AREA_PALETTES[area] || AREA_PALETTES.ashenPath;
      const isHollow = area === 'hollowDeep';
      const isLabyrinth = area === 'labyrinth';

      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: palette.grassDark,
          position: 'relative',
          overflow: 'hidden',
          animation: isHollow ? 'voidPulse 3s ease-in-out infinite' :
                     isLabyrinth ? 'mazeGlow 4s ease-in-out infinite' : 'none'
        }}>
          {/* Grass blades pattern with area-specific colors */}
          <svg width="56" height="56" style={{
            position: 'absolute',
            top: 0,
            left: 0,
            animation: 'grassSway 2s ease-in-out infinite'
          }}>
            <rect x="6" y="16" width="3" height="12" fill={palette.grassMid}/>
            <rect x="6" y="13" width="3" height="3" fill={palette.grassLight}/>
            <rect x="16" y="20" width="3" height="14" fill={palette.grassMid}/>
            <rect x="16" y="17" width="3" height="3" fill={palette.grassLight}/>
            <rect x="28" y="14" width="3" height="16" fill={palette.grassMid}/>
            <rect x="28" y="11" width="3" height="3" fill={palette.grassLight}/>
            <rect x="40" y="18" width="3" height="12" fill={palette.grassMid}/>
            <rect x="40" y="15" width="3" height="3" fill={palette.grassLight}/>
            <rect x="50" y="16" width="3" height="14" fill={palette.grassMid}/>
            <rect x="50" y="13" width="3" height="3" fill={palette.grassLight}/>
            <rect x="11" y="34" width="3" height="12" fill={palette.grassMid}/>
            <rect x="22" y="38" width="3" height="12" fill={palette.grassMid}/>
            <rect x="34" y="32" width="3" height="14" fill={palette.grassMid}/>
            <rect x="45" y="36" width="3" height="14" fill={palette.grassMid}/>
          </svg>
          {/* Void particles for Hollow Deep */}
          {isHollow && (
            <>
              <div style={{
                position: 'absolute',
                top: '8px',
                left: '12px',
                width: '4px',
                height: '4px',
                backgroundColor: palette.void,
                borderRadius: '50%',
                animation: 'ember 2s infinite',
                opacity: 0.7
              }}/>
              <div style={{
                position: 'absolute',
                bottom: '12px',
                right: '10px',
                width: '3px',
                height: '3px',
                backgroundColor: palette.accent,
                borderRadius: '50%',
                animation: 'ember 2.5s infinite 0.5s',
                opacity: 0.6
              }}/>
            </>
          )}
        </div>
      );
    };

    const PathTile = ({ area = 'ashenPath' }) => {
      const palette = AREA_PALETTES[area] || AREA_PALETTES.ashenPath;
      const isKeep = area === 'fallenKeep';
      const isLabyrinth = area === 'labyrinth';

      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: palette.pathMid,
          position: 'relative',
          boxShadow: isLabyrinth ? `inset 0 0 8px ${palette.glow}` : 'none'
        }}>
          <svg width="56" height="56" style={{ position: 'absolute', top: 0, left: 0 }}>
            {/* Stone/dirt texture with area-specific colors */}
            <rect x="3" y="5" width="12" height="6" fill={palette.pathLight}/>
            <rect x="22" y="3" width="14" height="8" fill={palette.pathDark}/>
            <rect x="44" y="8" width="9" height="6" fill={palette.pathLight}/>
            <rect x="8" y="22" width="16" height="7" fill={palette.pathDark}/>
            <rect x="34" y="20" width="12" height="8" fill={palette.pathLight}/>
            <rect x="5" y="40" width="9" height="6" fill={palette.pathLight}/>
            <rect x="20" y="42" width="14" height="6" fill={palette.pathDark}/>
            <rect x="42" y="38" width="11" height="8" fill={palette.pathDark}/>
            {/* Labyrinth ancient runes */}
            {isLabyrinth && (
              <>
                <rect x="24" y="24" width="8" height="2" fill={palette.ancient} opacity="0.4"/>
                <rect x="26" y="22" width="2" height="6" fill={palette.ancient} opacity="0.3"/>
              </>
            )}
          </svg>
          {/* Ashen wind particles for Ashen Path */}
          {area === 'ashenPath' && Math.random() > 0.7 && (
            <div style={{
              position: 'absolute',
              top: '20px',
              left: '10px',
              width: '6px',
              height: '2px',
              backgroundColor: palette.accent,
              animation: 'ashenWind 3s ease-in-out infinite',
              opacity: 0.4
            }}/>
          )}
        </div>
      );
    };

    const WallTile = ({ area = 'ashenPath' }) => {
      const palette = AREA_PALETTES[area] || AREA_PALETTES.ashenPath;
      const isKeep = area === 'fallenKeep';
      const isHollow = area === 'hollowDeep';
      const isLabyrinth = area === 'labyrinth';

      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: palette.wallDark,
          position: 'relative',
          boxShadow: isHollow ? `inset 0 0 12px ${palette.glow}` :
                     isLabyrinth ? `inset 0 0 6px ${palette.glow}` : 'none'
        }}>
          <svg width="56" height="56" style={{ position: 'absolute', top: 0, left: 0 }}>
            {/* Brick pattern with area-specific colors */}
            <rect x="0" y="0" width="26" height="13" fill={palette.wallMid} stroke={palette.wallDark} strokeWidth="1"/>
            <rect x="28" y="0" width="28" height="13" fill={palette.wallMid} stroke={palette.wallDark} strokeWidth="1"/>
            <rect x="0" y="14" width="14" height="13" fill={palette.wallLight} stroke={palette.wallDark} strokeWidth="1"/>
            <rect x="16" y="14" width="26" height="13" fill={palette.wallMid} stroke={palette.wallDark} strokeWidth="1"/>
            <rect x="44" y="14" width="12" height="13" fill={palette.wallLight} stroke={palette.wallDark} strokeWidth="1"/>
            <rect x="0" y="28" width="22" height="13" fill={palette.wallMid} stroke={palette.wallDark} strokeWidth="1"/>
            <rect x="24" y="28" width="32" height="13" fill={palette.wallLight} stroke={palette.wallDark} strokeWidth="1"/>
            <rect x="0" y="42" width="12" height="14" fill={palette.wallLight} stroke={palette.wallDark} strokeWidth="1"/>
            <rect x="14" y="42" width="26" height="14" fill={palette.wallMid} stroke={palette.wallDark} strokeWidth="1"/>
            <rect x="42" y="42" width="14" height="14" fill={palette.wallMid} stroke={palette.wallDark} strokeWidth="1"/>
            {/* Hollow Deep void cracks */}
            {isHollow && (
              <>
                <line x1="10" y1="20" x2="18" y2="35" stroke={palette.void} strokeWidth="2" opacity="0.6"/>
                <line x1="40" y1="8" x2="45" y2="22" stroke={palette.accent} strokeWidth="1" opacity="0.4"/>
              </>
            )}
            {/* Labyrinth ancient symbols */}
            {isLabyrinth && (
              <>
                <circle cx="28" cy="28" r="6" fill="none" stroke={palette.ancient} strokeWidth="1" opacity="0.3"/>
                <rect x="25" y="25" width="6" height="6" fill="none" stroke={palette.mystery} strokeWidth="1" opacity="0.2"/>
              </>
            )}
          </svg>
        </div>
      );
    };

    const BonfireTile = ({ area = 'ashenPath' }) => {
      const palette = AREA_PALETTES[area] || AREA_PALETTES.ashenPath;

      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: palette.pathDark,
          position: 'relative',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          {/* Fire base */}
          <div style={{
            position: 'absolute',
            bottom: '6px',
            width: '32px',
            height: '10px',
            backgroundColor: '#4a3728',
            borderRadius: '2px'
          }}/>
          {/* Animated flames */}
          <svg width="44" height="44" style={{ animation: 'flicker 0.5s infinite', position: 'relative', zIndex: 1 }}>
            {/* Outer flame */}
            <rect x="10" y="22" width="24" height="16" fill="#ed8936"/>
            <rect x="13" y="16" width="18" height="8" fill="#f6ad55"/>
            <rect x="16" y="10" width="12" height="8" fill="#f6e05e"/>
            <rect x="19" y="4" width="6" height="8" fill="#faf089"/>
            {/* Inner bright core */}
            <rect x="16" y="26" width="12" height="8" fill="#faf089"/>
            <rect x="19" y="20" width="6" height="8" fill="#fffff0"/>
          </svg>
          {/* Embers */}
          <div style={{
            position: 'absolute',
            top: '10px',
            left: '16px',
            width: '5px',
            height: '5px',
            backgroundColor: '#f6e05e',
            animation: 'ember 1s infinite',
            animationDelay: '0s'
          }}/>
          <div style={{
            position: 'absolute',
            top: '12px',
            right: '18px',
            width: '4px',
            height: '4px',
            backgroundColor: '#ed8936',
            animation: 'ember 1.2s infinite',
            animationDelay: '0.3s'
          }}/>
          {/* Area-specific glow */}
          <div style={{
            position: 'absolute',
            width: '100%',
            height: '100%',
            boxShadow: `inset 0 0 20px rgba(237, 137, 54, 0.3)`,
            pointerEvents: 'none'
          }}/>
        </div>
      );
    };

    const GateTile = ({ isKeep = false, area = 'ashenPath' }) => {
      const palette = AREA_PALETTES[area] || AREA_PALETTES.ashenPath;

      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: isKeep ? palette.wallMid : palette.pathMid,
          position: 'relative',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          <svg width="50" height="50" style={{ imageRendering: 'pixelated' }}>
            {/* Torii gate / dungeon entrance */}
            {/* Pillars */}
            <rect x="6" y="12" width="6" height="38" fill="#742a2a"/>
            <rect x="38" y="12" width="6" height="38" fill="#742a2a"/>
            {/* Top beam */}
            <rect x="3" y="6" width="44" height="6" fill="#9b2c2c"/>
            <rect x="0" y="3" width="50" height="5" fill="#c53030"/>
            {/* Cross beam */}
            <rect x="6" y="16" width="38" height="4" fill="#742a2a"/>
            {/* Entrance darkness */}
            <rect x="14" y="22" width="22" height="28" fill="#0f0f1a"/>
          </svg>
        </div>
      );
    };

    const BossRoomTile = ({ area = 'ashenPath' }) => {
      const palette = AREA_PALETTES[area] || AREA_PALETTES.ashenPath;
      const isHollow = area === 'hollowDeep';
      const eyeColor = isHollow ? '#9f7aea' : '#c53030';
      const eyeColor2 = isHollow ? '#faf089' : '#c53030';

      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: isHollow ? '#0d0a14' : '#1a0a0a',
          position: 'relative',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          animation: isHollow ? 'voidPulse 2s ease-in-out infinite' : 'none'
        }}>
          <svg width="50" height="50" style={{ imageRendering: 'pixelated' }}>
            {/* Skull */}
            <rect x="13" y="10" width="24" height="20" fill={isHollow ? '#a0a0b0' : '#e8e8e8'}/>
            <rect x="10" y="13" width="3" height="14" fill={isHollow ? '#a0a0b0' : '#e8e8e8'}/>
            <rect x="37" y="13" width="3" height="14" fill={isHollow ? '#a0a0b0' : '#e8e8e8'}/>
            {/* Eye sockets */}
            <rect x="16" y="16" width="6" height="7" fill={isHollow ? '#0d0a14' : '#1a0a0a'}/>
            <rect x="28" y="16" width="6" height="7" fill={isHollow ? '#0d0a14' : '#1a0a0a'}/>
            {/* Glowing eyes */}
            <rect x="18" y="18" width="3" height="3" fill={eyeColor}/>
            <rect x="30" y="18" width="3" height="3" fill={eyeColor2}/>
            {/* Nose */}
            <rect x="22" y="25" width="6" height="4" fill={isHollow ? '#0d0a14' : '#1a0a0a'}/>
            {/* Teeth */}
            <rect x="16" y="30" width="18" height="6" fill={isHollow ? '#a0a0b0' : '#e8e8e8'}/>
            <rect x="19" y="30" width="3" height="6" fill={isHollow ? '#0d0a14' : '#1a0a0a'}/>
            <rect x="25" y="30" width="3" height="6" fill={isHollow ? '#0d0a14' : '#1a0a0a'}/>
            <rect x="31" y="30" width="3" height="6" fill={isHollow ? '#0d0a14' : '#1a0a0a'}/>
            {/* Jaw */}
            <rect x="13" y="36" width="24" height="6" fill={isHollow ? '#8080a0' : '#d4d4d4'}/>
          </svg>
        </div>
      );
    };

    // Torch tile for Fallen Keep atmosphere
    const TorchTile = ({ area = 'fallenKeep' }) => {
      const palette = AREA_PALETTES[area] || AREA_PALETTES.fallenKeep;

      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: palette.wallMid,
          position: 'relative',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          <svg width="56" height="56" style={{ position: 'absolute', top: 0, left: 0 }}>
            {/* Wall base */}
            <rect x="0" y="0" width="56" height="56" fill={palette.wallMid}/>
            {/* Torch bracket */}
            <rect x="22" y="20" width="12" height="4" fill="#4a3728"/>
            <rect x="24" y="24" width="8" height="16" fill="#5a4a3a"/>
            {/* Torch head */}
            <rect x="23" y="10" width="10" height="12" fill="#6b5040"/>
          </svg>
          {/* Animated flame */}
          <svg width="20" height="20" style={{
            position: 'absolute',
            top: '2px',
            animation: 'torchFlicker 0.4s infinite'
          }}>
            <rect x="4" y="10" width="12" height="8" fill="#ed8936"/>
            <rect x="6" y="6" width="8" height="6" fill="#f6ad55"/>
            <rect x="7" y="2" width="6" height="6" fill="#f6e05e"/>
            <rect x="8" y="0" width="4" height="4" fill="#faf089"/>
          </svg>
          {/* Light glow effect */}
          <div style={{
            position: 'absolute',
            width: '100%',
            height: '100%',
            background: `radial-gradient(circle at 50% 30%, ${palette.glow} 0%, transparent 60%)`,
            pointerEvents: 'none'
          }}/>
        </div>
      );
    };

    // Ashen Gate - massive door at end of Labyrinth
    const AshenGateTile = ({ area = 'labyrinth' }) => {
      const palette = AREA_PALETTES.labyrinth;

      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: palette.wallDark,
          position: 'relative',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          animation: 'mazeGlow 3s ease-in-out infinite'
        }}>
          <svg width="56" height="56" style={{ imageRendering: 'pixelated' }}>
            {/* Massive door frame */}
            <rect x="4" y="2" width="48" height="52" fill="#2a2520"/>
            <rect x="8" y="6" width="40" height="44" fill="#1a1510"/>
            {/* Door panels */}
            <rect x="10" y="8" width="16" height="40" fill="#3a3530" stroke="#2a2520" strokeWidth="1"/>
            <rect x="30" y="8" width="16" height="40" fill="#3a3530" stroke="#2a2520" strokeWidth="1"/>
            {/* Ancient runes */}
            <rect x="16" y="14" width="4" height="8" fill={palette.ancient} opacity="0.6"/>
            <rect x="36" y="14" width="4" height="8" fill={palette.ancient} opacity="0.6"/>
            {/* Central emblem - flame symbol */}
            <rect x="24" y="20" width="8" height="12" fill={palette.ancient}/>
            <rect x="26" y="16" width="4" height="6" fill={palette.ancient}/>
            <rect x="27" y="12" width="2" height="6" fill="#faf089"/>
            {/* Door handles */}
            <circle cx="24" cy="36" r="3" fill="#8b7355"/>
            <circle cx="32" cy="36" r="3" fill="#8b7355"/>
          </svg>
          {/* Mystical glow */}
          <div style={{
            position: 'absolute',
            width: '100%',
            height: '100%',
            background: `radial-gradient(ellipse at 50% 50%, rgba(246, 224, 94, 0.2) 0%, transparent 70%)`,
            animation: 'lorePulse 2s ease-in-out infinite',
            pointerEvents: 'none'
          }}/>
        </div>
      );
    };

    // Secret door tile - hidden until revealed
    const SecretDoorTile = ({ revealed = false, area = 'labyrinth' }) => {
      const palette = AREA_PALETTES[area] || AREA_PALETTES.labyrinth;

      if (!revealed) {
        // Looks like a normal wall with subtle cracks
        return (
          <div style={{
            width: '100%',
            height: '100%',
            backgroundColor: palette.wallDark,
            position: 'relative'
          }}>
            <svg width="56" height="56" style={{ position: 'absolute', top: 0, left: 0 }}>
              <rect x="0" y="0" width="56" height="56" fill={palette.wallMid}/>
              {/* Subtle cracks - hint */}
              <line x1="10" y1="15" x2="18" y2="42" stroke={palette.wallLight} strokeWidth="1" opacity="0.5"/>
              <line x1="38" y1="12" x2="45" y2="45" stroke={palette.wallLight} strokeWidth="1" opacity="0.5"/>
              <line x1="10" y1="42" x2="46" y2="44" stroke={palette.wallLight} strokeWidth="1" opacity="0.4"/>
            </svg>
          </div>
        );
      }

      // Revealed secret door
      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: palette.wallDark,
          position: 'relative',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          <svg width="56" height="56" style={{ imageRendering: 'pixelated' }}>
            {/* Door frame */}
            <rect x="8" y="4" width="40" height="48" fill="#1a1510"/>
            <rect x="12" y="8" width="32" height="40" fill="#0f0f1a"/>
            {/* Ancient markings */}
            <rect x="14" y="12" width="2" height="30" fill={palette.ancient} opacity="0.4"/>
            <rect x="40" y="12" width="2" height="30" fill={palette.ancient} opacity="0.4"/>
          </svg>
          {/* Shimmer effect */}
          <div style={{
            position: 'absolute',
            width: '100%',
            height: '100%',
            animation: 'secretShimmer 2s ease-in-out infinite',
            pointerEvents: 'none'
          }}/>
        </div>
      );
    };

    // Lore object indicator tile - shows examinable props
    const LoreObjectTile = ({ objectType = 'generic', area = 'ashenPath' }) => {
      const palette = AREA_PALETTES[area] || AREA_PALETTES.ashenPath;

      const renderObject = () => {
        switch (objectType) {
          case 'statue':
            return (
              <svg width="40" height="48" style={{ imageRendering: 'pixelated' }}>
                {/* Statue base */}
                <rect x="8" y="40" width="24" height="8" fill="#5a5a60"/>
                {/* Body */}
                <rect x="12" y="20" width="16" height="22" fill="#7a7a85"/>
                {/* Head */}
                <rect x="14" y="10" width="12" height="12" fill="#8a8a95"/>
                {/* Arms */}
                <rect x="6" y="24" width="6" height="12" fill="#7a7a85"/>
                <rect x="28" y="24" width="6" height="12" fill="#7a7a85"/>
              </svg>
            );
          case 'altar':
            return (
              <svg width="48" height="40" style={{ imageRendering: 'pixelated' }}>
                {/* Altar base */}
                <rect x="4" y="28" width="40" height="12" fill="#5a4a3a"/>
                <rect x="8" y="20" width="32" height="10" fill="#6b5a4a"/>
                {/* Candles */}
                <rect x="12" y="14" width="4" height="8" fill="#e8e8e0"/>
                <rect x="32" y="14" width="4" height="8" fill="#e8e8e0"/>
                {/* Flames */}
                <rect x="13" y="10" width="2" height="4" fill="#f6ad55"/>
                <rect x="33" y="10" width="2" height="4" fill="#f6ad55"/>
              </svg>
            );
          case 'bones':
            return (
              <svg width="44" height="36" style={{ imageRendering: 'pixelated' }}>
                {/* Scattered bones */}
                <rect x="4" y="24" width="16" height="4" fill="#e8e8d8" transform="rotate(-15 12 26)"/>
                <rect x="24" y="20" width="14" height="4" fill="#e0e0d0" transform="rotate(20 31 22)"/>
                <rect x="10" y="12" width="10" height="4" fill="#d8d8c8" transform="rotate(-5 15 14)"/>
                {/* Skull */}
                <circle cx="34" cy="10" r="6" fill="#e8e8d8"/>
                <rect x="31" y="8" width="2" height="2" fill="#1a1a1a"/>
                <rect x="35" y="8" width="2" height="2" fill="#1a1a1a"/>
              </svg>
            );
          case 'torch':
            return (
              <svg width="24" height="48" style={{ imageRendering: 'pixelated' }}>
                {/* Torch handle */}
                <rect x="8" y="20" width="8" height="28" fill="#5a4a3a"/>
                {/* Torch head */}
                <rect x="6" y="14" width="12" height="8" fill="#6b5040"/>
                {/* Flame */}
                <rect x="8" y="6" width="8" height="10" fill="#ed8936"/>
                <rect x="9" y="2" width="6" height="6" fill="#f6ad55"/>
                <rect x="10" y="0" width="4" height="4" fill="#f6e05e"/>
              </svg>
            );
          case 'chest':
            return (
              <svg width="40" height="32" style={{ imageRendering: 'pixelated' }}>
                {/* Chest body */}
                <rect x="4" y="12" width="32" height="20" fill="#8b7355"/>
                <rect x="4" y="8" width="32" height="8" fill="#a08060" rx="2"/>
                {/* Metal bands */}
                <rect x="4" y="16" width="32" height="3" fill="#4a4a50"/>
                <rect x="4" y="24" width="32" height="3" fill="#4a4a50"/>
                {/* Lock */}
                <rect x="16" y="18" width="8" height="6" fill="#d69e2e"/>
                <rect x="18" y="20" width="4" height="2" fill="#1a1a1a"/>
              </svg>
            );
          default:
            return (
              <svg width="32" height="32" style={{ imageRendering: 'pixelated' }}>
                <rect x="8" y="8" width="16" height="16" fill={palette.accent} opacity="0.6"/>
              </svg>
            );
        }
      };

      return (
        <div style={{
          width: '100%',
          height: '100%',
          backgroundColor: palette.pathMid,
          position: 'relative',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          {/* Base path texture */}
          <svg width="56" height="56" style={{ position: 'absolute', top: 0, left: 0 }}>
            <rect x="3" y="5" width="12" height="6" fill={palette.pathLight}/>
            <rect x="22" y="3" width="14" height="8" fill={palette.pathDark}/>
            <rect x="44" y="8" width="9" height="6" fill={palette.pathLight}/>
          </svg>
          {/* Object */}
          <div style={{ position: 'relative', zIndex: 2 }}>
            {renderObject()}
          </div>
          {/* Lore indicator glow */}
          <div style={{
            position: 'absolute',
            bottom: '4px',
            width: '8px',
            height: '8px',
            backgroundColor: GBC.gold,
            borderRadius: '50%',
            animation: 'lorePulse 1.5s ease-in-out infinite',
            boxShadow: '0 0 6px rgba(246, 224, 94, 0.8)'
          }}/>
        </div>
      );
    };


    // ============= BATTLE HELPERS =============
    function handleCreatureFaint(state, team, enemy, log) {
      const difficulty = getDifficulty(state);
      const activeCreature = team[state.activeCreatureIndex];
      const scar = getRandomScar(difficulty);

      activeCreature.hp = 0;
      activeCreature.scars = [...(activeCreature.scars || []), scar];

      log.push(`${activeCreature.nickname || activeCreature.name} has fallen!`);
      const scarMessages = [
        `${activeCreature.nickname || activeCreature.name} gained a scar. It's a look.`,
        `Another scar for ${activeCreature.nickname || activeCreature.name}. Basically tattoos at this point.`
      ];
      log.push(scarMessages[Math.floor(Math.random() * scarMessages.length)]);
      log.push(`  → ${scar.name}: ${scar.description}`);

      if (activeCreature.scars.length >= difficulty.hollowedThreshold) {
        log.push(`${activeCreature.nickname || activeCreature.name} has become Hollowed...`);
      }

      team[state.activeCreatureIndex] = activeCreature;

      const availableIndex = team.findIndex((c, i) => i !== state.activeCreatureIndex && c.hp > 0);

      if (availableIndex === -1) {
        // Calculate souls to drop based on difficulty
        let soulsToDrop = Math.floor(state.souls * difficulty.soulDropPercent);
        if (difficulty.dropBankedSouls) {
          soulsToDrop += state.bankedSouls;
        }

        const droppedSouls = soulsToDrop > 0 ? {
          map: state.currentMap,
          pos: { ...state.playerPos },
          amount: soulsToDrop
        } : state.droppedSouls;

        // Add boss death dialogue if dying to boss
        if (state.isBossFight) {
          BOSS_DIALOGUE.playerDeath.forEach(line => log.push(line));
        }

        return {
          ...state,
          screen: 'gameOver',
          team,
          enemy,
          battleLog: log,
          souls: 0,
          bankedSouls: difficulty.dropBankedSouls ? 0 : state.bankedSouls,
          droppedSouls,
          diedToBoss: state.isBossFight
        };
      }

      return {
        ...state,
        team,
        enemy,
        battleLog: log,
        activeCreatureIndex: availableIndex,
        turnPhase: 'player'
      };
    }

    // ============= GAME REDUCER =============
    function gameReducer(state, action) {
      switch (action.type) {
        case 'CREATE_CHARACTER': {
          if (!action.name || !action.appearance) return state;
          return {
            ...state,
            playerName: action.name.trim(),
            playerAppearance: action.appearance,
            screen: 'difficulty'
          };
        }

        case 'SELECT_DIFFICULTY': {
          return {
            ...state,
            difficulty: action.difficulty,
            screen: 'starter'
          };
        }

        case 'SELECT_STARTER': {
          const starterData = STARTERS[action.starter];
          const newCreature = {
            ...starterData,
            hp: starterData.maxHp,
            stamina: starterData.maxStamina,
            scars: [],
            winded: false,
            isGuarding: false,
            burnTurns: 0,
            poisonTurns: 0,
            chillTurns: 0
          };
          // Show prologue on first playthrough
          const nextScreen = state.hasSeenPrologue ? 'exploration' : 'prologue';
          return {
            ...state,
            screen: nextScreen,
            team: [newCreature]
          };
        }

        case 'CONTINUE_FROM_PROLOGUE': {
          return {
            ...state,
            screen: 'exploration',
            hasSeenPrologue: true
          };
        }

        case 'EXAMINE_TILE': {
          const key = `${state.playerPos.x},${state.playerPos.y}`;
          const lore = TILE_LORE[state.currentMap]?.[key];

          // Labyrinth secret room clue tracking
          const LABYRINTH_CLUES = ['16,1', '1,7', '4,15', '17,17'];
          const isLabyrinthClue = state.currentMap === 'labyrinth' && LABYRINTH_CLUES.includes(key);
          const isSecretDoor = state.currentMap === 'labyrinth' && key === '15,9';

          if (lore) {
            let newState = { ...state, examineText: lore };

            // Track clue discovery
            if (isLabyrinthClue && !state.cluesFound.includes(key)) {
              const newClues = [...state.cluesFound, key];
              newState.cluesFound = newClues;

              // All 4 clues found - reveal secret door
              if (newClues.length >= 4) {
                newState.secretDoorRevealed = true;
                newState.saveNotification = 'Something shifts in the labyrinth...';
                // Append hint to current lore text
                newState.examineText = {
                  ...newState.examineText,
                  lines: [...(newState.examineText.lines || []), '', '...A distant sound of grinding stone echoes through the maze.']
                };
              }
            }

            // Special lore when examining revealed secret door
            if (isSecretDoor && state.secretDoorRevealed) {
              newState.examineText = {
                name: 'Hidden Chamber',
                lines: [
                  'The wall yields to your knowledge.',
                  '',
                  'A hidden chamber opens before you.'
                ]
              };
              // Award title for discovering the secret
              if (!state.titles.includes('ashen_seeker')) {
                newState.titles = [...state.titles, 'ashen_seeker'];
                newState.activeTitle = 'ashen_seeker';
                newState.saveNotification = 'Title earned: Ashen Seeker';
              }
            }

            return newState;
          }
          return state;
        }

        case 'CLOSE_EXAMINE': {
          return {
            ...state,
            examineText: null
          };
        }

        case 'MOVE_PLAYER': {
          const map = state.currentMap === 'ashenPath' ? ASHEN_PATH :
                      state.currentMap === 'hollowDeep' ? HOLLOW_DEEP :
                      state.currentMap === 'labyrinth' ? LABYRINTH : FALLEN_KEEP;
          const newX = state.playerPos.x + action.dx;
          const newY = state.playerPos.y + action.dy;

          // Determine direction
          let dir = state.playerDir;
          if (action.dy < 0) dir = 'up';
          else if (action.dy > 0) dir = 'down';
          else if (action.dx < 0) dir = 'left';
          else if (action.dx > 0) dir = 'right';

          if (newY < 0 || newY >= map.length || newX < 0 || newX >= map[0].length) {
            return { ...state, playerDir: dir };
          }

          const tile = map[newY][newX];

          if (tile === 'W') return { ...state, playerDir: dir };

          // Secret door blocks movement until revealed
          if (tile === 'S' && !state.secretDoorRevealed) {
            return { ...state, playerDir: dir };
          }

          // Walking into revealed secret door awards Ashen Seeker title
          if (tile === 'S' && state.secretDoorRevealed) {
            let sState = { ...state, playerPos: { x: newX, y: newY }, playerDir: dir, bonfireMenuOpen: false, withdrawMenuOpen: false, depositMenuOpen: false };
            sState.examineText = {
              name: 'The Hidden Chamber',
              lines: [
                'The wall crumbles. Beyond, a small chamber.',
                '',
                'A single flame burns in the darkness.',
                '',
                'You have found what others could not.',
                '',
                'You are an Ashen Seeker.'
              ]
            };
            if (!state.titles.includes('ashen_seeker')) {
              sState.titles = [...state.titles, 'ashen_seeker'];
              sState.activeTitle = 'ashen_seeker';
              sState.saveNotification = 'Title earned: Ashen Seeker';
            }
            return sState;
          }

          let newState = { ...state, playerPos: { x: newX, y: newY }, playerDir: dir, bonfireMenuOpen: false, withdrawMenuOpen: false, depositMenuOpen: false };

          if (tile === 'G' && (state.currentMap === 'ashenPath' || state.currentMap === 'hollowDeep' || state.currentMap === 'labyrinth')) {
            const encounter = state.grassEncounters.find(
              e => e.x === newX && e.y === newY && e.map === state.currentMap && e.active
            );
            if (encounter && !encounter.alerted && Math.random() < 0.6) {
              const wildData = state.currentMap === 'labyrinth' ? getRandomLabyrinthWild() : state.currentMap === 'hollowDeep' ? getRandomDeepWild() : getRandomWild();
              // Apply scar penalties if pre-scarred
              let actualMaxHp = wildData.maxHp;
              let actualMaxStamina = wildData.maxStamina;
              if (wildData.scars) {
                wildData.scars.forEach(scar => {
                  if (scar.effect === 'maxHp') actualMaxHp = Math.max(15, actualMaxHp + scar.value);
                  if (scar.effect === 'maxStamina') actualMaxStamina = Math.max(8, actualMaxStamina + scar.value);
                });
              }
              // Show pre-battle preview instead of immediately starting battle
              newState = {
                ...newState,
                screen: 'encounterPreview',
                pendingEncounter: {
                  wildData,
                  actualMaxHp,
                  actualMaxStamina,
                  encounter: { x: newX, y: newY }
                }
              };
            }
          }

          if (tile === 'X') {
            newState = {
              ...newState,
              currentMap: 'fallenKeep',
              playerPos: { x: 2, y: 7 }
            };
          }

          if (tile === 'E' && state.currentMap === 'fallenKeep') {
            newState = {
              ...newState,
              currentMap: 'ashenPath',
              playerPos: { x: 2, y: 6 }
            };
          }

          if (tile === 'K' && state.currentMap === 'fallenKeep' && !state.bossDefeated) {
            const bossData = BOSS.obsidianHound;
            const difficulty = getDifficulty(state);
            const bossMaxHp = Math.floor(bossData.maxHp * difficulty.bossHpMult);
            newState = {
              ...newState,
              screen: 'battle',
              enemy: {
                ...bossData,
                maxHp: bossMaxHp,
                hp: bossMaxHp,
                stamina: bossData.maxStamina,
                winded: false,
                isGuarding: false
              },
              enemyCreature: { ...bossData, maxHp: bossMaxHp },
              battleLog: [
                'Keeper Varek blocks your path!',
                ...BOSS_DIALOGUE.intro
              ],
              turnPhase: 'player',
              bossPhase: 1,
              arenaEffect: null,
              isBossFight: true
            };
          }

          // Enter The Hollow Deep after defeating Varek
          if (tile === 'K' && state.currentMap === 'fallenKeep' && state.bossDefeated && !state.hollowWardenDefeated) {
            newState = {
              ...newState,
              currentMap: 'hollowDeep',
              playerPos: { x: 3, y: 7 }
            };
          }

          // Exit The Hollow Deep back to Fallen Keep
          if (tile === 'E' && state.currentMap === 'hollowDeep') {
            newState = {
              ...newState,
              currentMap: 'fallenKeep',
              playerPos: { x: 1, y: 6 }
            };
          }

          // Enter The Labyrinth from Hollow Deep (X tile at 8,14)
          if (tile === 'X' && state.currentMap === 'hollowDeep') {
            newState = {
              ...newState,
              currentMap: 'labyrinth',
              playerPos: { x: 9, y: 17 }
            };
          }

          // Exit The Labyrinth back to Hollow Deep (E tile at 9,18)
          if (tile === 'E' && state.currentMap === 'labyrinth') {
            newState = {
              ...newState,
              currentMap: 'hollowDeep',
              playerPos: { x: 8, y: 13 }
            };
          }

          // Hollow Warden boss fight
          if (tile === 'K' && state.currentMap === 'hollowDeep' && !state.hollowWardenDefeated) {
            const bossData = BOSS.hollowWarden;
            const difficulty = getDifficulty(state);
            const bossMaxHp = Math.floor(bossData.maxHp * difficulty.bossHpMult);
            newState = {
              ...newState,
              screen: 'battle',
              enemy: {
                ...bossData,
                maxHp: bossMaxHp,
                hp: bossMaxHp,
                stamina: bossData.maxStamina,
                winded: false,
                isGuarding: false
              },
              enemyCreature: { ...bossData, maxHp: bossMaxHp },
              battleLog: [
                'The Hollow Warden awakens!',
                ...HOLLOW_WARDEN_DIALOGUE.intro
              ],
              turnPhase: 'player',
              bossPhase: 1,
              arenaEffect: null,
              isBossFight: true,
              isHollowWardenFight: true
            };
          }

          if (state.droppedSouls &&
              state.droppedSouls.map === state.currentMap &&
              state.droppedSouls.pos.x === newX &&
              state.droppedSouls.pos.y === newY) {
            newState = {
              ...newState,
              souls: state.souls + state.droppedSouls.amount,
              droppedSouls: null,
              battleLog: [`Recovered ${state.droppedSouls.amount} souls!`]
            };
          }

          if (state.currentMap === 'fallenKeep' && newY <= 3) {
            newState.shortcutUnlocked = true;
          }

          return newState;
        }

        case 'INTERACT_BONFIRE': {
          // Toggle bonfire menu
          return {
            ...state,
            bonfireMenuOpen: !state.bonfireMenuOpen
          };
        }

        case 'REST_AT_BONFIRE': {
          const difficulty = getDifficulty(state);

          const team = state.team.map(creature => {
            const baseData = STARTERS[creature.id];
            // Clear scars on Ashen difficulty
            const scars = difficulty.scarsHealAtBonfire ? [] : creature.scars;
            const creatureWithScars = { ...creature, scars };
            const { maxHp, maxStamina } = applyScars(creatureWithScars, baseData, difficulty.hollowedThreshold);

            // Broken difficulty: bonfire doesn't heal HP
            if (!difficulty.bonfireHeals) {
              return {
                ...creature,
                scars,
                stamina: maxStamina,
                winded: false,
                burnTurns: 0,
                poisonTurns: 0,
                chillTurns: 0
              };
            }

            return {
              ...creature,
              scars,
              hp: creature.hp === 0 ? 1 : maxHp,
              stamina: maxStamina,
              winded: false,
              burnTurns: 0,
              poisonTurns: 0,
              chillTurns: 0
            };
          });

          const grassEncounters = state.grassEncounters.map(e => ({ ...e, active: true }));

          const bonfireMessages = [
            "Progress saved. Enemies respawned. Life is compromise.",
            "Rested. Ready to make the same mistakes."
          ];
          const saveMessage = difficulty.bonfireHeals
            ? bonfireMessages[Math.floor(Math.random() * bonfireMessages.length)]
            : "Progress saved. No healing. Broken mode is fun, right?";

          const newState = {
            ...state,
            team,
            grassEncounters,
            bankedSouls: state.bankedSouls + state.souls,
            souls: 0,
            lastBonfire: { map: state.currentMap, pos: { ...state.playerPos } },
            bonfireMenuOpen: false,
            withdrawMenuOpen: false,
            depositMenuOpen: false,
            saveNotification: saveMessage
          };

          // Auto-save when resting
          saveGame(newState);

          return newState;
        }

        case 'CLEAR_NOTIFICATION': {
          return {
            ...state,
            saveNotification: null
          };
        }

        case 'SWITCH_ACTIVE_AT_BONFIRE': {
          // Can only switch to creatures with HP > 0
          const targetCreature = state.team[action.index];
          if (!targetCreature || targetCreature.hp <= 0) {
            return state;
          }
          return {
            ...state,
            activeCreatureIndex: action.index,
            bonfireMenuOpen: false
          };
        }

        case 'CLOSE_BONFIRE_MENU': {
          return {
            ...state,
            bonfireMenuOpen: false,
            withdrawMenuOpen: false,
            depositMenuOpen: false
          };
        }

        case 'TOGGLE_WITHDRAW_MENU': {
          return {
            ...state,
            withdrawMenuOpen: !state.withdrawMenuOpen
          };
        }

        case 'WITHDRAW_SOULS': {
          const amount = Math.min(action.amount, state.bankedSouls);
          if (amount <= 0) return state;
          const newState = {
            ...state,
            souls: state.souls + amount,
            bankedSouls: state.bankedSouls - amount,
            withdrawMenuOpen: false
          };
          saveGame(newState);
          return newState;
        }

        case 'TOGGLE_DEPOSIT_MENU': {
          return {
            ...state,
            depositMenuOpen: !state.depositMenuOpen
          };
        }

        case 'DEPOSIT_SOULS': {
          const amount = Math.min(action.amount, state.souls);
          if (amount <= 0) return state;
          const newState = {
            ...state,
            souls: state.souls - amount,
            bankedSouls: state.bankedSouls + amount,
            depositMenuOpen: false
          };
          saveGame(newState);
          return newState;
        }

        case 'SELECT_MOVE': {
          const activeCreature = state.team[state.activeCreatureIndex];
          // Check Flinching scar - strip priority at resolution time
          const { hasFlinching } = applyScars(activeCreature, STARTERS[activeCreature.id]);
          const move = action.move.priority && hasFlinching ? { ...action.move, priority: false } : action.move;

          if (move.cost > activeCreature.stamina) return state;

          let newTeam = [...state.team];
          let newEnemy = { ...state.enemy };
          let log = [...state.battleLog];
          let turnPhase = 'enemy';

          if (move.effect === 'rest') {
            newTeam[state.activeCreatureIndex] = {
              ...activeCreature,
              stamina: Math.min(activeCreature.stamina + 8 + 4,
                applyScars(activeCreature, STARTERS[activeCreature.id]).maxStamina),
              winded: false,
              isGuarding: false
            };
            log.push(`${activeCreature.nickname || activeCreature.name} rests and recovers stamina.`);
            return { ...state, team: newTeam, battleLog: log, turnPhase };
          }

          // Purifying Light - removes all status effects and heals
          if (move.effect === 'purify') {
            const baseData = STARTERS[activeCreature.id];
            const { maxHp } = applyScars(activeCreature, baseData);
            newTeam[state.activeCreatureIndex] = {
              ...activeCreature,
              hp: Math.min(activeCreature.hp + (move.healAmount || 10), maxHp),
              stamina: activeCreature.stamina - move.cost,
              burnTurns: 0,
              poisonTurns: 0,
              chillTurns: 0,
              winded: false,
              isGuarding: false
            };
            log.push(`${activeCreature.nickname || activeCreature.name} used ${move.name}!`);
            log.push(`${activeCreature.nickname || activeCreature.name} is purified and healed!`);
            if (newTeam[state.activeCreatureIndex].stamina < 5) {
              newTeam[state.activeCreatureIndex].winded = true;
              log.push(`${activeCreature.nickname || activeCreature.name} is winded!`);
            }
            return { ...state, team: newTeam, battleLog: log, turnPhase };
          }

          if (move.effect === 'guard') {
            newTeam[state.activeCreatureIndex] = {
              ...activeCreature,
              stamina: activeCreature.stamina - move.cost,
              isGuarding: true
            };
            log.push(`${activeCreature.nickname || activeCreature.name} takes a defensive stance.`);

            if (activeCreature.stamina - move.cost < 5) {
              newTeam[state.activeCreatureIndex].winded = true;
              log.push(`${activeCreature.nickname || activeCreature.name} is winded!`);
            }

            return { ...state, team: newTeam, battleLog: log, turnPhase };
          }

          const damage = calculateDamage(move, activeCreature, newEnemy,
            STARTERS[activeCreature.id], state.enemyCreature);

          newEnemy.hp = Math.max(0, newEnemy.hp - damage);
          newEnemy.isGuarding = false;

          const effectiveness = TYPE_CHART[STARTERS[activeCreature.id].type][state.enemyCreature.type];
          let effectText = '';
          if (effectiveness > 1) effectText = " It's super effective!";
          if (effectiveness < 1) effectText = " It's not very effective...";

          log.push(`${activeCreature.nickname || activeCreature.name} used ${move.name}! ${damage} damage.${effectText}`);

          // Apply status effects to enemy based on move
          if (move.effect && move.effectChance && Math.random() * 100 < move.effectChance) {
            if (move.effect === 'burn' && (!newEnemy.burnTurns || newEnemy.burnTurns === 0)) {
              newEnemy.burnTurns = 2;
              log.push(`${state.enemyCreature.name} is burning!`);
            }
            if (move.effect === 'poison' && (!newEnemy.poisonTurns || newEnemy.poisonTurns === 0)) {
              newEnemy.poisonTurns = 3;
              log.push(`${state.enemyCreature.name} is poisoned!`);
            }
            if (move.effect === 'chill' && (!newEnemy.chillTurns || newEnemy.chillTurns === 0)) {
              newEnemy.chillTurns = 2;
              log.push(`${state.enemyCreature.name} is chilled!`);
            }
          }

          // Void Drain - drains stamina from enemy and heals self
          if (move.effect === 'drain') {
            const drainAmount = move.drainStamina || 4;
            const healAmount = move.drainHp || 4;
            newEnemy.stamina = Math.max(0, newEnemy.stamina - drainAmount);
            const baseData = STARTERS[activeCreature.id];
            const { maxHp } = applyScars(activeCreature, baseData);
            newTeam[state.activeCreatureIndex] = {
              ...newTeam[state.activeCreatureIndex],
              hp: Math.min(activeCreature.hp + healAmount, maxHp)
            };
            log.push(`${activeCreature.nickname || activeCreature.name} drains ${drainAmount} stamina and heals ${healAmount} HP!`);
          }

          newTeam[state.activeCreatureIndex] = {
            ...newTeam[state.activeCreatureIndex],
            stamina: activeCreature.stamina - move.cost,
            isGuarding: false
          };

          if (newTeam[state.activeCreatureIndex].stamina < 5) {
            newTeam[state.activeCreatureIndex].winded = true;
            log.push(`${activeCreature.nickname || activeCreature.name} is winded!`);
          }

          if (state.isBossFight && state.bossPhase === 1 &&
              newEnemy.hp <= state.enemyCreature.maxHp * 0.3 && newEnemy.hp > 0) {
            const difficulty = getDifficulty(state);
            // Broken difficulty: no phase transition pause (boss still transforms but no HP recovery)
            if (difficulty.bossPhaseTransition) {
              newEnemy.hp += state.isHollowWardenFight ? 25 : 20;
            }

            if (state.isHollowWardenFight) {
              HOLLOW_WARDEN_DIALOGUE.phase2.forEach(line => log.push(line));
              log.push('The Hollow Warden fractures! Light and dark merge into chaos!');
              return {
                ...state,
                team: newTeam,
                enemy: newEnemy,
                enemyCreature: { ...state.enemyCreature, type: 'darklight' },
                battleLog: log,
                bossPhase: 2,
                arenaEffect: 'fracturedAura',
                turnPhase
              };
            } else {
              BOSS_DIALOGUE.phase2.forEach(line => log.push(line));
              log.push('Obsidian Hound transforms! The arena ignites with scorched earth!');
              return {
                ...state,
                team: newTeam,
                enemy: newEnemy,
                battleLog: log,
                bossPhase: 2,
                arenaEffect: 'scorchedEarth',
                turnPhase
              };
            }
          }

          if (newEnemy.hp <= 0) {
            const soulsEarned = state.enemyCreature.souls || 10;
            log.push(`${state.enemyCreature.name} defeated! Gained ${soulsEarned} souls.`);

            if (state.isBossFight) {
              return {
                ...state,
                screen: 'victory',
                souls: state.souls + soulsEarned,
                bossDefeated: state.isHollowWardenFight ? state.bossDefeated : true,
                hollowWardenDefeated: state.isHollowWardenFight ? true : state.hollowWardenDefeated,
                team: newTeam,
                battleLog: log
              };
            }

            const grassEncounters = state.grassEncounters.map(e =>
              e.x === state.currentEncounter?.x && e.y === state.currentEncounter?.y
                ? { ...e, active: false }
                : e
            );

            return {
              ...state,
              screen: 'exploration',
              souls: state.souls + soulsEarned,
              enemy: null,
              enemyCreature: null,
              team: newTeam,
              battleLog: log,
              grassEncounters
            };
          }

          return { ...state, team: newTeam, enemy: newEnemy, battleLog: log, turnPhase };
        }

        case 'BIND_ATTEMPT': {
          // Can't bind bosses
          if (state.isBossFight) {
            return { ...state, battleLog: [...state.battleLog, "Can't bind a boss!"] };
          }

          // Check if can afford
          if (state.souls < BIND_COST) {
            return { ...state, battleLog: [...state.battleLog, "Not enough souls!"] };
          }

          let log = [...state.battleLog];
          const difficulty = getDifficulty(state);
          const captureChance = getCaptureChance(state.enemy.hp, state.enemy.maxHp, difficulty.captureBonus);
          const roll = Math.random() * 100;

          log.push(`Attempting soul bind... (${captureChance}% chance)`);

          // Deduct souls regardless of outcome
          const newSouls = state.souls - BIND_COST;

          if (roll < captureChance) {
            // SUCCESS! Creature captured
            const capturedCreature = {
              id: state.enemyCreature.id.replace('wild', '').toLowerCase(),
              name: state.enemyCreature.name.replace('Wild ', ''),
              type: state.enemyCreature.type,
              maxHp: state.enemy.maxHp,
              maxStamina: state.enemy.maxStamina,
              hp: state.enemy.hp,
              stamina: state.enemy.stamina,
              scars: state.enemy.scars || [],
              winded: false,
              isGuarding: false,
              burnTurns: 0,
              poisonTurns: 0,
              chillTurns: 0,
              moves: []
            };

            // Fix the id and moves to match STARTERS based on type
            const typeToStarter = {
              fire: 'cindrath',
              water: 'marshveil',
              grass: 'thornwick',
              dark: 'umbravine',
              light: 'solrath'
            };
            capturedCreature.id = typeToStarter[state.enemyCreature.type] || 'cindrath';
            capturedCreature.moves = STARTERS[capturedCreature.id].moves;
            capturedCreature.nickname = null; // Will be set in nickname screen

            const grassEncounters = state.grassEncounters.map(e =>
              e.x === state.currentEncounter?.x && e.y === state.currentEncounter?.y
                ? { ...e, active: false }
                : e
            );

            // Team full? Show release screen instead of nickname
            if (state.team.length >= MAX_TEAM_SIZE) {
              log.push(`${capturedCreature.name} bound! But your team is full...`);
              return {
                ...state,
                screen: 'release',
                pendingCapture: capturedCreature,
                releaseMenuOpen: true,
                souls: newSouls,
                battleLog: log,
                grassEncounters
              };
            }

            // Team has room - go straight to nickname
            log.push(state.playerName
              ? `${capturedCreature.name} answered ${state.playerName}'s call!`
              : `${capturedCreature.name} answered your call!`);
            return {
              ...state,
              screen: 'nickname',
              pendingCreature: capturedCreature,
              souls: newSouls,
              battleLog: log,
              grassEncounters
            };
          } else {
            // FAILED - enemy gets a free attack
            const failMessages = [
              "They said no. Respect boundaries.",
              state.playerName ? `${state.playerName}'s call went unanswered.` : "Your call went unanswered.",
              "The binding failed. They resist."
            ];
            log.push(failMessages[Math.floor(Math.random() * failMessages.length)]);

            // Enemy retaliates
            return {
              ...state,
              souls: newSouls,
              battleLog: log,
              turnPhase: 'enemy'
            };
          }
        }

        case 'RELEASE_FOR_CAPTURE': {
          if (!state.pendingCapture) return state;
          if (action.releaseIndex < 0 || action.releaseIndex >= state.team.length) return state;

          const releasedCreature = state.team[action.releaseIndex];
          const newTeam = state.team.filter((_, i) => i !== action.releaseIndex);

          // Adjust activeCreatureIndex if needed
          let newActiveIndex = state.activeCreatureIndex;
          if (action.releaseIndex < state.activeCreatureIndex) {
            newActiveIndex = state.activeCreatureIndex - 1;
          } else if (action.releaseIndex === state.activeCreatureIndex) {
            newActiveIndex = 0;
          }

          return {
            ...state,
            screen: 'nickname',
            team: newTeam,
            activeCreatureIndex: Math.min(newActiveIndex, newTeam.length - 1),
            pendingCreature: state.pendingCapture,
            pendingCapture: null,
            releaseMenuOpen: false,
            battleLog: [...state.battleLog, `${releasedCreature.nickname || releasedCreature.name} was released forever.`]
          };
        }

        case 'CANCEL_CAPTURE': {
          if (!state.pendingCapture) return state;

          return {
            ...state,
            screen: 'exploration',
            pendingCapture: null,
            releaseMenuOpen: false,
            enemy: null,
            enemyCreature: null,
            battleLog: [...state.battleLog, `${state.pendingCapture.name} escaped while you hesitated.`]
          };
        }

        case 'SET_NICKNAME': {
          if (!state.pendingCreature) return state;

          const creature = {
            ...state.pendingCreature,
            nickname: action.nickname || null
          };

          return {
            ...state,
            screen: 'exploration',
            team: [...state.team, creature],
            pendingCreature: null,
            enemy: null,
            enemyCreature: null
          };
        }

        case 'RENAME_CREATURE': {
          const newTeam = [...state.team];
          newTeam[action.index] = {
            ...newTeam[action.index],
            nickname: action.nickname || null
          };
          return {
            ...state,
            team: newTeam
          };
        }


        case 'ENEMY_TURN': {
          let newTeam = [...state.team];
          let newEnemy = { ...state.enemy };
          let log = [...state.battleLog];
          let activeCreature = newTeam[state.activeCreatureIndex];
          const activeBase = STARTERS[activeCreature.id];
          const enemyDifficulty = getDifficulty(state);
          const { maxHp, maxStamina } = applyScars(activeCreature, activeBase, enemyDifficulty.hollowedThreshold);

          activeCreature = {
            ...activeCreature,
            stamina: Math.min(activeCreature.stamina + 4, maxStamina)
          };

          if (activeCreature.stamina >= 5) {
            activeCreature.winded = false;
          }

          // Process burn damage
          if (activeCreature.burnTurns > 0) {
            activeCreature.hp = Math.max(0, activeCreature.hp - 3);
            activeCreature.burnTurns--;
            log.push(`${activeCreature.nickname || activeCreature.name} takes 3 burn damage!`);
          }

          // Process poison damage
          if (activeCreature.poisonTurns > 0) {
            activeCreature.hp = Math.max(0, activeCreature.hp - 2);
            activeCreature.poisonTurns--;
            log.push(`${activeCreature.nickname || activeCreature.name} takes 2 poison damage!`);
          }

          // Process chill effect (25% chance to skip turn)
          let chillSkip = false;
          if (activeCreature.chillTurns > 0) {
            activeCreature.chillTurns--;
            if (Math.random() < 0.25) {
              chillSkip = true;
              log.push(`${activeCreature.nickname || activeCreature.name} is frozen and can't move!`);
            }
          }

          if (state.arenaEffect === 'scorchedEarth' && activeBase.type !== 'fire') {
            activeCreature.hp = Math.max(0, activeCreature.hp - 2);
            log.push(`Scorched Earth burns ${activeCreature.nickname || activeCreature.name} for 2 damage!`);
          }

          // Fractured Aura damages non-Dark/Light creatures
          if (state.arenaEffect === 'fracturedAura' && activeBase.type !== 'dark' && activeBase.type !== 'light') {
            activeCreature.hp = Math.max(0, activeCreature.hp - 2);
            log.push(`Fractured Aura tears at ${activeCreature.nickname || activeCreature.name} for 2 damage!`);
          }

          newTeam[state.activeCreatureIndex] = activeCreature;

          if (activeCreature.hp <= 0) {
            return handleCreatureFaint(state, newTeam, newEnemy, log);
          }

          newEnemy.stamina = Math.min(newEnemy.stamina + 4, state.enemyCreature.maxStamina);
          newEnemy.winded = false;

          // Process enemy status effects
          if (newEnemy.burnTurns > 0) {
            newEnemy.hp = Math.max(0, newEnemy.hp - 3);
            newEnemy.burnTurns--;
            log.push(`${state.enemyCreature.name} takes 3 burn damage!`);
          }
          if (newEnemy.poisonTurns > 0) {
            newEnemy.hp = Math.max(0, newEnemy.hp - 2);
            newEnemy.poisonTurns--;
            log.push(`${state.enemyCreature.name} takes 2 poison damage!`);
          }

          // Check if enemy died from status effects
          if (newEnemy.hp <= 0) {
            const soulsEarned = state.enemyCreature.souls || 10;
            log.push(`${state.enemyCreature.name} defeated! Gained ${soulsEarned} souls.`);
            if (state.isBossFight) {
              return {
                ...state,
                screen: 'victory',
                souls: state.souls + soulsEarned,
                bossDefeated: state.isHollowWardenFight ? state.bossDefeated : true,
                hollowWardenDefeated: state.isHollowWardenFight ? true : state.hollowWardenDefeated,
                team: newTeam,
                battleLog: log
              };
            }
            return {
              ...state,
              screen: 'exploration',
              souls: state.souls + soulsEarned,
              enemy: null,
              team: newTeam,
              battleLog: log
            };
          }

          // Get available moves based on boss type and phase
          let bossData = state.isHollowWardenFight ? BOSS.hollowWarden : BOSS.obsidianHound;
          let availableMoves = (state.bossPhase === 2 ?
            bossData.phase2Moves : state.enemyCreature.moves)
            .filter(m => m.cost <= newEnemy.stamina);

          if (availableMoves.length === 0) {
            availableMoves = [{ name: 'Rest', cost: 0, damage: 0, effect: 'rest' }];
          }

          let selectedMove;
          if (state.isBossFight) {
            const playerHpPercent = activeCreature.hp / (maxHp || 1);
            if (state.isHollowWardenFight) {
              // Hollow Warden AI
              if (state.bossPhase === 2 && playerHpPercent < 0.4) {
                const despVoid = availableMoves.find(m => m.name === 'Desperate Void');
                if (despVoid) selectedMove = despVoid;
              }
              if (!selectedMove && activeCreature.stamina > 12) {
                const voidGrasp = availableMoves.find(m => m.name === 'Void Grasp');
                if (voidGrasp) selectedMove = voidGrasp;
              }
            } else {
              // Obsidian Hound AI
              if (state.bossPhase === 2 && playerHpPercent < 0.4) {
                const despFang = availableMoves.find(m => m.name === 'Desperation Fang');
                if (despFang) selectedMove = despFang;
              }
              if (!selectedMove && playerHpPercent > 0.7) {
                const flameWall = availableMoves.find(m => m.name === 'Flame Wall');
                if (flameWall) selectedMove = flameWall;
              }
            }
          }

          if (!selectedMove) {
            const attackMoves = availableMoves.filter(m => m.damage > 0);
            selectedMove = attackMoves.length > 0
              ? attackMoves[Math.floor(Math.random() * attackMoves.length)]
              : availableMoves[0];
          }

          if (selectedMove.effect === 'rest') {
            newEnemy.stamina = Math.min(newEnemy.stamina + 12, state.enemyCreature.maxStamina);
            log.push(`${state.enemyCreature.name} rests.`);
          } else if (selectedMove.effect === 'guard') {
            newEnemy.isGuarding = true;
            newEnemy.stamina -= selectedMove.cost;
            log.push(`${state.enemyCreature.name} guards.`);
          } else {
            const difficulty = getDifficulty(state);
            const damageMult = state.isBossFight ? difficulty.bossDamageMult : difficulty.wildDamageMult;
            const damage = calculateDamage(selectedMove, newEnemy, activeCreature,
              state.enemyCreature, activeBase, damageMult);

            activeCreature.hp = Math.max(0, activeCreature.hp - damage);
            activeCreature.isGuarding = false;
            newEnemy.stamina -= selectedMove.cost;

            log.push(`${state.enemyCreature.name} used ${selectedMove.name}! ${damage} damage.`);

            // Apply status effects from enemy attacks
            if (selectedMove.effect === 'burn' && (!activeCreature.burnTurns || activeCreature.burnTurns === 0)) {
              activeCreature.burnTurns = 2;
              log.push(`${activeCreature.nickname || activeCreature.name} is burning!`);
            }
            if (selectedMove.effect === 'poison' && (!activeCreature.poisonTurns || activeCreature.poisonTurns === 0)) {
              activeCreature.poisonTurns = 3;
              log.push(`${activeCreature.nickname || activeCreature.name} is poisoned!`);
            }
            if (selectedMove.effect === 'chill' && (!activeCreature.chillTurns || activeCreature.chillTurns === 0)) {
              activeCreature.chillTurns = 2;
              log.push(`${activeCreature.nickname || activeCreature.name} is chilled!`);
            }

            if (selectedMove.effect === 'recoil') {
              newEnemy.hp = Math.max(0, newEnemy.hp - selectedMove.recoilDamage);
              log.push(`${state.enemyCreature.name} takes ${selectedMove.recoilDamage} recoil!`);
            }

            // Void Grasp drains stamina
            if (selectedMove.effect === 'drainStamina') {
              activeCreature.stamina = Math.max(0, activeCreature.stamina - selectedMove.drainAmount);
              log.push(`${activeCreature.nickname || activeCreature.name} loses ${selectedMove.drainAmount} stamina!`);
            }

            if (newEnemy.stamina < 5) {
              newEnemy.winded = true;
              log.push(`${state.enemyCreature.name} is winded!`);
            }
          }

          newTeam[state.activeCreatureIndex] = activeCreature;

          if (newEnemy.hp <= 0) {
            const soulsEarned = state.enemyCreature.souls || 10;
            log.push(`${state.enemyCreature.name} defeated! Gained ${soulsEarned} souls.`);

            if (state.isBossFight) {
              return {
                ...state,
                screen: 'victory',
                souls: state.souls + soulsEarned,
                bossDefeated: state.isHollowWardenFight ? state.bossDefeated : true,
                hollowWardenDefeated: state.isHollowWardenFight ? true : state.hollowWardenDefeated,
                team: newTeam,
                battleLog: log
              };
            }

            return {
              ...state,
              screen: 'exploration',
              souls: state.souls + soulsEarned,
              enemy: null,
              team: newTeam,
              battleLog: log
            };
          }

          if (activeCreature.hp <= 0) {
            return handleCreatureFaint(state, newTeam, newEnemy, log);
          }

          return {
            ...state,
            team: newTeam,
            enemy: newEnemy,
            battleLog: log,
            turnPhase: 'player'
          };
        }

        case 'SWITCH_CREATURE': {
          if (state.team[action.index].hp <= 0) return state;
          return {
            ...state,
            activeCreatureIndex: action.index,
            battleLog: [...state.battleLog, `Go, ${state.team[action.index].name}!`]
          };
        }

        case 'RESPAWN': {
          const respawnDifficulty = getDifficulty(state);
          const team = state.team.map(creature => {
            const baseData = STARTERS[creature.id];
            const { maxHp, maxStamina } = applyScars(creature, baseData, respawnDifficulty.hollowedThreshold);
            return {
              ...creature,
              hp: creature.hp === 0 ? 1 : Math.max(creature.hp, 1),
              stamina: maxStamina,
              winded: false,
              burnTurns: 0,
              poisonTurns: 0,
              chillTurns: 0,
              isGuarding: false
            };
          });

          return {
            ...state,
            screen: 'exploration',
            currentMap: state.lastBonfire.map,
            playerPos: { ...state.lastBonfire.pos },
            team,
            activeCreatureIndex: Math.max(0, team.findIndex(c => c.hp > 0)),
            enemy: null,
            enemyCreature: null,
            battleLog: [],
            turnPhase: 'player',
            bossPhase: 1,
            arenaEffect: null,
            isBossFight: false,
            diedToBoss: false,
            bonfireMenuOpen: false,
            withdrawMenuOpen: false,
            depositMenuOpen: false
          };
        }

        case 'RESTART': {
          return {
            ...initialState,
            hasSeenPrologue: true // Skip prologue on subsequent playthroughs
          };
        }

        case 'SHOW_CREDITS': {
          return {
            ...state,
            screen: 'credits'
          };
        }

        case 'RETURN_TO_TITLE': {
          return initialState;
        }

        case 'MANUAL_SAVE': {
          const success = saveGame(state);
          return {
            ...state,
            saveNotification: success ? 'Progress saved.' : 'Save failed!'
          };
        }

        case 'LOAD_GAME': {
          const saveData = action.saveData;
          if (!saveData) return state;

          return {
            ...initialState,
            screen: 'exploration',
            difficulty: saveData.difficulty || 'scarred',
            playerName: saveData.playerName || 'Ashen One',
            playerAppearance: saveData.playerAppearance || 'other',
            currentMap: saveData.currentMap,
            playerPos: saveData.playerPos,
            playerDir: saveData.playerDir,
            team: saveData.team,
            activeCreatureIndex: saveData.activeCreatureIndex,
            souls: saveData.souls,
            bankedSouls: saveData.bankedSouls,
            droppedSouls: saveData.droppedSouls,
            bossDefeated: saveData.bossDefeated,
            hollowWardenDefeated: saveData.hollowWardenDefeated || false,
            shortcutUnlocked: saveData.shortcutUnlocked,
            grassEncounters: saveData.grassEncounters,
            lastBonfire: saveData.lastBonfire,
            hasSeenPrologue: saveData.hasSeenPrologue,
            playTime: saveData.playTime || 0,
            titles: saveData.titles || [],
            activeTitle: saveData.activeTitle || null,
            cluesFound: saveData.cluesFound || [],
            secretDoorRevealed: saveData.secretDoorRevealed || false,
            saveNotification: 'Journey resumed.'
          };
        }

        case 'NEW_GAME_CONFIRMED': {
          deleteSaveData();
          return initialState;
        }

        case 'UPDATE_PLAY_TIME': {
          return {
            ...state,
            playTime: state.playTime + action.delta
          };
        }

        case 'EARN_TITLE': {
          const titleId = action.titleId;
          if (state.titles.includes(titleId)) {
            return state;
          }
          const titleData = TITLES.find(t => t.id === titleId);
          const titleName = titleData ? titleData.name : titleId;
          return {
            ...state,
            titles: [...state.titles, titleId],
            saveNotification: `Title earned: ${titleName}`
          };
        }

        case 'SET_ACTIVE_TITLE': {
          return {
            ...state,
            activeTitle: action.titleId
          };
        }

        case 'CONFIRM_ENCOUNTER': {
          if (!state.pendingEncounter) return state;
          const { wildData, actualMaxHp, actualMaxStamina, encounter } = state.pendingEncounter;
          return {
            ...state,
            screen: 'battle',
            enemy: {
              ...wildData,
              maxHp: actualMaxHp,
              maxStamina: actualMaxStamina,
              hp: actualMaxHp,
              stamina: actualMaxStamina,
              winded: false,
              isGuarding: false
            },
            enemyCreature: wildData,
            battleLog: [`A ${wildData.name} appeared!`],
            turnPhase: 'player',
            currentEncounter: encounter,
            pendingEncounter: null
          };
        }

        case 'FLEE_ENCOUNTER': {
          if (!state.pendingEncounter) return state;
          const { encounter } = state.pendingEncounter;
          // Mark grass as alerted - can't flee twice
          const grassEncounters = state.grassEncounters.map(e =>
            e.x === encounter.x && e.y === encounter.y && e.map === state.currentMap
              ? { ...e, alerted: true }
              : e
          );
          return {
            ...state,
            screen: 'exploration',
            pendingEncounter: null,
            grassEncounters
          };
        }

        default:
          return state;
      }
    }

    // ============= REACT UI COMPONENTS =============
    function DifficultySelect({ dispatch, onShowStats, onShowFallen }) {
      const difficultyInfo = {
        ashen: [
          '• Wild damage reduced 50%',
          '• Scars heal at bonfire',
          '• Souls only drop 50% on death',
          '• Capture chance +20%'
        ],
        scarred: [
          '• Standard damage (wild -25%)',
          '• Permanent scars',
          '• Full soul drop on death',
          '• Standard capture rates'
        ],
        hollowed: [
          '• Full damage from all enemies',
          '• Worse scar penalties (-7 HP, -3 STA)',
          '• Drop ALL souls including banked',
          '• Capture chance -20%',
          '• Boss has 25% more HP'
        ],
        broken: [
          '• All Hollowed settings plus:',
          '• No bonfire healing (save only)',
          '• One scar = Hollowed status',
          '• Boss has no phase pause',
          '• PERMADEATH: Save deleted on wipe'
        ]
      };

      return (
        <div style={styles.difficultySelect}>
          <h1 style={{ color: GBC.textDim, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-2xl)' }}>SCARS OF ASH</h1>
          <div style={{ color: GBC.gold, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-sm)', fontStyle: 'italic' }}>The flame remembers.</div>
          <div style={styles.difficultyTitle}>CHOOSE YOUR FATE</div>

          {Object.values(DIFFICULTIES).map(diff => (
            <div
              key={diff.id}
              style={styles.difficultyCard}
              onClick={() => dispatch({ type: 'SELECT_DIFFICULTY', difficulty: diff.id })}
              onMouseOver={e => {
                const colors = { ashen: GBC.gold, scarred: GBC.textDim, hollowed: GBC.red, broken: '#8b0000' };
                e.currentTarget.style.borderColor = colors[diff.id] || GBC.border;
              }}
              onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
            >
              <div style={styles.difficultyHeader}>
                <span style={styles.difficultyIcon}>{diff.icon}</span>
                <span style={styles.difficultyName}>{diff.name}</span>
                <span style={styles.difficultySubtitle}>({diff.subtitle})</span>
              </div>
              <div style={styles.difficultyDesc}>"{diff.description}"</div>
              <div style={styles.difficultyDetails}>
                {difficultyInfo[diff.id].map((line, i) => (
                  <div key={i}>{line}</div>
                ))}
              </div>
            </div>
          ))}

          <div style={{ display: 'flex', gap: 'var(--spacing-md)', justifyContent: 'center', marginTop: 'var(--spacing-lg)', flexWrap: 'wrap' }}>
            <button
              style={{
                ...styles.button,
                padding: 'var(--spacing-sm) var(--spacing-xl)'
              }}
              onClick={onShowStats}
            >
              STATS
            </button>
            <button
              style={{
                ...styles.button,
                padding: 'var(--spacing-sm) var(--spacing-xl)',
                borderColor: GBC.red,
                color: GBC.red
              }}
              onClick={onShowFallen}
            >
              MEMORIAL
            </button>
          </div>
        </div>
      );
    }

    function DifficultyIndicator({ difficulty }) {
      const diff = DIFFICULTIES[difficulty] || DIFFICULTIES.scarred;
      return (
        <div style={styles.difficultyIndicator}>
          <span>{diff.icon}</span>
          <span style={styles.difficultyIndicatorName}>{diff.name}</span>
        </div>
      );
    }

    function CharacterCreate({ dispatch }) {
      const [name, setName] = useState('');
      const [appearance, setAppearance] = useState('');

      const isValid = name.trim().length > 0 && appearance;

      const appearances = [
        { id: 'male', label: 'MALE' },
        { id: 'female', label: 'FEMALE' },
        { id: 'other', label: 'OTHER' }
      ];

      return (
        <div style={{
          textAlign: 'center',
          padding: 'var(--spacing-lg)',
          maxWidth: '400px',
          margin: '0 auto'
        }}>
          <h1 style={{ color: GBC.textDim, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-2xl)' }}>
            SCARS OF ASH
          </h1>
          <div style={{ color: GBC.gold, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-xl)', fontStyle: 'italic' }}>
            "The flame remembers."
          </div>

          <div style={{
            color: GBC.textDim,
            fontSize: 'var(--font-lg)',
            marginBottom: 'var(--spacing-lg)',
            letterSpacing: '2px'
          }}>
            WHO ARE YOU?
          </div>

          {/* Name input */}
          <div style={{ marginBottom: 'var(--spacing-lg)' }}>
            <input
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value.slice(0, 12))}
              placeholder="Enter your name"
              maxLength={12}
              style={{
                width: '100%',
                maxWidth: '280px',
                padding: 'var(--spacing-md)',
                backgroundColor: GBC.bgPanel,
                border: `3px solid ${GBC.border}`,
                color: GBC.text,
                fontFamily: '"Press Start 2P", monospace',
                fontSize: 'var(--font-sm)',
                textAlign: 'center',
                outline: 'none',
                boxSizing: 'border-box'
              }}
              onFocus={(e) => e.target.style.borderColor = GBC.gold}
              onBlur={(e) => e.target.style.borderColor = GBC.border}
            />
            <div style={{
              color: GBC.textDim,
              fontSize: 'var(--font-xs)',
              marginTop: 'var(--spacing-xs)'
            }}>
              {name.length}/12
            </div>
          </div>

          {/* Appearance selection */}
          <div style={{
            display: 'flex',
            justifyContent: 'center',
            gap: 'var(--spacing-md)',
            marginBottom: 'var(--spacing-xl)',
            flexWrap: 'wrap'
          }}>
            {appearances.map(opt => (
              <div
                key={opt.id}
                onClick={() => setAppearance(opt.id)}
                style={{
                  padding: 'var(--spacing-md)',
                  backgroundColor: GBC.bgPanel,
                  border: `3px solid ${appearance === opt.id ? GBC.gold : GBC.border}`,
                  cursor: 'pointer',
                  minWidth: '80px',
                  transition: 'border-color 0.2s'
                }}
                onMouseOver={e => { if (appearance !== opt.id) e.currentTarget.style.borderColor = GBC.textDim; }}
                onMouseOut={e => { if (appearance !== opt.id) e.currentTarget.style.borderColor = GBC.border; }}
              >
                <div style={{
                  display: 'flex',
                  justifyContent: 'center',
                  marginBottom: 'var(--spacing-sm)'
                }}>
                  <PlayerSprite direction="down" appearance={opt.id} />
                </div>
                <div style={{
                  color: appearance === opt.id ? GBC.gold : GBC.text,
                  fontSize: 'var(--font-xs)'
                }}>
                  {opt.label}
                </div>
              </div>
            ))}
          </div>

          {/* Begin button */}
          <button
            disabled={!isValid}
            onClick={() => dispatch({ type: 'CREATE_CHARACTER', name, appearance })}
            style={{
              ...styles.button,
              padding: 'var(--spacing-md) var(--spacing-xl)',
              fontSize: 'var(--font-base)',
              opacity: isValid ? 1 : 0.5,
              cursor: isValid ? 'pointer' : 'not-allowed'
            }}
          >
            BEGIN
          </button>

          {!isValid && (
            <div style={{
              color: GBC.textDim,
              fontSize: 'var(--font-xs)',
              marginTop: 'var(--spacing-md)'
            }}>
              Enter a name and choose your appearance
            </div>
          )}
        </div>
      );
    }

    function StarterSelect({ dispatch }) {
      return (
        <div style={styles.starterSelect}>
          <h1 style={{ color: GBC.textDim, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-2xl)' }}>SCARS OF ASH</h1>
          <div style={{ color: GBC.gold, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-sm)', fontStyle: 'italic' }}>The flame remembers.</div>
          <p style={{ color: GBC.text, marginBottom: 'var(--spacing-lg)', fontSize: 'var(--font-sm)' }}>Choose your survivor</p>
          <div>
            {Object.values(STARTERS).filter(s => ['cindrath', 'marshveil', 'thornwick'].includes(s.id)).map(starter => (
              <div
                key={starter.id}
                style={styles.starterCard}
                onClick={() => dispatch({ type: 'SELECT_STARTER', starter: starter.id })}
                onMouseOver={e => e.currentTarget.style.borderColor = getTypeColor(starter.type)}
                onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
              >
                <div style={{ display: 'flex', justifyContent: 'center', marginBottom: 'var(--spacing-sm)' }}>
                  <CreatureSprite type={starter.type} size={48} animated={false} />
                </div>
                <div style={{ margin: 'var(--spacing-sm) 0 var(--spacing-xs)', color: GBC.text, fontSize: 'var(--font-base)' }}>{starter.name}</div>
                <div style={{ fontSize: 'var(--font-sm)', color: getTypeColor(starter.type), margin: 'var(--spacing-xs) 0' }}>
                  {starter.type.toUpperCase()}
                </div>
                <div style={{ fontSize: 'var(--font-xs)', color: GBC.textDim }}>
                  HP {starter.maxHp}
                </div>
                <div style={{ fontSize: 'var(--font-xs)', color: GBC.textDim }}>
                  STA {starter.maxStamina}
                </div>
                <div style={{ fontSize: 'var(--font-xs)', color: getTypeColor(starter.type), marginTop: 'var(--spacing-xs)' }}>
                  {starter.moves[0].name}
                </div>
              </div>
            ))}
          </div>
        </div>
      );
    }

    function Exploration({ state, dispatch }) {
      const map = state.currentMap === 'ashenPath' ? ASHEN_PATH : state.currentMap === 'hollowDeep' ? HOLLOW_DEEP : state.currentMap === 'labyrinth' ? LABYRINTH : FALLEN_KEEP;
      const mapName = state.currentMap === 'ashenPath' ? 'Ashen Path' : state.currentMap === 'hollowDeep' ? 'The Hollow Deep' : state.currentMap === 'labyrinth' ? 'The Labyrinth' : 'Fallen Keep';
      const ghost = loadGhost(); // Load once for ghost marker display

      // Track movement for walk animation
      const [isMoving, setIsMoving] = useState(false);
      const prevPosRef = useRef({ x: state.playerPos.x, y: state.playerPos.y });
      const moveTimeoutRef = useRef(null);

      // Detect when player position changes and trigger walk animation
      useEffect(() => {
        const posChanged = prevPosRef.current.x !== state.playerPos.x ||
                          prevPosRef.current.y !== state.playerPos.y;

        if (posChanged) {
          setIsMoving(true);
          prevPosRef.current = { x: state.playerPos.x, y: state.playerPos.y };

          // Clear any existing timeout
          if (moveTimeoutRef.current) {
            clearTimeout(moveTimeoutRef.current);
          }

          // Stop moving animation after 200ms of no movement
          moveTimeoutRef.current = setTimeout(() => {
            setIsMoving(false);
          }, 200);
        }

        return () => {
          if (moveTimeoutRef.current) {
            clearTimeout(moveTimeoutRef.current);
          }
        };
      }, [state.playerPos.x, state.playerPos.y]);

      const handleKeyDown = useCallback((e) => {
        const key = e.key.toLowerCase();
        let dx = 0, dy = 0;

        // Close examine overlay first if open
        if (state.examineText && (key === 'x' || key === 'escape' || key === 'enter' || key === 'e')) {
          dispatch({ type: 'CLOSE_EXAMINE' });
          return;
        }

        if (key === 'arrowup' || key === 'w') dy = -1;
        else if (key === 'arrowdown' || key === 's') dy = 1;
        else if (key === 'arrowleft' || key === 'a') dx = -1;
        else if (key === 'arrowright' || key === 'd') dx = 1;
        else if (key === 'e' || key === 'enter') {
          const tile = map[state.playerPos.y][state.playerPos.x];
          if (tile === 'B') {
            dispatch({ type: 'INTERACT_BONFIRE' });
          }
          return;
        }
        else if (key === 'x') {
          dispatch({ type: 'EXAMINE_TILE' });
          return;
        }

        if (dx !== 0 || dy !== 0) {
          dispatch({ type: 'MOVE_PLAYER', dx, dy });
        }
      }, [dispatch, map, state.playerPos, state.examineText]);

      useEffect(() => {
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [handleKeyDown]);

      const currentTile = map[state.playerPos.y][state.playerPos.x];

      // Render tile background with area-specific styling
      const renderTileBackground = (tile, x, y) => {
        const area = state.currentMap;

        switch(tile) {
          case 'W': return <WallTile area={area} />;
          case 'P': return <PathTile area={area} />;
          case 'G': return <GrassTile area={area} />;
          case 'B': return <BonfireTile area={area} />;
          case 'X': return <GateTile area={area} />;
          case 'E': return <GateTile isKeep={true} area={area} />;
          case 'K': return <BossRoomTile area={area} />;
          case 'T': return <TorchTile area={area} />;
          case 'A': return <AshenGateTile area={area} />;
          case 'H': return <SecretDoorTile revealed={false} area={area} />;
          case 'S': return <SecretDoorTile revealed={state.secretDoorRevealed} area={area} />;
          case 'L': return <PathTile area={area} />;
          default: return <PathTile area={area} />;
        }
      };

      // Handle tile tap for movement/interaction
      const handleTileTap = (x, y, tile) => {
        // If examine overlay is open, close it
        if (state.examineText) {
          dispatch({ type: 'CLOSE_EXAMINE' });
          return;
        }

        const px = state.playerPos.x;
        const py = state.playerPos.y;
        const dx = x - px;
        const dy = y - py;
        const currentTileType = map[py][px];

        // Tap on player tile
        if (x === px && y === py) {
          // If on bonfire, interact with it
          if (currentTileType === 'B') {
            dispatch({ type: 'INTERACT_BONFIRE' });
          } else {
            // Check for lore tile
            const key = `${px},${py}`;
            const hasLore = TILE_LORE[state.currentMap]?.[key];
            if (hasLore) {
              dispatch({ type: 'EXAMINE_TILE' });
            } else {
              // Open pause menu
              window.dispatchEvent(new KeyboardEvent('keydown', { key: 'Escape' }));
            }
          }
          return;
        }

        // Check if adjacent tile (including diagonals for tap)
        const isAdjacent = Math.abs(dx) <= 1 && Math.abs(dy) <= 1;

        if (isAdjacent) {
          // Move in that direction
          dispatch({ type: 'MOVE_PLAYER', dx, dy });
        }
      };

      return (
        <div>
          <div
            style={{ ...styles.header, cursor: isTouchDevice() ? 'pointer' : 'default' }}
            onClick={() => isTouchDevice() && window.dispatchEvent(new KeyboardEvent('keydown', { key: 'Escape' }))}
          >
            <span style={styles.souls}>CARRIED {state.souls} | BANKED {state.bankedSouls}</span>
            <span style={{ color: GBC.textDim, display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2px' }}>
              <span style={{ fontSize: 'var(--font-xs)', color: GBC.gold }}>{state.playerName || 'Ashen One'}</span>
              <span>{mapName}</span>
            </span>
            <span style={{ color: GBC.textDim, fontSize: 'var(--font-sm)' }}>TEAM {state.team.length}/{MAX_TEAM_SIZE}</span>
          </div>

          <div style={styles.mapContainer}>
            <div style={{
              ...styles.grid,
              gridTemplateColumns: `repeat(${map[0].length}, var(--tile-size))`
            }}>
              {map.map((row, y) =>
                row.map((tile, x) => {
                  const isPlayer = x === state.playerPos.x && y === state.playerPos.y;
                  const hasSouls = state.droppedSouls &&
                    state.droppedSouls.map === state.currentMap &&
                    state.droppedSouls.pos.x === x &&
                    state.droppedSouls.pos.y === y;

                  // Check if adjacent to player for tap highlighting
                  const px = state.playerPos.x;
                  const py = state.playerPos.y;
                  const isAdjacent = Math.abs(x - px) <= 1 && Math.abs(y - py) <= 1 && !(x === px && y === py);
                  const isWalkable = tile !== 'W';

                  return (
                    <div
                      key={`${x}-${y}`}
                      style={{
                        ...styles.tile,
                        cursor: (isAdjacent && isWalkable) || isPlayer ? 'pointer' : 'default'
                      }}
                      onClick={() => handleTileTap(x, y, tile)}
                    >
                      {renderTileBackground(tile, x, y)}
                      {isPlayer && (
                        <div style={{ position: 'absolute', zIndex: 10 }}>
                          <PlayerSprite direction={state.playerDir} appearance={state.playerAppearance || 'other'} isMoving={isMoving} />
                        </div>
                      )}
                      {hasSouls && !isPlayer && (
                        <div style={{
                          position: 'absolute',
                          zIndex: 5,
                          display: 'flex',
                          flexDirection: 'column',
                          alignItems: 'center',
                          justifyContent: 'center'
                        }}>
                          <div style={{
                            width: '28px',
                            height: '28px',
                            backgroundColor: GBC.gold,
                            border: '3px solid #744210',
                            animation: 'flicker 1s infinite',
                            boxShadow: '0 0 10px rgba(246, 224, 94, 0.5)'
                          }} />
                          <div style={{
                            fontSize: '8px',
                            color: GBC.gold,
                            fontFamily: '"Press Start 2P", monospace',
                            marginTop: '2px',
                            textShadow: '1px 1px 0 #000'
                          }}>SOULS</div>
                        </div>
                      )}
                      {ghost && ghost.map === state.currentMap &&
                        ghost.pos.x === x && ghost.pos.y === y &&
                        ghost.name && ghost.name !== state.playerName && !isPlayer && (
                        <div style={{
                          position: 'absolute',
                          zIndex: 4,
                          display: 'flex',
                          flexDirection: 'column',
                          alignItems: 'center',
                          justifyContent: 'center',
                          opacity: 0.5
                        }}>
                          <div style={{ transform: 'scale(0.6)', transformOrigin: 'center', filter: 'grayscale(100%)' }}>
                            <FallbackPlayerSprite direction="down" appearance={ghost.appearance || 'other'} />
                          </div>
                          <div style={{
                            fontSize: '6px',
                            color: GBC.textDim,
                            fontFamily: '"Press Start 2P", monospace',
                            textShadow: '1px 1px 0 #000',
                            marginTop: '-4px'
                          }}>{ghost.name}...</div>
                        </div>
                      )}
                    </div>
                  );
                })
              )}
            </div>
          </div>

          {currentTile === 'B' && !state.bonfireMenuOpen && (
            <div style={{
              textAlign: 'center',
              color: GBC.gold,
              marginBottom: 'var(--spacing-sm)',
              padding: 'var(--spacing-xs)',
              backgroundColor: GBC.bgPanel,
              border: `2px solid ${GBC.border}`,
              fontSize: 'var(--font-sm)'
            }}>
              {isTouchDevice() ? 'Tap here to rest' : 'Press E to rest at bonfire'}
            </div>
          )}

          {state.bonfireMenuOpen && (
            <div style={styles.bonfireMenu}>
              <div style={{ color: GBC.gold, marginBottom: 'var(--spacing-sm)', fontSize: 'var(--font-sm)' }}>BONFIRE</div>

              <div
                style={styles.bonfireOption}
                onClick={() => { playSfx('bonfireRest'); dispatch({ type: 'REST_AT_BONFIRE' }); }}
                onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
                onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
              >
                REST - Heal all, bank souls, respawn enemies
              </div>

              {state.bankedSouls > 0 && (
                <div>
                  <div
                    style={styles.bonfireOption}
                    onClick={() => dispatch({ type: 'TOGGLE_WITHDRAW_MENU' })}
                    onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
                    onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
                  >
                    WITHDRAW - Take souls from bank ({state.bankedSouls} available)
                  </div>

                  {state.withdrawMenuOpen && (
                    <div style={{ marginLeft: '12px', marginBottom: '8px' }}>
                      {[20, 50, state.bankedSouls].filter((amount, index, arr) => {
                        // Filter out amounts > bankedSouls and remove duplicates
                        if (amount > state.bankedSouls) return false;
                        return arr.indexOf(amount) === index;
                      }).map(amount => (
                        <div
                          key={amount}
                          style={{ ...styles.bonfireOption, marginTop: '4px' }}
                          onClick={() => { playSfx('soulsGained'); dispatch({ type: 'WITHDRAW_SOULS', amount }); }}
                          onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
                          onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
                        >
                          {amount === state.bankedSouls ? `ALL (${amount})` : amount}
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              )}

              {state.souls > 0 && (
                <div>
                  <div
                    style={styles.bonfireOption}
                    onClick={() => dispatch({ type: 'TOGGLE_DEPOSIT_MENU' })}
                    onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
                    onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
                  >
                    DEPOSIT - Put souls in bank ({state.souls} carried)
                  </div>

                  {state.depositMenuOpen && (
                    <div style={{ marginLeft: '12px', marginBottom: '8px' }}>
                      {[20, 50].filter(amount => amount < state.souls).map(amount => (
                        <div
                          key={amount}
                          style={{ ...styles.bonfireOption, marginTop: '4px' }}
                          onClick={() => { playSfx('bonfireRest'); dispatch({ type: 'DEPOSIT_SOULS', amount }); }}
                          onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
                          onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
                        >
                          {amount}
                        </div>
                      ))}

                      {state.souls > 20 && (
                        <div
                          style={{ ...styles.bonfireOption, marginTop: '4px' }}
                          onClick={() => { playSfx('bonfireRest'); dispatch({ type: 'DEPOSIT_SOULS', amount: state.souls - 20 }); }}
                          onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
                          onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
                        >
                          KEEP 20 ({state.souls - 20})
                        </div>
                      )}

                      <div
                        style={{ ...styles.bonfireOption, marginTop: '4px' }}
                        onClick={() => { playSfx('bonfireRest'); dispatch({ type: 'DEPOSIT_SOULS', amount: state.souls }); }}
                        onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
                        onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
                      >
                        ALL ({state.souls})
                      </div>
                    </div>
                  )}
                </div>
              )}

              {state.team.length > 1 && (
                <div style={{ marginTop: 'var(--spacing-sm)' }}>
                  <div style={{ color: GBC.textDim, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-xs)' }}>SWITCH ACTIVE:</div>
                  {state.team.map((creature, i) => {
                    const isActive = i === state.activeCreatureIndex;
                    const baseData = STARTERS[creature.id];
                    const { maxHp } = applyScars(creature, baseData);
                    const isAlive = creature.hp > 0;

                    return (
                      <div
                        key={i}
                        style={{
                          ...styles.bonfireOption,
                          opacity: isAlive ? 1 : 0.5,
                          cursor: isAlive && !isActive ? 'pointer' : 'default',
                          borderColor: isActive ? getTypeColor(creature.type) : GBC.border
                        }}
                        onClick={() => {
                          if (isAlive && !isActive) {
                            dispatch({ type: 'SWITCH_ACTIVE_AT_BONFIRE', index: i });
                          }
                        }}
                      >
                        <span style={{ color: getTypeColor(creature.type) }}>{getTypeIcon(creature.type)}</span>
                        {' '}{creature.nickname || creature.name} - {creature.hp}/{maxHp} HP
                        {isActive && <span style={{ color: GBC.gold, marginLeft: '6px' }}>(ACTIVE)</span>}
                        {!isAlive && <span style={{ color: GBC.red, marginLeft: '6px' }}>(FAINTED)</span>}
                        {creature.scars?.length > 0 && (
                          <span style={{ color: GBC.red, marginLeft: '6px' }}>({creature.scars.length} scars)</span>
                        )}
                      </div>
                    );
                  })}
                </div>
              )}

              <div
                style={{ ...styles.bonfireOption, marginTop: '8px', color: GBC.textDim }}
                onClick={() => dispatch({ type: 'CLOSE_BONFIRE_MENU' })}
              >
                LEAVE
              </div>
            </div>
          )}

          <TeamStatus team={state.team} activeIndex={state.activeCreatureIndex} />

          {/* Examine prompt when on lore tile */}
          {(() => {
            const key = `${state.playerPos.x},${state.playerPos.y}`;
            const hasLore = TILE_LORE[state.currentMap]?.[key];
            if (hasLore && !state.examineText) {
              return (
                <div style={{
                  textAlign: 'center',
                  color: GBC.gold,
                  marginBottom: 'var(--spacing-sm)',
                  padding: 'var(--spacing-xs)',
                  backgroundColor: GBC.bgPanel,
                  border: `2px solid ${GBC.border}`,
                  fontSize: 'var(--font-sm)'
                }}>
                  {isTouchDevice() ? 'Tap here to examine' : 'Press X to examine'}
                </div>
              );
            }
            return null;
          })()}

          {/* Examine overlay */}
          {state.examineText && (
            <div style={styles.examineOverlay} onClick={() => dispatch({ type: 'CLOSE_EXAMINE' })}>
              <div style={styles.examineContent} onClick={e => e.stopPropagation()}>
                <div style={styles.examineTitle}>{state.examineText.name}</div>
                {state.examineText.lines.map((line, i) => (
                  <div key={i} style={styles.examineLine}>{line || '\u00A0'}</div>
                ))}
                <div style={styles.examinePrompt}>{isTouchDevice() ? '[Tap to close]' : '[Press X to close]'}</div>
              </div>
            </div>
          )}

          {/* Keyboard hints - hidden on touch devices */}
          {!isTouchDevice() && (
            <div style={{
              padding: 'var(--spacing-xs) var(--spacing-sm)',
              backgroundColor: GBC.bgPanel,
              marginTop: 'var(--spacing-sm)',
              fontSize: 'var(--font-xs)',
              color: GBC.textDim,
              border: `2px solid ${GBC.border}`
            }}>
              WASD: Move | E: Rest | X: Examine | ESC: Menu
            </div>
          )}
        </div>
      );
    }

    function TeamStatus({ team, activeIndex }) {
      return (
        <div style={styles.teamStatus}>
          <div style={{ margin: '0 0 var(--spacing-xs)' }}>
            <span style={{ color: GBC.textDim, fontSize: 'var(--font-sm)' }}>TEAM</span>
          </div>
          {team.map((creature, i) => {
            const baseData = STARTERS[creature.id];
            const { maxHp, maxStamina } = applyScars(creature, baseData);
            const hpPercent = (creature.hp / (maxHp || 1)) * 100;
            const staminaPercent = (creature.stamina / (maxStamina || 1)) * 100;
            const isActive = i === activeIndex;
            const isHollowed = creature.scars && creature.scars.length >= 3;

            return (
              <div
                key={i}
                style={{
                  ...styles.creatureStatus,
                  borderColor: isActive ? getTypeColor(creature.type) : GBC.border,
                  display: 'flex',
                  alignItems: 'center'
                }}
              >
                <div style={styles.creatureSprite}>
                  <CreatureSprite type={creature.type} size={32} scarCount={creature.scars?.length || 0} isHollowed={isHollowed} />
                </div>
                <div style={{ flex: 1 }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2px' }}>
                    <span style={{ fontSize: 'var(--font-sm)' }}>
                      {creature.name}
                      {isHollowed && <span style={styles.scar}>HOLLOW</span>}
                      {creature.winded && <span style={{ ...styles.status, ...styles.winded }}>WIND</span>}
                      {creature.burnTurns > 0 && (
                        <span style={{ ...styles.status, ...styles.burn }}>BURN</span>
                      )}
                    </span>
                    <span style={{ fontSize: 'var(--font-sm)', color: GBC.textDim }}>
                      {creature.hp}/{maxHp}
                    </span>
                  </div>
                  <div style={styles.hpBar}>
                    <div style={{
                    ...styles.hpFill,
                    width: `${hpPercent}%`,
                    backgroundColor: hpPercent > 50 ? '#4a4' : hpPercent > 25 ? '#aa4' : '#a44'
                  }} />
                </div>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginTop: '2px' }}>
                    <span style={{ fontSize: 'var(--font-xs)', color: GBC.textDim }}>
                      STA {creature.stamina}/{maxStamina}
                    </span>
                    {creature.scars && creature.scars.length > 0 && (
                      <span>
                        {creature.scars.slice(0, 2).map((scar, j) => (
                          <span key={j} style={styles.scar}>{scar.name.slice(0, 4)}</span>
                        ))}
                        {creature.scars.length > 2 && <span style={styles.scar}>+{creature.scars.length - 2}</span>}
                      </span>
                    )}
                  </div>
                  <div style={styles.staminaBar}>
                    <div style={{
                      ...styles.staminaFill,
                      width: `${staminaPercent}%`
                    }} />
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      );
    }

    // Damage number component for combat juice
    function DamageNumber({ damage, type, position, onComplete }) {
      useEffect(() => {
        const timer = setTimeout(onComplete, 1000);
        return () => clearTimeout(timer);
      }, [onComplete]);

      const colors = {
        normal: '#ffffff',
        effective: '#68d391',
        resisted: '#a0aec0',
        player: '#fc8181'
      };

      return (
        <div style={{
          position: 'absolute',
          top: position === 'enemy' ? '20%' : '60%',
          left: position === 'enemy' ? '70%' : '30%',
          transform: 'translateX(-50%)',
          color: colors[type] || colors.normal,
          fontSize: 'var(--font-lg)',
          fontFamily: '"Press Start 2P", monospace',
          textShadow: '2px 2px 0 #000',
          animation: 'damageNumber 1s ease-out forwards',
          pointerEvents: 'none',
          zIndex: 100
        }}>
          {damage}
        </div>
      );
    }

    function Battle({ state, dispatch }) {
      const activeCreature = state.team[state.activeCreatureIndex];
      const activeBase = STARTERS[activeCreature.id];
      const { maxHp, maxStamina, hasFlinching } = applyScars(activeCreature, activeBase);

      const enemyHpPercent = (state.enemy.hp / (state.enemyCreature.maxHp || 1)) * 100;
      const playerHpPercent = (activeCreature.hp / (maxHp || 1)) * 100;
      const prevLogLengthRef = useRef(state.battleLog.length);
      const [damageNumbers, setDamageNumbers] = useState([]);
      const [screenShake, setScreenShake] = useState(false);
      const [criticalFlash, setCriticalFlash] = useState(false);
      const damageIdRef = useRef(0);

      // Play sound effects and visual effects based on battle log changes
      useEffect(() => {
        const newLogs = state.battleLog.slice(prevLogLengthRef.current);
        prevLogLengthRef.current = state.battleLog.length;

        newLogs.forEach(log => {
          // Check for damage messages
          const damageMatch = log.match(/(\d+) damage/);
          if (damageMatch) {
            const damage = parseInt(damageMatch[1]);
            const isEffective = log.includes('super effective');
            const isResisted = log.includes('not very effective');
            const isEnemyDamage = log.includes(state.enemyCreature?.name + ' used');

            // Play sound effects
            if (isEffective) {
              playSfx('critical');
              setCriticalFlash(true);
              setTimeout(() => setCriticalFlash(false), 100);
            } else if (damage >= 15) {
              playSfx('hitHeavy');
              setScreenShake(true);
              setTimeout(() => setScreenShake(false), 200);
            } else if (damage >= 8) {
              playSfx('hitMedium');
            } else {
              playSfx('hitLight');
            }

            // Add damage number
            const dmgType = isEffective ? 'effective' : isResisted ? 'resisted' : isEnemyDamage ? 'player' : 'normal';
            const position = isEnemyDamage ? 'player' : 'enemy';
            const newDamage = {
              id: damageIdRef.current++,
              damage,
              type: dmgType,
              position
            };
            setDamageNumbers(prev => [...prev, newDamage]);
          }

          // Check for status effects
          if (log.includes('is burning')) playSfx('burn');
          if (log.includes('is poisoned')) playSfx('poison');
          if (log.includes('is chilled')) playSfx('chill');
          if (log.includes('poison damage')) playSfx('poison');
          if (log.includes('chill damage') || log.includes('frozen')) playSfx('chill');
          if (log.includes('burn damage')) playSfx('burn');

          // Check for faint
          if (log.includes('has fallen') || log.includes('defeated')) {
            playSfx('faint');
          }

          // Check for souls
          if (log.includes('Gained') && log.includes('souls')) {
            playSfx('soulsGained');
          }

          // Capture attempts
          if (log.includes('Attempting soul bind')) playSfx('bindAttempt');
          if (log.includes('joined your disaster')) playSfx('captureSuccess');
          if (log.includes('said no')) playSfx('captureFail');
        });
      }, [state.battleLog, state.enemyCreature?.name]);

      const removeDamageNumber = useCallback((id) => {
        setDamageNumbers(prev => prev.filter(d => d.id !== id));
      }, []);

      useEffect(() => {
        if (state.turnPhase === 'enemy') {
          const timer = setTimeout(() => {
            dispatch({ type: 'ENEMY_TURN' });
          }, 1000);
          return () => clearTimeout(timer);
        }
      }, [state.turnPhase, dispatch]);

      const getMoveWithPriority = (move) => {
        if (move.priority && hasFlinching) {
          return { ...move, priority: false };
        }
        return move;
      };

      // Keyboard controls for battle
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (state.turnPhase !== 'player') return;

          const moves = activeBase.moves;

          // Number keys 1-4 for moves
          if (e.key >= '1' && e.key <= '4') {
            const moveIndex = parseInt(e.key) - 1;
            if (moveIndex < moves.length) {
              const move = getMoveWithPriority(moves[moveIndex]);
              if (move.cost <= activeCreature.stamina) {
                dispatch({ type: 'SELECT_MOVE', move });
              }
            }
          }

          // B for bind/capture
          if (e.key.toLowerCase() === 'b' && !state.isBossFight) {
            dispatch({ type: 'BIND_ATTEMPT' });
          }

          // Tab to cycle through team
          if (e.key === 'Tab') {
            e.preventDefault();
            const aliveCreatures = state.team
              .map((c, i) => ({ creature: c, index: i }))
              .filter(({ creature, index }) => creature.hp > 0 && index !== state.activeCreatureIndex);
            if (aliveCreatures.length > 0) {
              dispatch({ type: 'SWITCH_CREATURE', index: aliveCreatures[0].index });
            }
          }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [state.turnPhase, state.team, state.activeCreatureIndex, activeBase.moves, activeCreature.stamina, state.isBossFight, dispatch]);

      const enemyType = state.isBossFight ? (state.isHollowWardenFight ? 'hollowWarden' : 'boss') : state.enemyCreature.type;

      return (
        <div style={styles.battleContainer}>
          <div style={styles.header}>
            <span style={styles.souls}>CARRIED {state.souls}</span>
            <span style={{ color: state.isBossFight ? GBC.red : GBC.textDim, fontSize: 'var(--font-sm)' }}>
              {state.isBossFight ? 'BOSS' : 'BATTLE'}
            </span>
          </div>

          {state.arenaEffect === 'scorchedEarth' && (
            <div style={{
              textAlign: 'center',
              padding: 'var(--spacing-xs)',
              backgroundColor: '#2a1510',
              color: GBC.fire,
              marginBottom: 'var(--spacing-sm)',
              border: `2px solid ${GBC.fire}`,
              fontSize: 'var(--font-sm)',
              animation: 'flicker 0.5s infinite'
            }}>
              SCORCHED EARTH - 2 DMG/TURN
            </div>
          )}

          {/* Battle sprite arena */}
          <div
            style={styles.battleSpriteArea}
            className={`${screenShake ? 'screen-shake' : ''} ${criticalFlash ? 'critical-flash' : ''}`}
          >
            <div style={{ textAlign: 'center', position: 'relative' }}>
              <CreatureSprite type={activeCreature.type} size={48} scarCount={activeCreature.scars?.length || 0} />
              <div style={{ fontSize: 'var(--font-xs)', color: GBC.text, marginTop: 'var(--spacing-xs)' }}>
                {activeCreature.nickname || activeCreature.name}
              </div>
            </div>
            <div style={{ fontSize: 'var(--font-xl)', color: GBC.textDim }}>VS</div>
            <div
              style={{
                textAlign: 'center',
                position: 'relative',
                cursor: state.turnPhase === 'player' ? 'pointer' : 'default',
                padding: 'var(--spacing-xs)'
              }}
              onClick={() => {
                if (state.turnPhase !== 'player') return;
                // Find first available move and use it
                const moves = activeBase.moves;
                for (let i = 0; i < moves.length; i++) {
                  const move = getMoveWithPriority(moves[i]);
                  if (move.cost <= activeCreature.stamina) {
                    playSfx('menuClick');
                    dispatch({ type: 'SELECT_MOVE', move });
                    break;
                  }
                }
              }}
              title={state.turnPhase === 'player' ? 'Tap to attack' : ''}
            >
              <CreatureSprite type={enemyType} size={state.isBossFight ? 56 : 48} isEnemy={true} bossPhase={state.bossPhase || 1} />
              <div style={{ fontSize: 'var(--font-xs)', color: GBC.text, marginTop: 'var(--spacing-xs)' }}>{state.enemyCreature.name}</div>
              {isTouchDevice() && state.turnPhase === 'player' && (
                <div style={{ fontSize: 'var(--font-xs)', color: GBC.gold, marginTop: '2px' }}>TAP TO ATTACK</div>
              )}
            </div>
            {/* Damage numbers */}
            {damageNumbers.map(dn => (
              <DamageNumber
                key={dn.id}
                damage={dn.damage}
                type={dn.type}
                position={dn.position}
                onComplete={() => removeDamageNumber(dn.id)}
              />
            ))}
          </div>

          {/* Enemy stats */}
          <div style={styles.battleCreature}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 'var(--spacing-xs)' }}>
              <span style={{ fontSize: 'var(--font-sm)' }}>
                {state.enemyCreature.name}
                {state.bossPhase === 2 && <span style={{ color: GBC.red, marginLeft: 'var(--spacing-xs)' }}>P2</span>}
                {state.enemy.burnTurns > 0 && <span style={{ ...styles.status, ...styles.burn }}>BRN</span>}
                {state.enemy.poisonTurns > 0 && <span style={{ ...styles.status, backgroundColor: '#1a3a1a', border: '2px solid #48bb78', color: '#48bb78' }}>PSN</span>}
                {state.enemy.chillTurns > 0 && <span style={{ ...styles.status, backgroundColor: '#1a2a3a', border: '2px solid #63b3ed', color: '#63b3ed' }}>CHL</span>}
              </span>
              <span style={{ fontSize: 'var(--font-sm)', color: GBC.textDim }}>
                {state.enemy.hp}/{state.enemyCreature.maxHp}
              </span>
            </div>
            <div style={styles.hpBar}>
              <div style={{
                ...styles.hpFill,
                width: `${enemyHpPercent}%`,
                backgroundColor: GBC.red
              }} />
            </div>
            <div style={{ fontSize: 'var(--font-xs)', color: GBC.textDim, marginTop: '3px' }}>
              STA {state.enemy.stamina}/{state.enemyCreature.maxStamina}
              {state.enemy.winded && <span style={{ ...styles.status, ...styles.winded }}>WIND</span>}
              {state.enemy.isGuarding && <span style={{ ...styles.status, backgroundColor: '#1a2a3a', border: `1px solid ${GBC.blue}`, color: GBC.blue }}>GRD</span>}
            </div>
          </div>

          {/* Battle log */}
          <div style={styles.battleAnimation}>
            {state.battleLog.slice(-2).map((log, i) => (
              <div key={i} style={{ marginBottom: '4px' }}>{log}</div>
            ))}
          </div>

          {/* Player stats */}
          <div style={styles.battleCreature}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 'var(--spacing-xs)' }}>
              <span style={{ fontSize: 'var(--font-sm)' }}>
                {activeCreature.nickname || activeCreature.name}
                {activeCreature.winded && <span style={{ ...styles.status, ...styles.winded }}>WIND +25%</span>}
                {activeCreature.burnTurns > 0 && <span style={{ ...styles.status, ...styles.burn }}>BURN</span>}
                {activeCreature.poisonTurns > 0 && <span style={{ ...styles.status, backgroundColor: '#1a3a1a', border: '2px solid #48bb78', color: '#48bb78' }}>PSN</span>}
                {activeCreature.chillTurns > 0 && <span style={{ ...styles.status, backgroundColor: '#1a2a3a', border: '2px solid #63b3ed', color: '#63b3ed' }}>CHL</span>}
                {activeCreature.isGuarding && <span style={{ ...styles.status, backgroundColor: '#1a2a3a', border: `1px solid ${GBC.blue}`, color: GBC.blue }}>GRD</span>}
              </span>
              <span style={{ fontSize: 'var(--font-sm)', color: GBC.textDim }}>
                {activeCreature.hp}/{maxHp}
              </span>
            </div>
            <div style={styles.hpBar} className={playerHpPercent <= 25 ? 'hp-low' : ''}>
              <div style={{
                ...styles.hpFill,
                width: `${playerHpPercent}%`,
                backgroundColor: playerHpPercent > 50 ? GBC.green : playerHpPercent > 25 ? GBC.gold : GBC.red
              }} />
            </div>
            <div style={{ fontSize: 'var(--font-xs)', color: GBC.textDim, marginTop: '3px' }}>
              STA {activeCreature.stamina}/{maxStamina}
              {activeCreature.scars && activeCreature.scars.length > 0 && (
                <span style={{ marginLeft: 'var(--spacing-xs)' }}>
                  {activeCreature.scars.slice(0, 2).map((scar, j) => (
                    <span key={j} style={styles.scar}>{scar.name.slice(0, 4)}</span>
                  ))}
                </span>
              )}
            </div>
            <div
              style={{
                ...styles.staminaBar,
                borderColor: activeCreature.stamina < 5 ? GBC.red : activeCreature.stamina < 8 ? GBC.gold : GBC.border
              }}
              className={activeCreature.stamina < 5 ? 'stamina-warning' : ''}
            >
              <div style={{
                ...styles.staminaFill,
                width: `${(activeCreature.stamina / maxStamina) * 100}%`,
                backgroundColor: activeCreature.stamina < 5 ? GBC.red : activeCreature.stamina < 8 ? GBC.gold : GBC.blue
              }} />
            </div>
          </div>

          {/* Move buttons */}
          <div style={styles.moveButtons}>
            {activeBase.moves.map((move, i) => {
              const adjustedMove = getMoveWithPriority(move);
              const canUse = adjustedMove.cost <= activeCreature.stamina && state.turnPhase === 'player';

              return (
                <button
                  key={i}
                  style={{
                    ...styles.moveButton,
                    ...(canUse ? {} : styles.moveButtonDisabled),
                    position: 'relative'
                  }}
                  disabled={!canUse}
                  onClick={() => { playSfx('menuClick'); dispatch({ type: 'SELECT_MOVE', move: adjustedMove }); }}
                >
                  <span style={{
                    position: 'absolute',
                    top: '2px',
                    left: '4px',
                    fontSize: 'var(--font-xs)',
                    color: GBC.textDim,
                    opacity: 0.6
                  }}>{i + 1}</span>
                  <div>{adjustedMove.name}</div>
                  <div style={{ fontSize: 'var(--font-xs)', color: GBC.textDim, marginTop: '3px' }}>
                    {adjustedMove.cost}SP
                    {adjustedMove.damage > 0 ? ` ${adjustedMove.damage}DMG` : ` ${adjustedMove.effect?.toUpperCase()}`}
                    {adjustedMove.priority && !hasFlinching && ' PRI'}
                  </div>
                </button>
              );
            })}

            {/* Bind button - only for wild creatures, not bosses */}
            {!state.isBossFight && (() => {
              const teamFull = state.team.length >= MAX_TEAM_SIZE;
              const canAfford = state.souls >= BIND_COST;
              const canBind = canAfford && state.turnPhase === 'player';
              const difficulty = getDifficulty(state);
              const captureChance = getCaptureChance(state.enemy.hp, state.enemy.maxHp, difficulty.captureBonus);

              return (
                <button
                  style={{
                    ...styles.bindButton,
                    ...(canBind ? {} : styles.bindButtonDisabled),
                    position: 'relative'
                  }}
                  disabled={!canBind}
                  onClick={() => dispatch({ type: 'BIND_ATTEMPT' })}
                  title={`${captureChance}% capture chance`}
                >
                  <span style={{
                    position: 'absolute',
                    top: '2px',
                    left: '4px',
                    fontSize: 'var(--font-xs)',
                    color: GBC.textDim,
                    opacity: 0.6
                  }}>B</span>
                  <div>SOUL BIND ({BIND_COST} souls)</div>
                  <div style={{ fontSize: 'var(--font-xs)', marginTop: '3px', color: teamFull ? GBC.gold : 'inherit' }}>
                    {!canAfford ? `NEED ${BIND_COST - state.souls} MORE SOULS` :
                     teamFull ? 'MUST RELEASE ONE' :
                     `${captureChance}% CHANCE`}
                  </div>
                </button>
              );
            })()}
          </div>

          {state.team.length > 1 && (
            <div style={{ marginTop: 'var(--spacing-sm)' }}>
              <div style={{ fontSize: 'var(--font-xs)', color: GBC.textDim, marginBottom: 'var(--spacing-xs)' }}>SWITCH:</div>
              <div style={{ display: 'flex', gap: 'var(--spacing-xs)' }}>
                {state.team.map((creature, i) => {
                  if (i === state.activeCreatureIndex) return null;
                  const base = STARTERS[creature.id];
                  const stats = applyScars(creature, base);
                  return (
                    <button
                      key={i}
                      style={{
                        ...styles.moveButton,
                        flex: 1,
                        opacity: creature.hp <= 0 ? 0.5 : 1
                      }}
                      disabled={creature.hp <= 0 || state.turnPhase !== 'player'}
                      onClick={() => dispatch({ type: 'SWITCH_CREATURE', index: i })}
                    >
                      {getTypeIcon(creature.type)} {creature.nickname || creature.name} ({creature.hp}/{stats.maxHp})
                    </button>
                  );
                })}
              </div>
            </div>
          )}

          <div style={styles.log}>
            {state.battleLog.map((log, i) => (
              <div key={i} style={{ marginBottom: '2px' }}>{log}</div>
            ))}
          </div>
        </div>
      );
    }

    function Victory({ state, dispatch }) {
      const totalScars = state.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0);
      const survivingCreatures = state.team.filter(c => c.hp > 0).length;
      const isHollowWarden = state.hollowWardenDefeated && state.currentMap === 'hollowDeep';

      // Play victory sound on mount
      useEffect(() => {
        playSfx('victory');
      }, []);

      return (
        <div style={styles.victory}>
          {/* Boss final words */}
          <div style={{ marginBottom: 'var(--spacing-lg)' }}>
            <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-sm)' }}>
              {isHollowWarden
                ? 'The Hollow Warden fractures into light and shadow. A voice echoes:'
                : 'The Obsidian Hound collapses. Varek speaks one last time:'}
            </div>
            {(isHollowWarden ? HOLLOW_WARDEN_DIALOGUE.victory : BOSS_DIALOGUE.victory).map((line, i) => (
              <div key={i} style={styles.victoryDialogue}>{line.replace('{name}', state.playerName || 'Ashen One')}</div>
            ))}
          </div>

          <div style={{
            margin: 'var(--spacing-lg) 0',
            padding: 'var(--spacing-md)',
            backgroundColor: isHollowWarden ? 'rgba(159, 122, 234, 0.1)' : 'rgba(104, 211, 145, 0.1)',
            border: `2px solid ${isHollowWarden ? GBC.dark : GBC.green}`
          }}>
            <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-sm)' }}>
              {isHollowWarden
                ? 'The deep falls silent. The surface awaits.'
                : 'The gate opens. Light pours through.'}
            </div>
          </div>

          <div style={styles.victoryTitle}>
            {isHollowWarden ? 'THE HOLLOW DEEP - CLEARED' : `${(state.playerName || 'ASHEN ONE').toUpperCase()} SURVIVED`}
          </div>

          <div style={{ margin: 'var(--spacing-lg) 0', textAlign: 'left', display: 'inline-block' }}>
            <p style={{ color: GBC.red, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-sm)' }}>
              Scars earned: {totalScars}
            </p>
            <p style={{ color: GBC.gold, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-sm)' }}>
              Souls banked: {state.souls + state.bankedSouls}
            </p>
            <p style={{ color: GBC.green, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-sm)' }}>
              Creatures bound: {state.team.length}
            </p>
            <p style={{ color: GBC.textDim, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-sm)' }}>
              Time: {formatPlayTime(state.playTime)}
            </p>
          </div>

          <div style={styles.victorySubtitle}>
            {isHollowWarden
              ? '"You have walked through shadow and emerged."'
              : '"Scarred but not broken."'}
          </div>

          <div style={{ display: 'flex', gap: 'var(--spacing-md)', justifyContent: 'center', marginTop: 'var(--spacing-lg)' }}>
            <button
              style={styles.button}
              onClick={() => dispatch({ type: 'RESTART' })}
            >
              NEW GAME+
            </button>
            <button
              style={styles.button}
              onClick={() => dispatch({ type: 'SHOW_CREDITS' })}
            >
              CREDITS
            </button>
          </div>
        </div>
      );
    }

    function GameOver({ state, dispatch }) {
      const difficulty = getDifficulty(state);
      const isPermadeath = difficulty.permadeath;

      // Play death sound, record ghost/fallen, and delete save on permadeath
      useEffect(() => {
        playSfx('death');
        if (isPermadeath) {
          recordFallen(state);
          deleteSaveData();
        } else {
          recordGhost(state);
        }
      }, [isPermadeath]);

      const playerName = state.playerName || 'Ashen One';

      return (
        <div style={styles.gameOver}>
          <div style={{ fontSize: 'var(--font-lg)', color: GBC.red, marginBottom: 'var(--spacing-lg)' }}>
            {(() => {
              const deathMessages = [
                `${playerName} died. Again.`,
                "That went well.",
                "The flame remembers. Unfortunately.",
                `${playerName}'s creatures believed in them. That was their mistake.`,
                "Scars build character. You have plenty now."
              ];
              return deathMessages[Math.floor(Math.random() * deathMessages.length)];
            })()}
          </div>

          {isPermadeath && (
            <div style={{
              marginBottom: 'var(--spacing-lg)',
              padding: 'var(--spacing-md)',
              backgroundColor: 'rgba(252, 129, 129, 0.1)',
              border: `2px solid ${GBC.red}`
            }}>
              <p style={{ color: GBC.red, fontSize: 'var(--font-sm)', marginBottom: 'var(--spacing-xs)' }}>PERMADEATH</p>
              <p style={{ color: GBC.textDim, fontSize: 'var(--font-xs)' }}>Your save has been erased.</p>
            </div>
          )}

          {state.diedToBoss && (
            <div style={{ marginBottom: 'var(--spacing-lg)' }}>
              {BOSS_DIALOGUE.playerDeath.map((line, i) => (
                <p key={i} style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', fontStyle: 'italic', marginBottom: 'var(--spacing-xs)' }}>
                  {line}
                </p>
              ))}
            </div>
          )}

          {state.droppedSouls && !isPermadeath && (
            <p style={{ color: GBC.gold, marginBottom: 'var(--spacing-lg)', fontSize: 'var(--font-sm)' }}>
              {state.droppedSouls.amount} souls dropped
            </p>
          )}

          <p style={{ color: GBC.textDim, marginBottom: 'var(--spacing-lg)', fontSize: 'var(--font-sm)' }}>
            {isPermadeath ? 'Broken beyond repair.' : 'Scarred but not broken.'}
          </p>

          <button
            style={styles.button}
            onClick={() => dispatch({ type: isPermadeath ? 'RESTART' : 'RESPAWN' })}
          >
            {isPermadeath ? 'NEW GAME' : 'RETURN'}
          </button>
        </div>
      );
    }

    function Prologue({ dispatch, state }) {
      const getAppearanceLine = (appearance) => {
        switch(appearance) {
          case 'male':
          case 'female':
            return "A warrior's path lies ahead.";
          default:
            return 'Your path is your own to forge.';
        }
      };

      const prologueLines = [
        { text: 'The bonfire wars ended long ago.', highlight: false },
        { text: '', highlight: false },
        { text: 'Binders and their companions fell, one by one.', highlight: false },
        { text: '', highlight: false },
        { text: 'The creatures that survived... changed.', highlight: false },
        { text: '', highlight: false },
        { text: 'Now they wander the ashen paths, feral and scarred.', highlight: false },
        { text: '', highlight: false },
        { text: 'You are not the first to wake at this flame.', highlight: true },
        { text: '', highlight: false },
        { text: 'You will not be the last.', highlight: false },
        { text: '', highlight: false },
        { text: 'But perhaps you will be the one who endures.', highlight: true },
        { text: '', highlight: false },
        { text: getAppearanceLine(state?.playerAppearance), highlight: true }
      ];

      return (
        <div style={styles.prologue}>
          <div style={{ marginBottom: 'var(--spacing-xl)' }}>
            {prologueLines.map((line, i) => (
              <div
                key={i}
                style={line.highlight ? styles.prologueHighlight : styles.prologueLine}
              >
                {line.text || '\u00A0'}
              </div>
            ))}
          </div>

          <button
            style={styles.button}
            onClick={() => dispatch({ type: 'CONTINUE_FROM_PROLOGUE' })}
          >
            CONTINUE
          </button>
        </div>
      );
    }

    function Credits({ dispatch }) {
      return (
        <div style={styles.credits}>
          <div style={styles.creditsTitle}>SCARS OF ASH</div>

          <div style={{ marginBottom: 'var(--spacing-xl)' }}>
            <div style={{ color: GBC.gold, fontSize: 'var(--font-sm)', fontStyle: 'italic' }}>
              The flame remembers.
            </div>
          </div>

          <div style={styles.creditsSection}>
            <div style={styles.creditsLabel}>Created by</div>
            <div style={styles.creditsValue}>BBAD Games</div>
          </div>

          <div style={styles.creditsSection}>
            <div style={styles.creditsLabel}>Built with</div>
            <div style={styles.creditsValue}>Claude Code</div>
          </div>

          <div style={styles.creditsSection}>
            <div style={styles.creditsLabel}>Music</div>
            <div style={styles.creditsValue}>Procedural chiptune via Tone.js</div>
          </div>

          <div style={styles.creditsQuote}>
            "The bonfire wars are over.<br/>
            But the flames still burn.<br/>
            And someone must carry them forward."
          </div>

          <div style={{ marginTop: 'var(--spacing-lg)', marginBottom: 'var(--spacing-lg)' }}>
            <div style={{ color: GBC.text, fontSize: 'var(--font-sm)' }}>
              Thank you for playing.
            </div>
          </div>

          <button
            style={styles.button}
            onClick={() => dispatch({ type: 'RETURN_TO_TITLE' })}
          >
            RETURN TO TITLE
          </button>
        </div>
      );
    }

    function ReleaseScreen({ state, dispatch }) {
      const [selectedIndex, setSelectedIndex] = useState(null);
      const [confirmOpen, setConfirmOpen] = useState(false);
      const pendingCreature = state.pendingCapture;

      const handleSelect = (index) => {
        playSfx('menuClick');
        setSelectedIndex(index);
        setConfirmOpen(true);
      };

      const handleConfirmRelease = () => {
        playSfx('menuClick');
        dispatch({ type: 'RELEASE_FOR_CAPTURE', releaseIndex: selectedIndex });
      };

      const handleCancel = () => {
        playSfx('menuClick');
        setConfirmOpen(false);
        setSelectedIndex(null);
      };

      const handleEscape = () => {
        playSfx('menuClick');
        dispatch({ type: 'CANCEL_CAPTURE' });
      };

      if (!pendingCreature) return null;

      const selectedCreature = selectedIndex !== null ? state.team[selectedIndex] : null;

      return (
        <div style={{
          ...styles.starterSelect,
          minHeight: 'clamp(400px, 70vh, 700px)',
          display: 'flex',
          flexDirection: 'column',
          padding: 'var(--spacing-md)'
        }}>
          {/* Header */}
          <div style={{ textAlign: 'center', marginBottom: 'var(--spacing-md)' }}>
            <div style={{ color: GBC.gold, fontSize: 'var(--font-md)', marginBottom: 'var(--spacing-sm)' }}>
              TEAM FULL
            </div>
            <div style={{ color: GBC.textDim, fontSize: 'var(--font-sm)' }}>
              Release one to make room for {pendingCreature.name}
            </div>
          </div>

          {/* Pending creature preview */}
          <div style={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            gap: 'var(--spacing-md)',
            marginBottom: 'var(--spacing-md)',
            padding: 'var(--spacing-sm)',
            backgroundColor: 'rgba(245, 203, 92, 0.1)',
            border: `2px solid ${GBC.gold}`
          }}>
            <CreatureSprite type={pendingCreature.type} size={32} scarCount={pendingCreature.scars?.length || 0} />
            <div>
              <div style={{ color: GBC.gold, fontSize: 'var(--font-sm)' }}>
                {getTypeIcon(pendingCreature.type)} {pendingCreature.name}
              </div>
              <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)' }}>
                HP: {pendingCreature.hp}/{pendingCreature.maxHp} | Scars: {pendingCreature.scars?.length || 0}
              </div>
            </div>
          </div>

          {/* Confirmation dialog */}
          {confirmOpen && selectedCreature && (
            <div style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              backgroundColor: 'rgba(0, 0, 0, 0.85)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 100,
              padding: 'var(--spacing-md)'
            }}>
              <div style={{
                backgroundColor: GBC.bg,
                border: `3px solid ${GBC.red}`,
                padding: 'var(--spacing-lg)',
                maxWidth: '350px',
                textAlign: 'center'
              }}>
                <div style={{ marginBottom: 'var(--spacing-md)' }}>
                  <CreatureSprite type={selectedCreature.type} size={48} scarCount={selectedCreature.scars?.length || 0} />
                </div>
                <div style={{ color: GBC.red, fontSize: 'var(--font-sm)', marginBottom: 'var(--spacing-sm)' }}>
                  Release {selectedCreature.nickname || selectedCreature.name} forever?
                </div>
                <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-lg)' }}>
                  They will not return.
                </div>
                <div style={{ display: 'flex', gap: 'var(--spacing-md)', justifyContent: 'center' }}>
                  <button
                    style={{ ...styles.button, padding: 'var(--spacing-sm) var(--spacing-lg)' }}
                    onClick={handleCancel}
                  >
                    BACK
                  </button>
                  <button
                    style={{
                      ...styles.button,
                      padding: 'var(--spacing-sm) var(--spacing-lg)',
                      borderColor: GBC.red,
                      color: GBC.red
                    }}
                    onClick={handleConfirmRelease}
                  >
                    RELEASE
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Team list */}
          <div style={{ flex: 1, overflow: 'auto' }}>
            <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-sm)' }}>
              SELECT CREATURE TO RELEASE:
            </div>
            <div style={{ display: 'flex', flexDirection: 'column', gap: 'var(--spacing-sm)' }}>
              {state.team.map((creature, i) => {
                const base = STARTERS[creature.id];
                const difficulty = getDifficulty(state);
                const stats = applyScars(creature, base, difficulty.hollowedThreshold);
                const isHollowed = (creature.scars?.length || 0) >= difficulty.hollowedThreshold;

                return (
                  <button
                    key={i}
                    style={{
                      ...styles.button,
                      display: 'flex',
                      alignItems: 'center',
                      gap: 'var(--spacing-sm)',
                      padding: 'var(--spacing-sm)',
                      textAlign: 'left',
                      minHeight: '60px'
                    }}
                    onClick={() => handleSelect(i)}
                  >
                    <CreatureSprite type={creature.type} size={32} scarCount={creature.scars?.length || 0} isHollowed={isHollowed} />
                    <div style={{ flex: 1 }}>
                      <div style={{ color: isHollowed ? GBC.textDim : GBC.text, fontSize: 'var(--font-sm)' }}>
                        {getTypeIcon(creature.type)} {creature.nickname || creature.name}
                        {isHollowed && <span style={{ color: GBC.textDim }}> (Hollowed)</span>}
                      </div>
                      <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginTop: '2px' }}>
                        HP: {creature.hp}/{stats.maxHp} | SP: {creature.stamina}/{stats.maxStamina} | Scars: {creature.scars?.length || 0}
                      </div>
                      {creature.scars?.length > 0 && (
                        <div style={{ color: GBC.red, fontSize: 'var(--font-xs)', marginTop: '2px' }}>
                          {creature.scars.map(s => s.name).join(', ')}
                        </div>
                      )}
                    </div>
                  </button>
                );
              })}
            </div>
          </div>

          {/* Cancel option */}
          <div style={{ marginTop: 'var(--spacing-md)', textAlign: 'center' }}>
            <button
              style={{
                ...styles.button,
                padding: 'var(--spacing-sm) var(--spacing-lg)',
                borderColor: GBC.textDim,
                color: GBC.textDim
              }}
              onClick={handleEscape}
            >
              LET IT ESCAPE
            </button>
            <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginTop: 'var(--spacing-xs)' }}>
              (Souls already spent)
            </div>
          </div>
        </div>
      );
    }

    function NicknameScreen({ creature, dispatch }) {
      const [nickname, setNickname] = useState('');
      const inputRef = useRef(null);

      useEffect(() => {
        if (inputRef.current) {
          inputRef.current.focus();
        }
      }, []);

      const handleSubmit = (e) => {
        e.preventDefault();
        playSfx('captureSuccess');
        dispatch({ type: 'SET_NICKNAME', nickname: nickname.trim() || null });
      };

      const handleSkip = () => {
        playSfx('menuClick');
        dispatch({ type: 'SET_NICKNAME', nickname: null });
      };

      return (
        <div style={{
          ...styles.starterSelect,
          minHeight: 'clamp(400px, 60vh, 600px)',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          alignItems: 'center'
        }}>
          <div style={{ marginBottom: 'var(--spacing-lg)' }}>
            <CreatureSprite type={creature.type} size={64} scarCount={creature.scars?.length || 0} />
          </div>

          <div style={{ color: GBC.gold, fontSize: 'var(--font-md)', marginBottom: 'var(--spacing-sm)' }}>
            {creature.name} joined your disaster.
          </div>

          <div style={{ color: GBC.textDim, fontSize: 'var(--font-sm)', marginBottom: 'var(--spacing-lg)' }}>
            Give your new companion a name?
          </div>

          <form onSubmit={handleSubmit} style={{ width: '100%', maxWidth: '300px' }}>
            <input
              ref={inputRef}
              type="text"
              value={nickname}
              onChange={(e) => setNickname(e.target.value.slice(0, 12))}
              placeholder={creature.name}
              maxLength={12}
              style={{
                width: '100%',
                padding: 'var(--spacing-md)',
                backgroundColor: GBC.bgLight,
                border: `3px solid ${GBC.border}`,
                color: GBC.text,
                fontFamily: '"Press Start 2P", monospace',
                fontSize: 'var(--font-sm)',
                textAlign: 'center',
                marginBottom: 'var(--spacing-md)'
              }}
            />

            <div style={{ display: 'flex', gap: 'var(--spacing-md)', justifyContent: 'center' }}>
              <button
                type="button"
                style={{ ...styles.button, padding: 'var(--spacing-sm) var(--spacing-lg)' }}
                onClick={handleSkip}
              >
                SKIP
              </button>
              <button
                type="submit"
                style={{
                  ...styles.button,
                  padding: 'var(--spacing-sm) var(--spacing-lg)',
                  borderColor: GBC.gold,
                  color: GBC.gold
                }}
              >
                CONFIRM
              </button>
            </div>
          </form>
        </div>
      );
    }

    function EncounterPreview({ encounter, dispatch }) {
      if (!encounter) return null;
      const { wildData } = encounter;

      const handleFight = () => {
        playSfx('menuClick');
        dispatch({ type: 'CONFIRM_ENCOUNTER' });
      };

      const handleFlee = () => {
        playSfx('menuClick');
        dispatch({ type: 'FLEE_ENCOUNTER' });
      };

      return (
        <div style={{
          ...styles.starterSelect,
          minHeight: 'clamp(300px, 50vh, 400px)',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          alignItems: 'center'
        }}>
          <div style={{ color: GBC.textDim, fontSize: 'var(--font-sm)', marginBottom: 'var(--spacing-lg)' }}>
            Something stirs in the grass...
          </div>

          <div style={{ marginBottom: 'var(--spacing-lg)' }}>
            <div style={{
              width: '80px',
              height: '80px',
              backgroundColor: GBC.bgLight,
              border: `3px solid ${getTypeColor(wildData.type)}`,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: 'var(--font-2xl)'
            }}>
              {getTypeIcon(wildData.type)}
            </div>
          </div>

          <div style={{ color: getTypeColor(wildData.type), fontSize: 'var(--font-md)', marginBottom: 'var(--spacing-xs)' }}>
            {wildData.type.toUpperCase()} TYPE
          </div>

          <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-lg)' }}>
            Wild creature detected
          </div>

          <div style={{ display: 'flex', gap: 'var(--spacing-md)' }}>
            <button
              style={{ ...styles.button, padding: 'var(--spacing-sm) var(--spacing-xl)' }}
              onClick={handleFlee}
            >
              FLEE
            </button>
            <button
              style={{
                ...styles.button,
                padding: 'var(--spacing-sm) var(--spacing-xl)',
                borderColor: GBC.gold,
                color: GBC.gold
              }}
              onClick={handleFight}
            >
              FIGHT
            </button>
          </div>
        </div>
      );
    }

    function StatsScreen({ onClose }) {
      const stats = loadStats();
      const allCreatures = ['cindrath', 'marshveil', 'thornwick', 'umbravine', 'solrath'];

      const achievements = [
        {
          id: 'unscarred',
          name: 'Unscarred',
          desc: 'Beat the game with 0 scars',
          unlocked: Object.values(stats.lowestScars).some(s => s === 0)
        },
        {
          id: 'collector',
          name: 'Collector',
          desc: 'Capture all 5 creature types',
          unlocked: allCreatures.every(c => stats.creaturesCollected.includes(c))
        },
        {
          id: 'trueHollow',
          name: 'True Hollow',
          desc: 'Defeat the Hollow Warden on Broken',
          unlocked: stats.hollowWardenDefeated && stats.completedRuns.broken > 0
        },
        {
          id: 'speedrunner',
          name: 'Speedrunner',
          desc: 'Clear in under 20 minutes',
          unlocked: Object.values(stats.fastestClear).some(t => t !== null && t < 20 * 60 * 1000)
        }
      ];

      return (
        <div style={{
          ...styles.starterSelect,
          minHeight: 'clamp(400px, 70vh, 700px)',
          overflowY: 'auto'
        }}>
          <h1 style={{ color: GBC.gold, marginBottom: 'var(--spacing-lg)', fontSize: 'var(--font-xl)' }}>
            STATISTICS
          </h1>

          <div style={{ marginBottom: 'var(--spacing-lg)', textAlign: 'left', width: '100%', maxWidth: '400px' }}>
            <div style={{ color: GBC.textDim, marginBottom: 'var(--spacing-sm)', fontSize: 'var(--font-sm)' }}>
              OVERALL
            </div>
            <div style={{ color: GBC.text, fontSize: 'var(--font-xs)', marginBottom: '4px' }}>
              Total Runs: {stats.totalRuns}
            </div>
            <div style={{ color: GBC.text, fontSize: 'var(--font-xs)', marginBottom: '4px' }}>
              Total Deaths: {stats.totalDeaths}
            </div>
            <div style={{ color: GBC.text, fontSize: 'var(--font-xs)', marginBottom: '4px' }}>
              Total Scars: {stats.totalScarsEarned}
            </div>
            <div style={{ color: GBC.text, fontSize: 'var(--font-xs)', marginBottom: '4px' }}>
              Creatures Captured: {stats.totalCreaturesCaptured}
            </div>
          </div>

          <div style={{ marginBottom: 'var(--spacing-lg)', textAlign: 'left', width: '100%', maxWidth: '400px' }}>
            <div style={{ color: GBC.textDim, marginBottom: 'var(--spacing-sm)', fontSize: 'var(--font-sm)' }}>
              CLEARS BY DIFFICULTY
            </div>
            {Object.entries(DIFFICULTIES).map(([id, diff]) => (
              <div key={id} style={{ color: GBC.text, fontSize: 'var(--font-xs)', marginBottom: '4px' }}>
                {diff.icon} {diff.name}: {stats.completedRuns[id] || 0}
                {stats.fastestClear[id] && (
                  <span style={{ color: GBC.textDim }}> (Best: {formatPlayTime(stats.fastestClear[id])})</span>
                )}
              </div>
            ))}
          </div>

          <div style={{ marginBottom: 'var(--spacing-lg)', textAlign: 'left', width: '100%', maxWidth: '400px' }}>
            <div style={{ color: GBC.textDim, marginBottom: 'var(--spacing-sm)', fontSize: 'var(--font-sm)' }}>
              ACHIEVEMENTS
            </div>
            {achievements.map(ach => (
              <div
                key={ach.id}
                style={{
                  color: ach.unlocked ? GBC.gold : GBC.textDim,
                  fontSize: 'var(--font-xs)',
                  marginBottom: '4px',
                  opacity: ach.unlocked ? 1 : 0.6
                }}
              >
                {ach.unlocked ? '★' : '☆'} {ach.name}
                <span style={{ color: GBC.textDim, marginLeft: '8px' }}>
                  - {ach.desc}
                </span>
              </div>
            ))}
          </div>

          <button
            style={styles.button}
            onClick={onClose}
          >
            BACK
          </button>
        </div>
      );
    }

    function HallOfFallen({ onClose }) {
      const fallen = loadFallen();
      const mapNames = {
        ashenPath: 'Ashen Path',
        fallenKeep: 'Fallen Keep',
        hollowDeep: 'The Hollow Deep',
        labyrinth: 'The Labyrinth'
      };

      return (
        <div style={{
          ...styles.starterSelect,
          minHeight: 'clamp(400px, 70vh, 700px)',
          overflowY: 'auto'
        }}>
          <h1 style={{ color: GBC.red, marginBottom: 'var(--spacing-sm)', fontSize: 'var(--font-xl)' }}>
            HALL OF THE FALLEN
          </h1>
          <div style={{ color: GBC.gold, fontSize: 'var(--font-xs)', fontStyle: 'italic', marginBottom: 'var(--spacing-lg)' }}>
            The flame remembers those who burned brightest.
          </div>

          {fallen.length === 0 ? (
            <div style={{ color: GBC.textDim, fontSize: 'var(--font-sm)', marginBottom: 'var(--spacing-lg)' }}>
              No souls have fallen on the Broken path... yet.
            </div>
          ) : (
            <div style={{ width: '100%', maxWidth: '400px' }}>
              {fallen.map(entry => (
                <div key={entry.id} style={{
                  backgroundColor: GBC.bgPanel,
                  border: `2px solid ${GBC.border}`,
                  padding: 'var(--spacing-sm)',
                  marginBottom: 'var(--spacing-sm)',
                  textAlign: 'left'
                }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: 'var(--spacing-sm)', marginBottom: 'var(--spacing-xs)' }}>
                    <div style={{ width: '24px', height: '24px', overflow: 'hidden', flexShrink: 0 }}>
                      <div style={{ transform: 'scale(0.5)', transformOrigin: 'top left' }}>
                        <PlayerSprite direction="down" appearance={entry.playerAppearance || 'other'} />
                      </div>
                    </div>
                    <div style={{ color: GBC.red, fontSize: 'var(--font-sm)' }}>{entry.playerName}</div>
                  </div>
                  <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: '2px' }}>
                    Fell at: {mapNames[entry.finalMap] || entry.finalMap}
                  </div>
                  <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: '2px' }}>
                    Time: {formatPlayTime(entry.playTime || 0)} | Scars: {entry.totalScars}
                  </div>
                  <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)' }}>
                    Team: {(entry.team || []).map(c => c.name).join(', ') || 'Unknown'}
                  </div>
                </div>
              ))}
            </div>
          )}

          <button
            style={styles.button}
            onClick={onClose}
          >
            BACK
          </button>
        </div>
      );
    }

    function MuteButton({ muted, onToggle }) {
      return (
        <button
          style={styles.muteButton}
          onClick={onToggle}
          title={muted ? 'Unmute' : 'Mute'}
        >
          {muted ? '🔇' : '🔊'}
        </button>
      );
    }

    function HelpButton({ onClick }) {
      return (
        <button
          style={styles.helpButton}
          onClick={onClick}
          title="How to Play"
        >
          ?
        </button>
      );
    }

    function GearButton({ onClick }) {
      return (
        <button
          style={styles.gearButton}
          onClick={onClick}
          title="Menu (ESC)"
        >
          ⚙
        </button>
      );
    }

    function ConfirmDialog({ message, onConfirm, onCancel, confirmText = 'YES', cancelText = 'NO', danger = true }) {
      return (
        <div style={styles.confirmOverlay} onClick={onCancel}>
          <div style={styles.confirmDialog} onClick={e => e.stopPropagation()}>
            <div style={styles.confirmText}>{message}</div>
            <div style={styles.confirmButtons}>
              <button
                style={styles.confirmButton}
                onClick={onCancel}
              >
                {cancelText}
              </button>
              <button
                style={{
                  ...styles.confirmButton,
                  ...(danger ? styles.confirmButtonDanger : {})
                }}
                onClick={onConfirm}
              >
                {confirmText}
              </button>
            </div>
          </div>
        </div>
      );
    }

    function SaveSlotDisplay({ saveData }) {
      if (!saveData) return null;

      const totalScars = saveData.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0);
      const leadCreature = saveData.team[saveData.activeCreatureIndex] || saveData.team[0];
      const mapName = saveData.currentMap === 'ashenPath' ? 'Ashen Path' : saveData.currentMap === 'hollowDeep' ? 'The Hollow Deep' : saveData.currentMap === 'labyrinth' ? 'The Labyrinth' : 'Fallen Keep';
      const diff = DIFFICULTIES[saveData.difficulty] || DIFFICULTIES.scarred;

      const playerName = saveData.playerName || 'Ashen One';

      return (
        <div style={styles.saveSlot}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 'var(--spacing-sm)' }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: 'var(--spacing-sm)' }}>
              <div style={{ width: '16px', height: '16px', overflow: 'hidden' }}>
                <div style={{ transform: 'scale(0.333)', transformOrigin: 'top left' }}>
                  <PlayerSprite direction="down" appearance={saveData.playerAppearance || 'other'} />
                </div>
              </div>
              <div style={styles.saveSlotTitle}>{playerName.toUpperCase()}'S JOURNEY</div>
            </div>
            <div style={{ fontSize: 'var(--font-base)' }}>
              {diff.icon} <span style={{ fontSize: 'var(--font-xs)', color: GBC.textDim }}>{diff.name}</span>
            </div>
          </div>
          <div style={styles.saveSlotStat}>
            Lead: {leadCreature?.name || 'Unknown'} ({saveData.team.length} creature{saveData.team.length > 1 ? 's' : ''})
          </div>
          <div style={styles.saveSlotStat}>
            Location: {mapName}
          </div>
          <div style={styles.saveSlotStat}>
            Souls banked: {saveData.bankedSouls}
          </div>
          <div style={styles.saveSlotStat}>
            Scars: {totalScars}
          </div>
          <div style={styles.saveSlotStat}>
            Time played: {formatPlayTime(saveData.playTime || 0)}
          </div>
          {saveData.bossDefeated && (
            <div style={{ ...styles.saveSlotStat, color: GBC.gold }}>
              Boss defeated
            </div>
          )}
        </div>
      );
    }

    function PauseMenu({ onResume, onSave, onLoad, onNewGame, onHelp, hasSave, state }) {
      return (
        <div style={styles.pauseOverlay}>
          <div style={styles.pauseMenu}>
            <div style={styles.pauseTitle}>PAUSED</div>

            {state && (
              <div style={{
                marginBottom: 'var(--spacing-md)',
                padding: 'var(--spacing-sm)',
                backgroundColor: GBC.bgPanel,
                border: `2px solid ${GBC.border}`,
                display: 'flex',
                alignItems: 'center',
                gap: 'var(--spacing-sm)'
              }}>
                <div style={{ width: '24px', height: '24px', overflow: 'hidden', flexShrink: 0 }}>
                  <div style={{ transform: 'scale(0.5)', transformOrigin: 'top left' }}>
                    <PlayerSprite direction="down" appearance={state.playerAppearance || 'other'} />
                  </div>
                </div>
                <div style={{ textAlign: 'left' }}>
                  <div style={{ color: GBC.text, fontSize: 'var(--font-xs)' }}>
                    {state.playerName || 'Ashen One'}
                    {state.activeTitle && (() => {
                      const titleData = TITLES.find(t => t.id === state.activeTitle);
                      return titleData ? `, ${titleData.name}` : '';
                    })()}
                  </div>
                  <div style={{ color: GBC.gold, fontSize: 'var(--font-xs)' }}>
                    {state.souls}/{state.bankedSouls} souls
                  </div>
                  <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)' }}>
                    {state.team.length} creature{state.team.length !== 1 ? 's' : ''} | {state.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0)} scar{state.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0) !== 1 ? 's' : ''}
                  </div>
                </div>
              </div>
            )}

            <div
              style={styles.pauseOption}
              onClick={onResume}
              onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
              onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
            >
              RESUME
            </div>

            <div
              style={styles.pauseOption}
              onClick={onSave}
              onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
              onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
            >
              SAVE GAME
            </div>

            <div
              style={{
                ...styles.pauseOption,
                ...(hasSave ? {} : styles.pauseOptionDisabled)
              }}
              onClick={hasSave ? onLoad : undefined}
              onMouseOver={e => hasSave && (e.currentTarget.style.borderColor = GBC.gold)}
              onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
            >
              LOAD GAME
            </div>

            <div
              style={styles.pauseOption}
              onClick={onNewGame}
              onMouseOver={e => e.currentTarget.style.borderColor = GBC.red}
              onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
            >
              NEW GAME
            </div>

            <div
              style={styles.pauseOption}
              onClick={onHelp}
              onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
              onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
            >
              HELP
            </div>
          </div>
        </div>
      );
    }

    function LoadScreen({ saveData, onContinue, onNewGame }) {
      return (
        <div style={styles.loadScreen}>
          <div style={styles.loadTitle}>Continue your journey?</div>

          <SaveSlotDisplay saveData={saveData} />

          <div style={{ display: 'flex', gap: '12px', justifyContent: 'center', marginTop: '20px' }}>
            <button
              style={styles.button}
              onClick={onNewGame}
            >
              NEW GAME
            </button>
            <button
              style={{ ...styles.button, borderColor: GBC.gold, color: GBC.gold }}
              onClick={onContinue}
            >
              CONTINUE
            </button>
          </div>
        </div>
      );
    }

    function SaveNotification({ message, onDismiss }) {
      useEffect(() => {
        const timer = setTimeout(onDismiss, 2500);
        return () => clearTimeout(timer);
      }, [onDismiss]);

      return (
        <div style={styles.saveNotification}>
          {message}
        </div>
      );
    }

    function HelpOverlay({ onClose }) {
      return (
        <div style={styles.helpOverlay} onClick={onClose}>
          <div style={styles.helpContent} onClick={e => e.stopPropagation()}>
            <div style={styles.helpTitle}>HOW TO SURVIVE</div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>CONTROLS</div>
              <div style={styles.helpText}>
                WASD/Arrows - Move<br/>
                E - Rest at bonfire<br/>
                X - Examine surroundings<br/>
                ESC - Pause menu<br/>
                Click - Select moves
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>STAMINA (Battle Only)</div>
              <div style={styles.helpText}>
                Every battle move costs stamina.<br/>
                End turn below 5 = "Winded" (take +25% damage)<br/>
                REST move in battle: Recover 12 SP (skips attack)<br/>
                Bonfire rest: Fully restores stamina
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>SOULS</div>
              <div style={styles.helpText}>
                Earn from victories. Drop ALL on death.<br/>
                Die again before reclaiming = gone forever.<br/>
                Bank at bonfires for safety.
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>SCARS</div>
              <div style={styles.helpText}>
                Creatures gain permanent scars when they faint.<br/>
                Three scars = Hollowed (75% stats)
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>BONFIRE</div>
              <div style={styles.helpText}>
                Heals team. Banks souls. BUT respawns all enemies.
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>CAPTURE</div>
              <div style={styles.helpText}>
                SOUL BIND costs 20 souls. Lower HP = better odds.
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>TYPE MATCHUPS</div>
              <div style={styles.helpText}>
                <span style={{ color: GBC.fire }}>Fire</span> &gt; <span style={{ color: GBC.grass }}>Grass</span> &gt; <span style={{ color: GBC.water }}>Water</span> &gt; <span style={{ color: GBC.fire }}>Fire</span>
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>GOAL</div>
              <div style={styles.helpText}>
                Defeat Keeper Varek in the Fallen Keep.
              </div>
            </div>

            <div style={styles.helpQuote}>"Scarred but not broken."</div>

            <button style={styles.helpClose} onClick={onClose}>
              CLOSE
            </button>
          </div>
        </div>
      );
    }

    // Tap to Start splash screen
    function TapToStart({ onStart }) {
      return (
        <div
          style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: GBC.bg,
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            fontFamily: '"Press Start 2P", monospace',
            cursor: 'pointer',
            zIndex: 9999,
            padding: 'var(--spacing-lg)',
          }}
          onClick={onStart}
          onTouchStart={onStart}
        >
          <img
            src="assets/logo.png"
            alt="Scars of Ash"
            style={{
              maxWidth: '80%',
              maxHeight: '40vh',
              width: 'auto',
              height: 'auto',
              imageRendering: 'pixelated',
              marginBottom: 'var(--spacing-lg)',
            }}
          />
          <div style={{
            fontSize: 'var(--font-sm)',
            color: GBC.gold,
            marginBottom: 'var(--spacing-md)',
            textAlign: 'center',
            animation: 'flicker 2s infinite',
            textShadow: '1px 1px 0 #744210'
          }}>
            WARNING: THIS GAME MAY BREAK YOU
          </div>
          <div style={{
            fontSize: 'var(--font-xs)',
            color: GBC.textDim,
            marginBottom: 'var(--spacing-xl)'
          }}>
            The flame remembers.
          </div>
          <div style={{
            fontSize: 'var(--font-base)',
            color: GBC.text,
            animation: 'flicker 1.5s infinite'
          }}>
            {isTouchDevice() ? 'TAP TO START' : 'CLICK TO START'}
          </div>
        </div>
      );
    }


    // ============= MAIN APP =============
    function ScarsOfAsh() {
      const [state, dispatch] = useReducer(gameReducer, initialState);
      const [hasStarted, setHasStarted] = useState(false);
      const [muted, setMuted] = useState(true);
      const [audioStarted, setAudioStarted] = useState(false);
      const [showHelp, setShowHelp] = useState(false);
      const [showPauseMenu, setShowPauseMenu] = useState(false);
      const [showStats, setShowStats] = useState(false);
      const [showFallen, setShowFallen] = useState(false);
      const [confirmDialog, setConfirmDialog] = useState(null);
      const [checkingSave, setCheckingSave] = useState(true);
      const [existingSave, setExistingSave] = useState(null);
      const prevBonfireRef = useRef(null);
      const playTimeRef = useRef(Date.now());

      // Handle tap to start
      const handleStart = async () => {
        try {
          await musicManager.init();
          await sfxManager.init();
          setAudioStarted(true);
          setMuted(false);
          sfxManager.setMuted(false);
        } catch (e) {
          // Audio init failed, continue anyway
          console.warn('Audio initialization failed:', e);
        }
        setHasStarted(true);
      };

      // Check for existing save on mount
      useEffect(() => {
        const save = loadSaveData();
        if (save && save.team && save.team.length > 0) {
          setExistingSave(save);
        }
        setCheckingSave(false);
      }, []);

      // Show help on first visit (only if no save screen)
      useEffect(() => {
        if (!checkingSave && !existingSave) {
          const hasSeenHelp = localStorage.getItem('scarsOfAshHelpSeen');
          if (!hasSeenHelp) {
            setShowHelp(true);
          }
        }
      }, [checkingSave, existingSave]);

      // Track play time
      useEffect(() => {
        if (state.screen === 'exploration' || state.screen === 'battle') {
          const interval = setInterval(() => {
            const now = Date.now();
            const delta = now - playTimeRef.current;
            playTimeRef.current = now;
            dispatch({ type: 'UPDATE_PLAY_TIME', delta });
          }, 1000);
          return () => clearInterval(interval);
        }
        playTimeRef.current = Date.now();
      }, [state.screen]);

      // Handle ESC key for pause menu
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (e.key === 'Escape') {
            // Don't open pause in certain screens
            if (state.screen === 'starter' || state.screen === 'victory' ||
                state.screen === 'credits' || state.screen === 'gameOver') {
              return;
            }
            // Close help first if open
            if (showHelp) {
              setShowHelp(false);
              return;
            }
            // Close confirm dialog if open
            if (confirmDialog) {
              setConfirmDialog(null);
              return;
            }
            // Toggle pause menu
            setShowPauseMenu(prev => !prev);
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [state.screen, showHelp, confirmDialog]);

      const handleCloseHelp = () => {
        setShowHelp(false);
        localStorage.setItem('scarsOfAshHelpSeen', 'true');
      };

      // Check if player is currently on a bonfire tile
      const isOnBonfire = useCallback(() => {
        const map = state.currentMap === 'ashenPath' ? ASHEN_PATH : state.currentMap === 'hollowDeep' ? HOLLOW_DEEP : state.currentMap === 'labyrinth' ? LABYRINTH : FALLEN_KEEP;
        const tile = map[state.playerPos.y]?.[state.playerPos.x];
        return tile === 'B';
      }, [state.currentMap, state.playerPos]);

      // Compute the desired track based on game state
      const desiredTrack = (() => {
        if (state.screen === 'difficulty' || state.screen === 'starter') return null;
        if (state.screen === 'prologue') return 'bonfire';
        if (state.screen === 'victory') return 'victory';
        if (state.screen === 'credits') return 'bonfire';
        if (state.screen === 'gameOver') return 'gameOver';
        if (state.screen === 'battle') {
          if (state.isBossFight && state.bossPhase === 2) return 'bossPhase2';
          return 'battle';
        }
        if (state.screen === 'exploration') {
          return isOnBonfire() ? 'bonfire' : 'exploration';
        }
        return null;
      })();

      // Handle music transitions
      useEffect(() => {
        if (!audioStarted || muted) return;
        if (desiredTrack) {
          musicManager.switchTrack(desiredTrack);
        }
      }, [desiredTrack, audioStarted, muted]);

      const getTrackForState = useCallback(() => desiredTrack, [desiredTrack]);

      const handleToggleMute = async () => {
        if (!audioStarted) {
          await musicManager.init();
          await sfxManager.init();
          setAudioStarted(true);
          setMuted(false);
          sfxManager.setMuted(false);
          const track = getTrackForState();
          if (track) {
            musicManager.switchTrack(track);
          }
        } else {
          const newMuted = musicManager.toggleMute();
          setMuted(newMuted);
          sfxManager.setMuted(newMuted);
        }
      };

      // Track statistics
      const prevScreenRef = useRef(state.screen);
      const prevTeamLengthRef = useRef(state.team.length);
      const prevScarsRef = useRef(state.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0));

      useEffect(() => {
        // Track run start when moving from starter to exploration
        if (prevScreenRef.current === 'starter' && state.screen === 'exploration') {
          recordRunStart();
        }
        // Track death when going to gameOver
        if (state.screen === 'gameOver' && prevScreenRef.current !== 'gameOver') {
          recordDeath();
        }
        // Track victory
        if (state.screen === 'victory' && prevScreenRef.current !== 'victory') {
          const totalScars = state.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0);
          recordVictory(state.difficulty, state.playTime, totalScars, state.currentMap === 'hollowDeep');
        }
        prevScreenRef.current = state.screen;
      }, [state.screen, state.difficulty, state.playTime, state.team, state.currentMap]);

      useEffect(() => {
        // Track capture when team grows
        if (state.team.length > prevTeamLengthRef.current) {
          const newCreature = state.team[state.team.length - 1];
          if (newCreature) {
            recordCapture(newCreature.id);
          }
        }
        prevTeamLengthRef.current = state.team.length;
      }, [state.team.length, state.team]);

      useEffect(() => {
        // Track scar when total increases
        const currentScars = state.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0);
        if (currentScars > prevScarsRef.current) {
          for (let i = 0; i < currentScars - prevScarsRef.current; i++) {
            recordScar();
          }
        }
        prevScarsRef.current = currentScars;
      }, [state.team]);

      // Pause menu handlers
      const handleResume = () => setShowPauseMenu(false);

      const handleSave = () => {
        dispatch({ type: 'MANUAL_SAVE' });
        setShowPauseMenu(false);
      };

      const handleLoadRequest = () => {
        const save = loadSaveData();
        if (save) {
          setConfirmDialog({
            message: 'Load saved game? Unsaved progress will be lost.',
            onConfirm: () => {
              dispatch({ type: 'LOAD_GAME', saveData: save });
              setConfirmDialog(null);
              setShowPauseMenu(false);
            },
            onCancel: () => setConfirmDialog(null)
          });
        }
      };

      const handleNewGameRequest = () => {
        setConfirmDialog({
          message: 'Abandon this run? All progress will be lost.',
          onConfirm: () => {
            dispatch({ type: 'NEW_GAME_CONFIRMED' });
            setConfirmDialog(null);
            setShowPauseMenu(false);
            setExistingSave(null);
          },
          onCancel: () => setConfirmDialog(null)
        });
      };

      const handleHelpFromPause = () => {
        setShowPauseMenu(false);
        setShowHelp(true);
      };

      // Load screen handlers
      const handleContinueSave = () => {
        if (existingSave) {
          dispatch({ type: 'LOAD_GAME', saveData: existingSave });
          setExistingSave(null);
        }
      };

      const handleNewGameFromLoad = () => {
        setConfirmDialog({
          message: 'Start new game? Saved progress will be lost.',
          onConfirm: () => {
            deleteSaveData();
            setExistingSave(null);
            setConfirmDialog(null);
          },
          onCancel: () => setConfirmDialog(null)
        });
      };

      // Show tap to start screen (must be after all hooks)
      if (!hasStarted) {
        return <TapToStart onStart={handleStart} />;
      }

      // Show loading state
      if (checkingSave) {
        return (
          <div style={styles.container}>
            <div style={{ textAlign: 'center', padding: '40px', color: GBC.textDim }}>
              ...
            </div>
          </div>
        );
      }

      // Show load screen if save exists and we're at character creation or difficulty screen
      if (existingSave && (state.screen === 'characterCreate' || state.screen === 'difficulty')) {
        return (
          <div style={styles.container}>
            <LoadScreen
              saveData={existingSave}
              onContinue={handleContinueSave}
              onNewGame={handleNewGameFromLoad}
            />
            {confirmDialog && (
              <ConfirmDialog
                message={confirmDialog.message}
                onConfirm={confirmDialog.onConfirm}
                onCancel={confirmDialog.onCancel}
              />
            )}
          </div>
        );
      }

      // Check if pause menu is allowed
      const canPause = state.screen === 'exploration' || state.screen === 'battle' || state.screen === 'prologue';
      const hasSave = !!loadSaveData();

      return (
        <div style={styles.container}>
          {canPause && <GearButton onClick={() => setShowPauseMenu(true)} />}
          <HelpButton onClick={() => setShowHelp(true)} />
          <MuteButton muted={muted} onToggle={handleToggleMute} />

          {showHelp && <HelpOverlay onClose={handleCloseHelp} />}

          {showPauseMenu && canPause && (
            <PauseMenu
              onResume={handleResume}
              onSave={handleSave}
              onLoad={handleLoadRequest}
              onNewGame={handleNewGameRequest}
              onHelp={handleHelpFromPause}
              hasSave={hasSave}
              state={state}
            />
          )}

          {confirmDialog && (
            <ConfirmDialog
              message={confirmDialog.message}
              onConfirm={confirmDialog.onConfirm}
              onCancel={confirmDialog.onCancel}
            />
          )}

          {state.saveNotification && (
            <SaveNotification
              message={state.saveNotification}
              onDismiss={() => dispatch({ type: 'CLEAR_NOTIFICATION' })}
            />
          )}

          {/* Difficulty indicator during gameplay */}
          {(state.screen === 'exploration' || state.screen === 'battle') && (
            <DifficultyIndicator difficulty={state.difficulty} />
          )}

          {state.screen === 'characterCreate' && (
            <CharacterCreate dispatch={dispatch} />
          )}
          {state.screen === 'difficulty' && !showStats && !showFallen && (
            <DifficultySelect dispatch={dispatch} onShowStats={() => setShowStats(true)} onShowFallen={() => setShowFallen(true)} />
          )}
          {state.screen === 'difficulty' && showStats && (
            <StatsScreen onClose={() => setShowStats(false)} />
          )}
          {state.screen === 'difficulty' && showFallen && (
            <HallOfFallen onClose={() => setShowFallen(false)} />
          )}
          {state.screen === 'starter' && (
            <StarterSelect dispatch={dispatch} />
          )}
          {state.screen === 'prologue' && (
            <Prologue dispatch={dispatch} state={state} />
          )}
          {state.screen === 'exploration' && (
            <Exploration state={state} dispatch={dispatch} />
          )}
          {state.screen === 'battle' && (
            <Battle state={state} dispatch={dispatch} />
          )}
          {state.screen === 'victory' && (
            <Victory state={state} dispatch={dispatch} />
          )}
          {state.screen === 'gameOver' && (
            <GameOver state={state} dispatch={dispatch} />
          )}
          {state.screen === 'nickname' && (
            <NicknameScreen creature={state.pendingCreature} dispatch={dispatch} />
          )}
          {state.screen === 'release' && (
            <ReleaseScreen state={state} dispatch={dispatch} />
          )}
          {state.screen === 'encounterPreview' && (
            <EncounterPreview encounter={state.pendingEncounter} dispatch={dispatch} />
          )}
          {state.screen === 'credits' && (
            <Credits dispatch={dispatch} />
          )}
        </div>
      );
    }

    // Start preloading sprites in background (non-blocking)
    preloadSprites().catch(err => console.warn('Sprite preload failed:', err));

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<ScarsOfAsh />);
  </script>
</body>
</html>
