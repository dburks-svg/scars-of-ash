<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Poke Souls</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* CSS Custom Properties for responsive scaling */
    :root {
      /* Mobile-first defaults */
      --container-max-width: 520px;
      --tile-size: 56px;
      --font-xs: 7px;
      --font-sm: 8px;
      --font-base: 10px;
      --font-md: 12px;
      --font-lg: 14px;
      --font-xl: 16px;
      --font-2xl: 20px;
      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 12px;
      --spacing-lg: 16px;
      --spacing-xl: 24px;
      --button-size: 36px;
      --battle-height: 120px;
      --sprite-scale: 1;
    }

    /* Tablet - medium screens */
    @media (min-width: 768px) {
      :root {
        --container-max-width: 680px;
        --tile-size: 60px;
        --font-xs: 9px;
        --font-sm: 10px;
        --font-base: 12px;
        --font-md: 14px;
        --font-lg: 16px;
        --font-xl: 20px;
        --font-2xl: 24px;
        --spacing-sm: 10px;
        --spacing-md: 16px;
        --spacing-lg: 20px;
        --spacing-xl: 32px;
        --button-size: 44px;
        --battle-height: 150px;
        --sprite-scale: 1.2;
      }
    }

    /* Desktop - large screens */
    @media (min-width: 1024px) {
      :root {
        --container-max-width: 900px;
        --tile-size: 64px;
        --font-xs: 11px;
        --font-sm: 12px;
        --font-base: 14px;
        --font-md: 16px;
        --font-lg: 20px;
        --font-xl: 24px;
        --font-2xl: 32px;
        --spacing-sm: 12px;
        --spacing-md: 20px;
        --spacing-lg: 24px;
        --spacing-xl: 40px;
        --button-size: 48px;
        --battle-height: 180px;
        --sprite-scale: 1.5;
      }
    }

    /* Large desktop - 1440p+ */
    @media (min-width: 1440px) {
      :root {
        --container-max-width: 1000px;
        --tile-size: 72px;
        --font-xs: 12px;
        --font-sm: 14px;
        --font-base: 16px;
        --font-md: 18px;
        --font-lg: 22px;
        --font-xl: 28px;
        --font-2xl: 36px;
        --spacing-sm: 14px;
        --spacing-md: 24px;
        --spacing-lg: 28px;
        --spacing-xl: 48px;
        --button-size: 52px;
        --battle-height: 200px;
        --sprite-scale: 1.8;
      }
    }

    body {
      background-color: #0f0f1a;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    #root {
      max-width: var(--container-max-width);
      margin: 0 auto;
    }

    /* Bonfire animation */
    @keyframes flicker {
      0%, 100% { opacity: 1; transform: scale(1); }
      25% { opacity: 0.9; transform: scale(1.02, 0.98); }
      50% { opacity: 1; transform: scale(0.98, 1.02); }
      75% { opacity: 0.85; transform: scale(1.01, 0.99); }
    }

    @keyframes ember {
      0% { transform: translateY(0) scale(1); opacity: 1; }
      100% { transform: translateY(-8px) scale(0.5); opacity: 0; }
    }

    /* Grass sway animation */
    @keyframes grassSway {
      0%, 100% { transform: skewX(0deg); }
      50% { transform: skewX(2deg); }
    }

    /* Combat juice animations */
    @keyframes damageNumber {
      0% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(-30px); }
    }

    @keyframes screenShake {
      0%, 100% { transform: translateX(0); }
      20% { transform: translateX(-4px); }
      40% { transform: translateX(4px); }
      60% { transform: translateX(-3px); }
      80% { transform: translateX(3px); }
    }

    @keyframes criticalFlash {
      0%, 100% { background-color: transparent; }
      50% { background-color: rgba(255, 255, 255, 0.4); }
    }

    @keyframes hpPulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(252, 129, 129, 0); }
      50% { box-shadow: 0 0 8px 2px rgba(252, 129, 129, 0.6); }
    }

    @keyframes staminaWarning {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .screen-shake {
      animation: screenShake 0.2s ease-in-out;
    }

    .critical-flash {
      animation: criticalFlash 0.1s ease-in-out;
    }

    .hp-low {
      animation: hpPulse 1s ease-in-out infinite;
    }

    .stamina-warning {
      animation: staminaWarning 0.5s ease-in-out infinite;
    }

    /* Focus styles for accessibility */
    button:focus-visible,
    input:focus-visible {
      outline: 2px solid #f6e05e;
      outline-offset: 2px;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
  <script type="text/babel">
    // Inline the component for standalone HTML execution
    const { useState, useReducer, useEffect, useCallback, useRef } = React;

    // ============= MUSIC SYSTEM =============

    class MusicManager {
      constructor() {
        this.initialized = false;
        this.currentTrack = null;
        this.muted = false;
        this.masterGain = null;
        this.tracks = {};
        this.activeNodes = [];
      }

      async init() {
        if (this.initialized) return;
        await Tone.start();

        this.masterGain = new Tone.Gain(0.3).toDestination();

        // Create reverb for atmosphere
        this.reverb = new Tone.Reverb({ decay: 4, wet: 0.5 }).connect(this.masterGain);
        await this.reverb.generate();

        this.delay = new Tone.FeedbackDelay({ delayTime: '8n', feedback: 0.3, wet: 0.2 }).connect(this.reverb);

        this.initialized = true;
      }

      stopAllTracks() {
        this.activeNodes.forEach(node => {
          try {
            if (node.stop) node.stop();
            if (node.dispose) node.dispose();
          } catch (e) {}
        });
        this.activeNodes = [];
        Tone.Transport.stop();
        Tone.Transport.cancel();
      }

      async switchTrack(trackName) {
        if (!this.initialized) await this.init();
        if (this.currentTrack === trackName) return;

        this.stopAllTracks();
        this.currentTrack = trackName;

        if (this.muted) return;

        switch (trackName) {
          case 'exploration':
            this.playExploration();
            break;
          case 'bonfire':
            this.playBonfire();
            break;
          case 'battle':
            this.playBattle();
            break;
          case 'bossPhase2':
            this.playBossPhase2();
            break;
          case 'victory':
            this.playVictory();
            break;
          case 'gameOver':
            this.playGameOver();
            break;
        }
      }

      playExploration() {
        // Chiptune exploration - Lavender Town meets Firelink Shrine
        // Am - Em - F - G progression, 70 BPM, melancholic but musical

        // Lead melody - square wave, lonely and ancient
        const lead = new Tone.Synth({
          oscillator: { type: 'square', width: 0.5 },
          envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 0.2 }
        }).connect(new Tone.Gain(0.15).connect(this.masterGain));

        // Harmony - triangle wave for softer texture
        const harmony = new Tone.Synth({
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.01, decay: 0.1, sustain: 0.4, release: 0.3 }
        }).connect(new Tone.Gain(0.1).connect(this.masterGain));

        // Bass - triangle wave, arpeggiated
        const bass = new Tone.Synth({
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.01, decay: 0.15, sustain: 0.3, release: 0.1 }
        }).connect(new Tone.Gain(0.2).connect(this.masterGain));

        this.activeNodes.push(lead, harmony, bass);

        // Melancholic melody - 8 bar phrase that loops
        const melodyNotes = [
          // Bar 1-2 (Am)
          'E4', 'D4', 'C4', 'B3', 'A3', null, 'C4', 'E4',
          // Bar 3-4 (Em)
          'G4', 'E4', 'D4', 'B3', 'E4', null, 'G4', 'F#4',
          // Bar 5-6 (F)
          'A4', 'G4', 'F4', 'E4', 'F4', null, 'A4', 'C5',
          // Bar 7-8 (G -> Am)
          'B4', 'G4', 'D4', 'B3', 'C4', 'E4', 'A4', null
        ];

        const melodySeq = new Tone.Sequence((time, note) => {
          if (note) lead.triggerAttackRelease(note, '8n', time);
        }, melodyNotes, '8n');

        // Counter melody / harmony (plays on off-beats, lower)
        const harmonyNotes = [
          // Am
          null, 'A3', null, 'E3', null, 'C4', null, 'A3',
          // Em
          null, 'E3', null, 'B3', null, 'G3', null, 'E3',
          // F
          null, 'F3', null, 'C4', null, 'A3', null, 'F3',
          // G
          null, 'G3', null, 'D4', null, 'B3', null, null
        ];

        const harmonySeq = new Tone.Sequence((time, note) => {
          if (note) harmony.triggerAttackRelease(note, '8n', time);
        }, harmonyNotes, '8n');

        // Arpeggiated bass line
        const bassPattern = [
          // Am
          'A2', 'E2', 'A2', 'C3', 'A2', 'E2', 'A2', 'E2',
          // Em
          'E2', 'B2', 'E2', 'G2', 'E2', 'B2', 'E2', 'B2',
          // F
          'F2', 'C3', 'F2', 'A2', 'F2', 'C3', 'F2', 'C3',
          // G
          'G2', 'D3', 'G2', 'B2', 'G2', 'D3', 'E2', 'A2'
        ];

        const bassSeq = new Tone.Sequence((time, note) => {
          if (note) bass.triggerAttackRelease(note, '16n', time);
        }, bassPattern, '8n');

        this.activeNodes.push(melodySeq, harmonySeq, bassSeq);

        Tone.Transport.bpm.value = 70;
        melodySeq.start(0);
        harmonySeq.start(0);
        bassSeq.start(0);
        Tone.Transport.start();
      }

      playBonfire() {
        // Gentle rest theme - peaceful arpeggios, the safest place
        // Soft triangle waves, slower tempo, warm feeling

        const arp = new Tone.Synth({
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.02, decay: 0.3, sustain: 0.2, release: 0.5 }
        }).connect(new Tone.Gain(0.12).connect(this.delay));

        const pad = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.3, decay: 0.5, sustain: 0.4, release: 1 }
        }).connect(new Tone.Gain(0.08).connect(this.reverb));

        const bass = new Tone.Synth({
          oscillator: { type: 'sine' },
          envelope: { attack: 0.1, decay: 0.3, sustain: 0.5, release: 0.5 }
        }).connect(new Tone.Gain(0.15).connect(this.masterGain));

        this.activeNodes.push(arp, pad, bass);

        // Gentle ascending/descending arpeggios
        const arpNotes = [
          // Am (peaceful)
          'A3', 'C4', 'E4', 'A4', 'E4', 'C4', 'A3', 'E3',
          // F (warmth)
          'F3', 'A3', 'C4', 'F4', 'C4', 'A3', 'F3', 'C3',
          // C (hope)
          'C3', 'E3', 'G3', 'C4', 'G3', 'E3', 'C3', 'G2',
          // E (resolution to Am)
          'E3', 'G#3', 'B3', 'E4', 'B3', 'G#3', 'E3', 'B2'
        ];

        const arpSeq = new Tone.Sequence((time, note) => {
          if (note) arp.triggerAttackRelease(note, '4n', time);
        }, arpNotes, '8n');

        // Soft pad chords, one per measure
        const padChords = [
          ['A3', 'C4', 'E4'],
          ['F3', 'A3', 'C4'],
          ['C3', 'E3', 'G3'],
          ['E3', 'G#3', 'B3']
        ];
        let padIndex = 0;

        const padLoop = new Tone.Loop(time => {
          pad.triggerAttackRelease(padChords[padIndex % padChords.length], '1m', time);
          padIndex++;
        }, '1m');

        // Simple bass notes
        const bassNotes = ['A2', 'F2', 'C2', 'E2'];
        let bassIndex = 0;

        const bassLoop = new Tone.Loop(time => {
          bass.triggerAttackRelease(bassNotes[bassIndex % bassNotes.length], '2n', time);
          bassIndex++;
        }, '1m');

        this.activeNodes.push(arpSeq, padLoop, bassLoop);

        Tone.Transport.bpm.value = 55;
        arpSeq.start(0);
        padLoop.start(0);
        bassLoop.start(0);
        Tone.Transport.start();
      }

      playBattle() {
        // Tense battle theme - driving rhythm, minor key, stakes are high
        // Square wave lead, triangle bass, pulse wave rhythm

        const lead = new Tone.Synth({
          oscillator: { type: 'square', width: 0.25 },
          envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 0.1 }
        }).connect(new Tone.Gain(0.12).connect(this.masterGain));

        const bass = new Tone.Synth({
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.01, decay: 0.1, sustain: 0.4, release: 0.1 }
        }).connect(new Tone.Gain(0.2).connect(this.masterGain));

        const pulse = new Tone.Synth({
          oscillator: { type: 'pulse', width: 0.125 },
          envelope: { attack: 0.005, decay: 0.05, sustain: 0.1, release: 0.05 }
        }).connect(new Tone.Gain(0.1).connect(this.masterGain));

        // Noise for percussion
        const snare = new Tone.NoiseSynth({
          noise: { type: 'white' },
          envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 }
        }).connect(new Tone.Gain(0.08).connect(this.masterGain));

        this.activeNodes.push(lead, bass, pulse, snare);

        // Urgent, driving melody in C minor
        const melodyNotes = [
          // Phrase 1
          'C4', 'C4', 'Eb4', 'G4', 'F4', 'Eb4', 'D4', 'C4',
          'Bb3', 'C4', 'D4', 'Eb4', 'D4', 'C4', 'Bb3', 'G3',
          // Phrase 2 (higher tension)
          'G4', 'G4', 'Ab4', 'G4', 'F4', 'Eb4', 'F4', 'G4',
          'Ab4', 'G4', 'F4', 'Eb4', 'D4', 'C4', 'D4', 'Eb4'
        ];

        const melodySeq = new Tone.Sequence((time, note) => {
          if (note) lead.triggerAttackRelease(note, '16n', time);
        }, melodyNotes, '8n');

        // Driving bass pattern
        const bassNotes = [
          'C2', null, 'C2', 'C2', null, 'C2', 'G2', null,
          'Ab2', null, 'Ab2', 'Ab2', null, 'G2', 'F2', null,
          'Eb2', null, 'Eb2', 'Eb2', null, 'F2', 'G2', null,
          'Ab2', null, 'Bb2', null, 'G2', 'G2', 'G2', null
        ];

        const bassSeq = new Tone.Sequence((time, note) => {
          if (note) bass.triggerAttackRelease(note, '16n', time);
        }, bassNotes, '8n');

        // Rhythmic pulse on the beat
        const pulsePattern = [1, 0, 1, 0, 1, 0, 1, 0];
        const pulseSeq = new Tone.Sequence((time, hit) => {
          if (hit) pulse.triggerAttackRelease('C5', '32n', time);
        }, pulsePattern, '8n');

        // Snare on 2 and 4
        const snarePattern = [0, 0, 1, 0, 0, 0, 1, 0];
        const snareSeq = new Tone.Sequence((time, hit) => {
          if (hit) snare.triggerAttackRelease('16n', time);
        }, snarePattern, '8n');

        this.activeNodes.push(melodySeq, bassSeq, pulseSeq, snareSeq);

        Tone.Transport.bpm.value = 140;
        melodySeq.start(0);
        bassSeq.start(0);
        pulseSeq.start(0);
        snareSeq.start(0);
        Tone.Transport.start();
      }

      playBossPhase2() {
        // Desperate boss theme - faster, chromatic tension, the hound transforms
        // Still musical but with dissonant intervals and frantic energy

        const lead = new Tone.Synth({
          oscillator: { type: 'square', width: 0.5 },
          envelope: { attack: 0.005, decay: 0.1, sustain: 0.2, release: 0.1 }
        }).connect(new Tone.Gain(0.12).connect(this.masterGain));

        const lead2 = new Tone.Synth({
          oscillator: { type: 'sawtooth' },
          envelope: { attack: 0.005, decay: 0.1, sustain: 0.2, release: 0.1 }
        }).connect(new Tone.Gain(0.08).connect(this.masterGain));

        const bass = new Tone.Synth({
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.005, decay: 0.1, sustain: 0.4, release: 0.05 }
        }).connect(new Tone.Gain(0.22).connect(this.masterGain));

        const snare = new Tone.NoiseSynth({
          noise: { type: 'white' },
          envelope: { attack: 0.002, decay: 0.08, sustain: 0, release: 0.08 }
        }).connect(new Tone.Gain(0.1).connect(this.masterGain));

        this.activeNodes.push(lead, lead2, bass, snare);

        // Frantic chromatic melody with tritones
        const melodyNotes = [
          // Chromatic descent with tension
          'E5', 'Eb5', 'D5', 'Db5', 'C5', 'B4', 'Bb4', 'A4',
          'Ab4', 'G4', 'Gb4', 'F4', 'E4', 'Eb4', 'D4', 'Db4',
          // Rising panic
          'C4', 'D4', 'Eb4', 'F4', 'Gb4', 'G4', 'Ab4', 'A4',
          'Bb4', 'B4', 'C5', 'Db5', 'D5', 'Eb5', 'E5', 'F5'
        ];

        const melodySeq = new Tone.Sequence((time, note) => {
          if (note) lead.triggerAttackRelease(note, '16n', time);
        }, melodyNotes, '16n');

        // Harmony a tritone apart for dissonance
        const harmonyNotes = melodyNotes.map(note => {
          if (!note) return null;
          // Transpose down a tritone (6 semitones) for dissonance
          const noteMap = {'C': 'Gb', 'Db': 'G', 'D': 'Ab', 'Eb': 'A', 'E': 'Bb', 'F': 'B', 'Gb': 'C', 'G': 'Db', 'Ab': 'D', 'A': 'Eb', 'Bb': 'E', 'B': 'F'};
          const noteName = note.slice(0, -1);
          const octave = parseInt(note.slice(-1)) - 1;
          const base = noteName.replace('#', 'b');
          return (noteMap[base] || base) + octave;
        });

        const harmonySeq = new Tone.Sequence((time, note) => {
          if (note) lead2.triggerAttackRelease(note, '16n', time);
        }, harmonyNotes, '16n');

        // Pounding bass
        const bassNotes = [
          'C2', 'C2', 'C2', 'C2', 'Db2', 'Db2', 'D2', 'D2',
          'Eb2', 'Eb2', 'E2', 'E2', 'F2', 'F2', 'Gb2', 'G2',
          'Ab2', 'Ab2', 'A2', 'A2', 'Bb2', 'Bb2', 'B2', 'B2',
          'C3', 'B2', 'Bb2', 'A2', 'Ab2', 'G2', 'Gb2', 'F2'
        ];

        const bassSeq = new Tone.Sequence((time, note) => {
          if (note) bass.triggerAttackRelease(note, '16n', time);
        }, bassNotes, '16n');

        // Fast snare hits
        const snarePattern = [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1];
        const snareSeq = new Tone.Sequence((time, hit) => {
          if (hit) snare.triggerAttackRelease('32n', time);
        }, snarePattern, '16n');

        this.activeNodes.push(melodySeq, harmonySeq, bassSeq, snareSeq);

        Tone.Transport.bpm.value = 170;
        melodySeq.start(0);
        harmonySeq.start(0);
        bassSeq.start(0);
        snareSeq.start(0);
        Tone.Transport.start();
      }

      playVictory() {
        // Somber but triumphant - you survived, barely
        const lead = new Tone.Synth({
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.1, decay: 0.3, sustain: 0.4, release: 0.5 }
        }).connect(new Tone.Gain(0.15).connect(this.reverb));

        const bass = new Tone.Synth({
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.1, decay: 0.2, sustain: 0.5, release: 0.3 }
        }).connect(new Tone.Gain(0.12).connect(this.masterGain));

        this.activeNodes.push(lead, bass);

        // Simple ascending resolution melody
        const melodyNotes = [
          'A3', null, 'C4', null, 'E4', null, 'A4', null,
          'G4', null, 'E4', null, 'C4', null, 'E4', null,
          'F4', null, 'A4', null, 'C5', null, 'A4', null,
          'G4', null, 'B4', null, 'A4', null, null, null
        ];

        const melodySeq = new Tone.Sequence((time, note) => {
          if (note) lead.triggerAttackRelease(note, '4n', time);
        }, melodyNotes, '8n');

        const bassNotes = ['A2', 'A2', 'C3', 'C3', 'F2', 'F2', 'E2', 'A2'];
        const bassSeq = new Tone.Sequence((time, note) => {
          if (note) bass.triggerAttackRelease(note, '4n', time);
        }, bassNotes, '2n');

        this.activeNodes.push(melodySeq, bassSeq);

        Tone.Transport.bpm.value = 60;
        melodySeq.start(0);
        bassSeq.start(0);
        Tone.Transport.start();
      }

      playGameOver() {
        // YOU DIED - descending minor phrase
        const lead = new Tone.Synth({
          oscillator: { type: 'square', width: 0.5 },
          envelope: { attack: 0.1, decay: 0.5, sustain: 0.3, release: 1 }
        }).connect(new Tone.Gain(0.12).connect(this.reverb));

        const bass = new Tone.Synth({
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.2, decay: 0.5, sustain: 0.5, release: 1 }
        }).connect(new Tone.Gain(0.15).connect(this.masterGain));

        this.activeNodes.push(lead, bass);

        // Descending death melody
        const deathMelody = ['E4', 'D4', 'C4', 'B3', 'A3', null, null, null];
        const deathSeq = new Tone.Sequence((time, note) => {
          if (note) {
            lead.triggerAttackRelease(note, '2n', time);
            bass.triggerAttackRelease(Tone.Frequency(note).transpose(-12).toNote(), '2n', time);
          }
        }, deathMelody, '2n');

        this.activeNodes.push(deathSeq);

        Tone.Transport.bpm.value = 50;
        deathSeq.start(0);
        deathSeq.loop = false;
        Tone.Transport.start();
      }

      toggleMute() {
        this.muted = !this.muted;
        if (this.muted) {
          this.stopAllTracks();
        } else if (this.currentTrack) {
          const track = this.currentTrack;
          this.currentTrack = null;
          this.switchTrack(track);
        }
        return this.muted;
      }

      setMuted(muted) {
        if (this.muted !== muted) {
          this.toggleMute();
        }
      }
    }

    const musicManager = new MusicManager();

    // ============= SOUND EFFECTS SYSTEM =============
    class SfxManager {
      constructor() {
        this.initialized = false;
        this.muted = false;
        this.masterGain = null;
      }

      async init() {
        if (this.initialized) return;
        await Tone.start();
        this.masterGain = new Tone.Gain(0.4).toDestination();
        this.initialized = true;
      }

      setMuted(muted) {
        this.muted = muted;
      }

      async play(type, options = {}) {
        if (this.muted) return;
        if (!this.initialized) await this.init();

        switch (type) {
          case 'hitLight':
            this.playHitLight();
            break;
          case 'hitMedium':
            this.playHitMedium();
            break;
          case 'hitHeavy':
            this.playHitHeavy();
            break;
          case 'critical':
            this.playCritical();
            break;
          case 'faint':
            this.playFaint();
            break;
          case 'bindAttempt':
            this.playBindAttempt();
            break;
          case 'captureSuccess':
            this.playCaptureSuccess();
            break;
          case 'captureFail':
            this.playCaptureFail();
            break;
          case 'soulsGained':
            this.playSoulsGained();
            break;
          case 'menuClick':
            this.playMenuClick();
            break;
          case 'bonfireRest':
            this.playBonfireRest();
            break;
          case 'death':
            this.playDeath();
            break;
          case 'victory':
            this.playVictory();
            break;
          case 'poison':
            this.playPoison();
            break;
          case 'chill':
            this.playChill();
            break;
          case 'burn':
            this.playBurn();
            break;
        }
      }

      playHitLight() {
        const synth = new Tone.Synth({
          oscillator: { type: 'sine' },
          envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
        }).connect(this.masterGain);
        synth.triggerAttackRelease('C5', '16n');
        setTimeout(() => synth.dispose(), 200);
      }

      playHitMedium() {
        const synth = new Tone.Synth({
          oscillator: { type: 'square' },
          envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.1 }
        }).connect(this.masterGain);
        synth.triggerAttackRelease('G3', '8n');
        setTimeout(() => synth.dispose(), 300);
      }

      playHitHeavy() {
        const synth = new Tone.Synth({
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.001, decay: 0.2, sustain: 0.1, release: 0.2 }
        }).connect(this.masterGain);
        const noise = new Tone.NoiseSynth({
          noise: { type: 'brown' },
          envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.1 }
        }).connect(new Tone.Gain(0.3).connect(this.masterGain));
        synth.triggerAttackRelease('C2', '8n');
        noise.triggerAttackRelease('16n');
        setTimeout(() => { synth.dispose(); noise.dispose(); }, 400);
      }

      playCritical() {
        const synth = new Tone.Synth({
          oscillator: { type: 'square' },
          envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.1 }
        }).connect(this.masterGain);
        const now = Tone.now();
        synth.triggerAttackRelease('C5', '16n', now);
        synth.triggerAttackRelease('E5', '16n', now + 0.08);
        synth.triggerAttackRelease('G5', '16n', now + 0.16);
        setTimeout(() => synth.dispose(), 500);
      }

      playFaint() {
        const synth = new Tone.Synth({
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.01, decay: 0.3, sustain: 0.2, release: 0.5 }
        }).connect(this.masterGain);
        const now = Tone.now();
        synth.triggerAttackRelease('E4', '8n', now);
        synth.triggerAttackRelease('C4', '8n', now + 0.2);
        synth.triggerAttackRelease('A3', '4n', now + 0.4);
        setTimeout(() => synth.dispose(), 1200);
      }

      playBindAttempt() {
        const synth = new Tone.Synth({
          oscillator: { type: 'sine' },
          envelope: { attack: 0.1, decay: 0.3, sustain: 0.1, release: 0.3 }
        }).connect(this.masterGain);
        synth.frequency.rampTo('C6', 0.5);
        synth.triggerAttackRelease('C4', '4n');
        setTimeout(() => synth.dispose(), 800);
      }

      playCaptureSuccess() {
        const synth = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: 'square' },
          envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 0.2 }
        }).connect(this.masterGain);
        const now = Tone.now();
        synth.triggerAttackRelease(['C4', 'E4', 'G4'], '8n', now);
        synth.triggerAttackRelease(['C5', 'E5', 'G5'], '4n', now + 0.15);
        setTimeout(() => synth.dispose(), 800);
      }

      playCaptureFail() {
        const synth = new Tone.Synth({
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 }
        }).connect(this.masterGain);
        const noise = new Tone.NoiseSynth({
          noise: { type: 'white' },
          envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 }
        }).connect(new Tone.Gain(0.2).connect(this.masterGain));
        synth.triggerAttackRelease('Eb3', '8n');
        noise.triggerAttackRelease('16n');
        setTimeout(() => { synth.dispose(); noise.dispose(); }, 400);
      }

      playSoulsGained() {
        const synth = new Tone.Synth({
          oscillator: { type: 'sine' },
          envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
        }).connect(this.masterGain);
        const now = Tone.now();
        synth.triggerAttackRelease('E6', '32n', now);
        synth.triggerAttackRelease('G6', '32n', now + 0.05);
        setTimeout(() => synth.dispose(), 200);
      }

      playMenuClick() {
        const synth = new Tone.Synth({
          oscillator: { type: 'sine' },
          envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 }
        }).connect(new Tone.Gain(0.3).connect(this.masterGain));
        synth.triggerAttackRelease('A5', '64n');
        setTimeout(() => synth.dispose(), 100);
      }

      playBonfireRest() {
        const noise = new Tone.NoiseSynth({
          noise: { type: 'brown' },
          envelope: { attack: 0.3, decay: 0.5, sustain: 0.3, release: 0.5 }
        }).connect(new Tone.Filter(800, 'lowpass').connect(new Tone.Gain(0.15).connect(this.masterGain)));
        const synth = new Tone.Synth({
          oscillator: { type: 'sine' },
          envelope: { attack: 0.2, decay: 0.3, sustain: 0.4, release: 0.5 }
        }).connect(this.masterGain);
        noise.triggerAttackRelease('1n');
        synth.triggerAttackRelease('C4', '2n');
        setTimeout(() => { noise.dispose(); synth.dispose(); }, 2000);
      }

      playDeath() {
        const synth = new Tone.Synth({
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.1, decay: 0.5, sustain: 0.2, release: 1 }
        }).connect(this.masterGain);
        const now = Tone.now();
        synth.triggerAttackRelease('D4', '4n', now);
        synth.triggerAttackRelease('Bb3', '4n', now + 0.3);
        synth.triggerAttackRelease('G3', '4n', now + 0.6);
        synth.triggerAttackRelease('D3', '2n', now + 0.9);
        setTimeout(() => synth.dispose(), 2500);
      }

      playVictory() {
        const synth = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: 'square' },
          envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 0.2 }
        }).connect(this.masterGain);
        const now = Tone.now();
        synth.triggerAttackRelease(['C4', 'E4'], '8n', now);
        synth.triggerAttackRelease(['D4', 'F4'], '8n', now + 0.15);
        synth.triggerAttackRelease(['E4', 'G4'], '8n', now + 0.3);
        synth.triggerAttackRelease(['G4', 'C5', 'E5'], '4n', now + 0.45);
        setTimeout(() => synth.dispose(), 1200);
      }

      playPoison() {
        const synth = new Tone.Synth({
          oscillator: { type: 'sine' },
          envelope: { attack: 0.05, decay: 0.2, sustain: 0.1, release: 0.2 }
        }).connect(this.masterGain);
        const now = Tone.now();
        synth.triggerAttackRelease('G3', '16n', now);
        synth.triggerAttackRelease('Bb3', '16n', now + 0.08);
        synth.triggerAttackRelease('G3', '16n', now + 0.16);
        setTimeout(() => synth.dispose(), 400);
      }

      playChill() {
        const synth = new Tone.Synth({
          oscillator: { type: 'sine' },
          envelope: { attack: 0.1, decay: 0.3, sustain: 0.1, release: 0.3 }
        }).connect(this.masterGain);
        const now = Tone.now();
        synth.triggerAttackRelease('E5', '8n', now);
        synth.triggerAttackRelease('B4', '8n', now + 0.15);
        setTimeout(() => synth.dispose(), 500);
      }

      playBurn() {
        const noise = new Tone.NoiseSynth({
          noise: { type: 'pink' },
          envelope: { attack: 0.01, decay: 0.15, sustain: 0.05, release: 0.1 }
        }).connect(new Tone.Filter(2000, 'highpass').connect(new Tone.Gain(0.2).connect(this.masterGain)));
        const synth = new Tone.Synth({
          oscillator: { type: 'sawtooth' },
          envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 }
        }).connect(new Tone.Gain(0.3).connect(this.masterGain));
        noise.triggerAttackRelease('8n');
        synth.triggerAttackRelease('C4', '16n');
        setTimeout(() => { noise.dispose(); synth.dispose(); }, 300);
      }
    }

    const sfxManager = new SfxManager();

    // Helper function for playing sound effects
    const playSfx = (type, options) => sfxManager.play(type, options);

    // ============= GAME DATA =============

    const STARTERS = {
      cindrath: {
        id: 'cindrath',
        name: 'Cindrath',
        type: 'fire',
        maxHp: 45,
        maxStamina: 20,
        moves: [
          { name: 'Ember Slash', cost: 6, damage: 12, priority: false, effect: 'burn', effectChance: 20 },
          { name: 'Quick Strike', cost: 3, damage: 5, priority: true },
          { name: 'Guard', cost: 2, damage: 0, effect: 'guard' },
          { name: 'Rest', cost: 0, damage: 0, effect: 'rest' }
        ]
      },
      marshveil: {
        id: 'marshveil',
        name: 'Marshveil',
        type: 'water',
        maxHp: 50,
        maxStamina: 18,
        moves: [
          { name: 'Tide Crash', cost: 7, damage: 14, priority: false, effect: 'chill', effectChance: 20 },
          { name: 'Quick Strike', cost: 3, damage: 5, priority: true },
          { name: 'Guard', cost: 2, damage: 0, effect: 'guard' },
          { name: 'Rest', cost: 0, damage: 0, effect: 'rest' }
        ]
      },
      thornwick: {
        id: 'thornwick',
        name: 'Thornwick',
        type: 'grass',
        maxHp: 40,
        maxStamina: 24,
        moves: [
          { name: 'Vine Lash', cost: 5, damage: 10, priority: false, effect: 'poison', effectChance: 20 },
          { name: 'Quick Strike', cost: 3, damage: 5, priority: true },
          { name: 'Guard', cost: 2, damage: 0, effect: 'guard' },
          { name: 'Rest', cost: 0, damage: 0, effect: 'rest' }
        ]
      },
      umbravine: {
        id: 'umbravine',
        name: 'Umbravine',
        type: 'dark',
        maxHp: 42,
        maxStamina: 22,
        lore: 'Vines that grew in places the light forgot',
        moves: [
          { name: 'Shadow Lash', cost: 6, damage: 12, priority: false },
          { name: 'Void Drain', cost: 8, damage: 8, effect: 'drain', drainHp: 4, drainStamina: 4 },
          { name: 'Guard', cost: 2, damage: 0, effect: 'guard' },
          { name: 'Rest', cost: 0, damage: 0, effect: 'rest' }
        ]
      },
      solrath: {
        id: 'solrath',
        name: 'Solrath',
        type: 'light',
        maxHp: 48,
        maxStamina: 18,
        lore: 'Ember of the last dawn, before the ash',
        moves: [
          { name: 'Radiant Burst', cost: 5, damage: 11, priority: false },
          { name: 'Purifying Light', cost: 7, damage: 0, effect: 'purify', healAmount: 10 },
          { name: 'Guard', cost: 2, damage: 0, effect: 'guard' },
          { name: 'Rest', cost: 0, damage: 0, effect: 'rest' }
        ]
      }
    };

    const WILD_CREATURES = {
      wildCindrath: {
        id: 'wildCindrath',
        name: 'Wild Cindrath',
        type: 'fire',
        maxHp: 30,
        maxStamina: 15,
        souls: 12,
        moves: [
          { name: 'Ember Slash', cost: 6, damage: 9, priority: false },
          { name: 'Quick Strike', cost: 3, damage: 4, priority: true },
          { name: 'Rest', cost: 0, damage: 0, effect: 'rest' }
        ]
      },
      wildMarshveil: {
        id: 'wildMarshveil',
        name: 'Wild Marshveil',
        type: 'water',
        maxHp: 30,
        maxStamina: 15,
        souls: 12,
        moves: [
          { name: 'Tide Crash', cost: 7, damage: 10, priority: false },
          { name: 'Quick Strike', cost: 3, damage: 4, priority: true },
          { name: 'Rest', cost: 0, damage: 0, effect: 'rest' }
        ]
      },
      wildThornwick: {
        id: 'wildThornwick',
        name: 'Wild Thornwick',
        type: 'grass',
        maxHp: 30,
        maxStamina: 15,
        souls: 12,
        moves: [
          { name: 'Vine Lash', cost: 5, damage: 8, priority: false },
          { name: 'Quick Strike', cost: 3, damage: 4, priority: true },
          { name: 'Rest', cost: 0, damage: 0, effect: 'rest' }
        ]
      },
      wildUmbravine: {
        id: 'wildUmbravine',
        name: 'Wild Umbravine',
        type: 'dark',
        maxHp: 35,
        maxStamina: 18,
        souls: 18,
        moves: [
          { name: 'Shadow Lash', cost: 6, damage: 10, priority: false },
          { name: 'Quick Strike', cost: 3, damage: 4, priority: true },
          { name: 'Rest', cost: 0, damage: 0, effect: 'rest' }
        ]
      },
      wildSolrath: {
        id: 'wildSolrath',
        name: 'Wild Solrath',
        type: 'light',
        maxHp: 38,
        maxStamina: 16,
        souls: 20,
        moves: [
          { name: 'Radiant Burst', cost: 5, damage: 9, priority: false },
          { name: 'Quick Strike', cost: 3, damage: 4, priority: true },
          { name: 'Rest', cost: 0, damage: 0, effect: 'rest' }
        ]
      }
    };

    const BOSS = {
      obsidianHound: {
        id: 'obsidianHound',
        name: 'Obsidian Hound',
        type: 'fire',
        maxHp: 60,
        maxStamina: 22,
        souls: 100,
        moves: [
          { name: 'Ember Slash', cost: 6, damage: 12, priority: false },
          { name: 'Flame Wall', cost: 8, damage: 10, effect: 'burn' },
          { name: 'Guard', cost: 2, damage: 0, effect: 'guard' }
        ],
        phase2Moves: [
          { name: 'Ember Slash', cost: 6, damage: 12, priority: false },
          { name: 'Flame Wall', cost: 8, damage: 10, effect: 'burn' },
          { name: 'Desperation Fang', cost: 10, damage: 20, effect: 'recoil', recoilDamage: 5 },
          { name: 'Guard', cost: 2, damage: 0, effect: 'guard' }
        ]
      },
      hollowWarden: {
        id: 'hollowWarden',
        name: 'Hollow Warden',
        type: 'dark', // Phase 1: Dark type
        maxHp: 70,
        maxStamina: 24,
        souls: 200,
        moves: [
          { name: 'Shadow Lash', cost: 6, damage: 12, priority: false },
          { name: 'Void Grasp', cost: 5, damage: 8, effect: 'drainStamina', drainAmount: 4 },
          { name: 'Guard', cost: 2, damage: 0, effect: 'guard' }
        ],
        phase2Moves: [
          { name: 'Shattered Light', cost: 7, damage: 14, priority: false }, // Super effective vs Fire and Grass
          { name: 'Desperate Void', cost: 8, damage: 18, effect: 'recoil', recoilDamage: 6 },
          { name: 'Void Grasp', cost: 5, damage: 8, effect: 'drainStamina', drainAmount: 4 },
          { name: 'Guard', cost: 2, damage: 0, effect: 'guard' }
        ],
        phase2Type: 'darklight' // Dual type in phase 2
      }
    };

    const TYPE_CHART = {
      fire: { fire: 1.0, water: 0.5, grass: 1.5, dark: 1.0, light: 0.5, darklight: 0.75 },
      water: { fire: 1.5, water: 1.0, grass: 0.5, dark: 1.0, light: 1.0, darklight: 1.0 },
      grass: { fire: 0.5, water: 1.5, grass: 1.0, dark: 0.5, light: 1.0, darklight: 0.75 },
      dark: { fire: 1.0, water: 1.0, grass: 1.5, dark: 1.0, light: 1.5, darklight: 1.25 },
      light: { fire: 1.5, water: 1.0, grass: 1.0, dark: 0.5, light: 1.0, darklight: 1.25 }
    };

    const SCAR_TYPES = [
      { id: 'fractured', name: 'Fractured', effect: 'maxHp', value: -5, description: '-5 max HP' },
      { id: 'hesitant', name: 'Hesitant', effect: 'maxStamina', value: -2, description: '-2 max Stamina' },
      { id: 'flinching', name: 'Flinching', effect: 'noPriority', description: 'Quick Strike no longer goes first' }
    ];

    const ASHEN_PATH = [
      ['W', 'W', 'W', 'W', 'W', 'W', 'W', 'W'],
      ['W', 'B', 'P', 'G', 'G', 'P', 'P', 'W'],
      ['W', 'P', 'W', 'W', 'G', 'W', 'P', 'W'],
      ['W', 'P', 'P', 'P', 'P', 'P', 'G', 'W'],
      ['W', 'W', 'W', 'W', 'P', 'W', 'P', 'W'],
      ['W', 'W', 'W', 'W', 'X', 'W', 'W', 'W']
    ];

    const FALLEN_KEEP = [
      ['W', 'W', 'W', 'W', 'W', 'W'],
      ['W', 'P', 'P', 'P', 'P', 'W'],
      ['W', 'P', 'W', 'W', 'P', 'W'],
      ['W', 'P', 'W', 'P', 'P', 'W'],
      ['W', 'P', 'P', 'P', 'W', 'W'],
      ['W', 'W', 'W', 'P', 'W', 'W'],
      ['W', 'K', 'P', 'P', 'P', 'W'],
      ['W', 'W', 'E', 'W', 'W', 'W']
    ];

    // The Hollow Deep - Post-game dungeon (unlocks after Keeper Varek)
    // E = Entrance (from Fallen Keep), G = Grass (Dark/Light encounters)
    // B = Bonfire, K = Boss room (Hollow Warden), P = Path, W = Wall
    const HOLLOW_DEEP = [
      ['W', 'W', 'W', 'W', 'W', 'W', 'W', 'W'],
      ['W', 'P', 'P', 'P', 'G', 'P', 'P', 'W'],
      ['W', 'P', 'W', 'W', 'W', 'W', 'P', 'W'],
      ['W', 'P', 'W', 'B', 'W', 'P', 'P', 'W'],
      ['W', 'P', 'P', 'P', 'P', 'W', 'G', 'W'],
      ['W', 'W', 'W', 'P', 'W', 'W', 'P', 'W'],
      ['W', 'K', 'P', 'P', 'P', 'P', 'P', 'W'],
      ['W', 'W', 'W', 'E', 'W', 'W', 'W', 'W']
    ];

    // ============= GBC COLOR PALETTE =============
    const GBC = {
      bg: '#0f0f1a',
      bgLight: '#1a1a2e',
      bgPanel: '#16213e',
      border: '#4a5568',
      borderLight: '#718096',
      text: '#e8e8e8',
      textDim: '#a0aec0',
      gold: '#f6e05e',
      red: '#fc8181',
      green: '#68d391',
      blue: '#63b3ed',
      fire: '#f6ad55',
      water: '#4299e1',
      grass: '#48bb78',
      dark: '#9f7aea',
      light: '#faf089',
      // Tile colors
      wallDark: '#1a1a2e',
      wallMid: '#2d3748',
      wallLight: '#4a5568',
      pathDark: '#744210',
      pathMid: '#975a16',
      pathLight: '#b7791f',
      grassDark: '#276749',
      grassMid: '#38a169',
      grassLight: '#48bb78',
    };

    // ============= PIXEL ART SPRITES (CSS) =============

    // Player sprite facing different directions (16x16 scaled up)
    const PlayerSprite = ({ direction = 'down' }) => {
      const px = 3; // pixel size (3 = 48px total)

      // Base colors
      const skin = '#f6d5a8';
      const hair = '#4a3728';
      const shirt = '#c53030';
      const pants = '#2d3748';
      const outline = '#1a1a2e';

      const sprites = {
        down: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Hair */}
            <rect x={5*px} y={1*px} width={6*px} height={3*px} fill={hair}/>
            <rect x={4*px} y={2*px} width={1*px} height={2*px} fill={hair}/>
            <rect x={11*px} y={2*px} width={1*px} height={2*px} fill={hair}/>
            {/* Face */}
            <rect x={5*px} y={4*px} width={6*px} height={4*px} fill={skin}/>
            {/* Eyes */}
            <rect x={6*px} y={5*px} width={1*px} height={2*px} fill={outline}/>
            <rect x={9*px} y={5*px} width={1*px} height={2*px} fill={outline}/>
            {/* Body/Shirt */}
            <rect x={4*px} y={8*px} width={8*px} height={4*px} fill={shirt}/>
            <rect x={3*px} y={8*px} width={1*px} height={3*px} fill={shirt}/>
            <rect x={12*px} y={8*px} width={1*px} height={3*px} fill={shirt}/>
            {/* Pants */}
            <rect x={5*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={9*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            {/* Feet */}
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={hair}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={hair}/>
          </svg>
        ),
        up: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Hair (back view) */}
            <rect x={5*px} y={1*px} width={6*px} height={4*px} fill={hair}/>
            <rect x={4*px} y={2*px} width={1*px} height={3*px} fill={hair}/>
            <rect x={11*px} y={2*px} width={1*px} height={3*px} fill={hair}/>
            {/* Neck */}
            <rect x={6*px} y={5*px} width={4*px} height={3*px} fill={skin}/>
            {/* Body/Shirt */}
            <rect x={4*px} y={8*px} width={8*px} height={4*px} fill={shirt}/>
            <rect x={3*px} y={8*px} width={1*px} height={3*px} fill={shirt}/>
            <rect x={12*px} y={8*px} width={1*px} height={3*px} fill={shirt}/>
            {/* Pants */}
            <rect x={5*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={9*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            {/* Feet */}
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={hair}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={hair}/>
          </svg>
        ),
        left: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Hair */}
            <rect x={6*px} y={1*px} width={5*px} height={3*px} fill={hair}/>
            <rect x={5*px} y={2*px} width={1*px} height={3*px} fill={hair}/>
            {/* Face */}
            <rect x={6*px} y={4*px} width={4*px} height={4*px} fill={skin}/>
            {/* Eye */}
            <rect x={6*px} y={5*px} width={1*px} height={2*px} fill={outline}/>
            {/* Body */}
            <rect x={5*px} y={8*px} width={6*px} height={4*px} fill={shirt}/>
            <rect x={4*px} y={9*px} width={1*px} height={2*px} fill={skin}/>
            {/* Pants */}
            <rect x={6*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={9*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={6*px} y={15*px} width={2*px} height={1*px} fill={hair}/>
            <rect x={9*px} y={15*px} width={2*px} height={1*px} fill={hair}/>
          </svg>
        ),
        right: (
          <svg width={16*px} height={16*px} style={{ imageRendering: 'pixelated' }}>
            {/* Hair */}
            <rect x={5*px} y={1*px} width={5*px} height={3*px} fill={hair}/>
            <rect x={10*px} y={2*px} width={1*px} height={3*px} fill={hair}/>
            {/* Face */}
            <rect x={6*px} y={4*px} width={4*px} height={4*px} fill={skin}/>
            {/* Eye */}
            <rect x={9*px} y={5*px} width={1*px} height={2*px} fill={outline}/>
            {/* Body */}
            <rect x={5*px} y={8*px} width={6*px} height={4*px} fill={shirt}/>
            <rect x={11*px} y={9*px} width={1*px} height={2*px} fill={skin}/>
            {/* Pants */}
            <rect x={5*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={8*px} y={12*px} width={2*px} height={3*px} fill={pants}/>
            <rect x={5*px} y={15*px} width={2*px} height={1*px} fill={hair}/>
            <rect x={8*px} y={15*px} width={2*px} height={1*px} fill={hair}/>
          </svg>
        )
      };

      return sprites[direction] || sprites.down;
    };

    // Creature sprites
    const CreatureSprite = ({ type, size = 48, isEnemy = false }) => {
      const px = size / 16;

      const sprites = {
        fire: ( // Cindrath - flame creature
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body */}
            <rect x={4*px} y={8*px} width={8*px} height={6*px} fill="#c53030"/>
            <rect x={5*px} y={7*px} width={6*px} height={1*px} fill="#c53030"/>
            {/* Inner glow */}
            <rect x={5*px} y={9*px} width={6*px} height={4*px} fill="#ed8936"/>
            <rect x={6*px} y={10*px} width={4*px} height={2*px} fill="#f6e05e"/>
            {/* Eyes */}
            <rect x={5*px} y={9*px} width={2*px} height={2*px} fill="#1a1a2e"/>
            <rect x={9*px} y={9*px} width={2*px} height={2*px} fill="#1a1a2e"/>
            {/* Flames on head */}
            <rect x={6*px} y={4*px} width={1*px} height={3*px} fill="#ed8936"/>
            <rect x={8*px} y={3*px} width={1*px} height={4*px} fill="#f6ad55"/>
            <rect x={9*px} y={5*px} width={1*px} height={2*px} fill="#ed8936"/>
            <rect x={7*px} y={2*px} width={2*px} height={2*px} fill="#f6e05e"/>
            {/* Feet */}
            <rect x={4*px} y={14*px} width={2*px} height={2*px} fill="#742a2a"/>
            <rect x={10*px} y={14*px} width={2*px} height={2*px} fill="#742a2a"/>
          </svg>
        ),
        water: ( // Marshveil - water creature
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body - rounded blob */}
            <rect x={3*px} y={6*px} width={10*px} height={8*px} fill="#2b6cb0"/>
            <rect x={4*px} y={5*px} width={8*px} height={1*px} fill="#2b6cb0"/>
            <rect x={4*px} y={14*px} width={8*px} height={1*px} fill="#2b6cb0"/>
            {/* Inner shine */}
            <rect x={4*px} y={7*px} width={8*px} height={6*px} fill="#4299e1"/>
            <rect x={5*px} y={8*px} width={4*px} height={3*px} fill="#63b3ed"/>
            {/* Eyes */}
            <rect x={5*px} y={8*px} width={2*px} height={3*px} fill="#1a1a2e"/>
            <rect x={9*px} y={8*px} width={2*px} height={3*px} fill="#1a1a2e"/>
            <rect x={5*px} y={8*px} width={1*px} height={1*px} fill="#e8e8e8"/>
            <rect x={9*px} y={8*px} width={1*px} height={1*px} fill="#e8e8e8"/>
            {/* Fins/frills */}
            <rect x={1*px} y={8*px} width={2*px} height={4*px} fill="#4299e1"/>
            <rect x={13*px} y={8*px} width={2*px} height={4*px} fill="#4299e1"/>
            {/* Water drops */}
            <rect x={7*px} y={3*px} width={2*px} height={2*px} fill="#90cdf4"/>
          </svg>
        ),
        grass: ( // Thornwick - plant creature
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body */}
            <rect x={4*px} y={8*px} width={8*px} height={6*px} fill="#276749"/>
            <rect x={5*px} y={7*px} width={6*px} height={1*px} fill="#276749"/>
            {/* Inner */}
            <rect x={5*px} y={9*px} width={6*px} height={4*px} fill="#38a169"/>
            {/* Eyes */}
            <rect x={5*px} y={9*px} width={2*px} height={2*px} fill="#c53030"/>
            <rect x={9*px} y={9*px} width={2*px} height={2*px} fill="#c53030"/>
            {/* Leaves/thorns on top */}
            <rect x={5*px} y={4*px} width={2*px} height={3*px} fill="#48bb78"/>
            <rect x={7*px} y={2*px} width={2*px} height={5*px} fill="#68d391"/>
            <rect x={9*px} y={4*px} width={2*px} height={3*px} fill="#48bb78"/>
            {/* Thorns */}
            <rect x={3*px} y={10*px} width={1*px} height={2*px} fill="#68d391"/>
            <rect x={12*px} y={10*px} width={1*px} height={2*px} fill="#68d391"/>
            {/* Roots/feet */}
            <rect x={4*px} y={14*px} width={2*px} height={2*px} fill="#1c4532"/>
            <rect x={10*px} y={14*px} width={2*px} height={2*px} fill="#1c4532"/>
          </svg>
        ),
        boss: ( // Obsidian Hound
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body */}
            <rect x={2*px} y={8*px} width={12*px} height={5*px} fill="#1a1a2e"/>
            <rect x={3*px} y={7*px} width={10*px} height={1*px} fill="#1a1a2e"/>
            {/* Head */}
            <rect x={10*px} y={4*px} width={5*px} height={5*px} fill="#2d3748"/>
            <rect x={11*px} y={3*px} width={3*px} height={1*px} fill="#2d3748"/>
            {/* Ears */}
            <rect x={11*px} y={1*px} width={1*px} height={2*px} fill="#2d3748"/>
            <rect x={14*px} y={1*px} width={1*px} height={2*px} fill="#2d3748"/>
            {/* Eyes - glowing */}
            <rect x={11*px} y={5*px} width={2*px} height={2*px} fill="#f56565"/>
            <rect x={12*px} y={5*px} width={1*px} height={1*px} fill="#feb2b2"/>
            {/* Snout */}
            <rect x={14*px} y={6*px} width={2*px} height={2*px} fill="#4a5568"/>
            {/* Legs */}
            <rect x={3*px} y={13*px} width={2*px} height={3*px} fill="#1a1a2e"/>
            <rect x={6*px} y={13*px} width={2*px} height={3*px} fill="#1a1a2e"/>
            <rect x={9*px} y={13*px} width={2*px} height={3*px} fill="#1a1a2e"/>
            <rect x={12*px} y={13*px} width={2*px} height={3*px} fill="#1a1a2e"/>
            {/* Fire markings */}
            <rect x={4*px} y={9*px} width={1*px} height={2*px} fill="#ed8936"/>
            <rect x={7*px} y={8*px} width={1*px} height={3*px} fill="#f6ad55"/>
            {/* Tail */}
            <rect x={0*px} y={7*px} width={2*px} height={2*px} fill="#2d3748"/>
          </svg>
        ),
        dark: ( // Umbravine - dark vine creature
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body */}
            <rect x={4*px} y={8*px} width={8*px} height={6*px} fill="#2d2040"/>
            <rect x={5*px} y={7*px} width={6*px} height={1*px} fill="#2d2040"/>
            {/* Inner glow */}
            <rect x={5*px} y={9*px} width={6*px} height={4*px} fill="#4a3060"/>
            {/* Eyes - glowing violet */}
            <rect x={5*px} y={9*px} width={2*px} height={2*px} fill="#9f7aea"/>
            <rect x={9*px} y={9*px} width={2*px} height={2*px} fill="#9f7aea"/>
            <rect x={6*px} y={9*px} width={1*px} height={1*px} fill="#e9d8fd"/>
            <rect x={10*px} y={9*px} width={1*px} height={1*px} fill="#e9d8fd"/>
            {/* Vine tendrils */}
            <rect x={3*px} y={5*px} width={1*px} height={4*px} fill="#553c9a"/>
            <rect x={2*px} y={4*px} width={1*px} height={2*px} fill="#553c9a"/>
            <rect x={12*px} y={5*px} width={1*px} height={4*px} fill="#553c9a"/>
            <rect x={13*px} y={4*px} width={1*px} height={2*px} fill="#553c9a"/>
            {/* Top vines */}
            <rect x={6*px} y={3*px} width={1*px} height={4*px} fill="#6b46c1"/>
            <rect x={9*px} y={4*px} width={1*px} height={3*px} fill="#6b46c1"/>
            <rect x={7*px} y={2*px} width={2*px} height={2*px} fill="#805ad5"/>
            {/* Roots/feet */}
            <rect x={4*px} y={14*px} width={2*px} height={2*px} fill="#1a1030"/>
            <rect x={10*px} y={14*px} width={2*px} height={2*px} fill="#1a1030"/>
          </svg>
        ),
        light: ( // Solrath - light creature
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body */}
            <rect x={4*px} y={8*px} width={8*px} height={6*px} fill="#d69e2e"/>
            <rect x={5*px} y={7*px} width={6*px} height={1*px} fill="#d69e2e"/>
            {/* Inner glow */}
            <rect x={5*px} y={9*px} width={6*px} height={4*px} fill="#ecc94b"/>
            <rect x={6*px} y={10*px} width={4*px} height={2*px} fill="#faf089"/>
            {/* Eyes */}
            <rect x={5*px} y={9*px} width={2*px} height={2*px} fill="#1a1a2e"/>
            <rect x={9*px} y={9*px} width={2*px} height={2*px} fill="#1a1a2e"/>
            {/* Radiating light rays */}
            <rect x={7*px} y={1*px} width={2*px} height={5*px} fill="#faf089"/>
            <rect x={2*px} y={6*px} width={3*px} height={2*px} fill="#f6e05e"/>
            <rect x={11*px} y={6*px} width={3*px} height={2*px} fill="#f6e05e"/>
            <rect x={3*px} y={3*px} width={2*px} height={2*px} fill="#f6e05e"/>
            <rect x={11*px} y={3*px} width={2*px} height={2*px} fill="#f6e05e"/>
            {/* Warm glow halo */}
            <rect x={6*px} y={3*px} width={4*px} height={1*px} fill="#fefcbf"/>
            {/* Feet */}
            <rect x={4*px} y={14*px} width={2*px} height={2*px} fill="#b7791f"/>
            <rect x={10*px} y={14*px} width={2*px} height={2*px} fill="#b7791f"/>
          </svg>
        ),
        hollowWarden: ( // Hollow Warden - corrupted dark/light hybrid
          <svg width={size} height={size} style={{ imageRendering: 'pixelated' }}>
            {/* Body - fractured */}
            <rect x={2*px} y={7*px} width={12*px} height={7*px} fill="#1a1020"/>
            <rect x={3*px} y={6*px} width={10*px} height={1*px} fill="#1a1020"/>
            {/* Corruption cracks */}
            <rect x={4*px} y={8*px} width={1*px} height={4*px} fill="#553c9a"/>
            <rect x={8*px} y={7*px} width={1*px} height={5*px} fill="#9f7aea"/>
            <rect x={11*px} y={9*px} width={1*px} height={3*px} fill="#553c9a"/>
            {/* Head */}
            <rect x={5*px} y={2*px} width={6*px} height={5*px} fill="#2d2040"/>
            {/* Eyes - one dark, one light */}
            <rect x={6*px} y={4*px} width={2*px} height={2*px} fill="#9f7aea"/>
            <rect x={10*px} y={4*px} width={2*px} height={2*px} fill="#faf089"/>
            {/* Crown of fractured light */}
            <rect x={6*px} y={0*px} width={1*px} height={2*px} fill="#f6e05e"/>
            <rect x={8*px} y={0*px} width={1*px} height={3*px} fill="#faf089"/>
            <rect x={10*px} y={1*px} width={1*px} height={2*px} fill="#f6e05e"/>
            {/* Arms/appendages */}
            <rect x={0*px} y={9*px} width={2*px} height={3*px} fill="#2d2040"/>
            <rect x={14*px} y={9*px} width={2*px} height={3*px} fill="#2d2040"/>
            {/* Legs */}
            <rect x={4*px} y={14*px} width={2*px} height={2*px} fill="#1a1020"/>
            <rect x={10*px} y={14*px} width={2*px} height={2*px} fill="#1a1020"/>
          </svg>
        )
      };

      return sprites[type] || sprites.fire;
    };

    // Tile components
    const GrassTile = () => (
      <div style={{
        width: '100%',
        height: '100%',
        backgroundColor: GBC.grassDark,
        position: 'relative',
        overflow: 'hidden'
      }}>
        {/* Grass blades pattern */}
        <svg width="56" height="56" style={{ position: 'absolute', top: 0, left: 0 }}>
          <rect x="6" y="16" width="3" height="12" fill={GBC.grassMid}/>
          <rect x="6" y="13" width="3" height="3" fill={GBC.grassLight}/>
          <rect x="16" y="20" width="3" height="14" fill={GBC.grassMid}/>
          <rect x="16" y="17" width="3" height="3" fill={GBC.grassLight}/>
          <rect x="28" y="14" width="3" height="16" fill={GBC.grassMid}/>
          <rect x="28" y="11" width="3" height="3" fill={GBC.grassLight}/>
          <rect x="40" y="18" width="3" height="12" fill={GBC.grassMid}/>
          <rect x="40" y="15" width="3" height="3" fill={GBC.grassLight}/>
          <rect x="50" y="16" width="3" height="14" fill={GBC.grassMid}/>
          <rect x="50" y="13" width="3" height="3" fill={GBC.grassLight}/>
          <rect x="11" y="34" width="3" height="12" fill={GBC.grassMid}/>
          <rect x="22" y="38" width="3" height="12" fill={GBC.grassMid}/>
          <rect x="34" y="32" width="3" height="14" fill={GBC.grassMid}/>
          <rect x="45" y="36" width="3" height="14" fill={GBC.grassMid}/>
        </svg>
      </div>
    );

    const PathTile = () => (
      <div style={{
        width: '100%',
        height: '100%',
        backgroundColor: GBC.pathMid,
        position: 'relative'
      }}>
        <svg width="56" height="56" style={{ position: 'absolute', top: 0, left: 0 }}>
          {/* Stone/dirt texture */}
          <rect x="3" y="5" width="12" height="6" fill={GBC.pathLight}/>
          <rect x="22" y="3" width="14" height="8" fill={GBC.pathDark}/>
          <rect x="44" y="8" width="9" height="6" fill={GBC.pathLight}/>
          <rect x="8" y="22" width="16" height="7" fill={GBC.pathDark}/>
          <rect x="34" y="20" width="12" height="8" fill={GBC.pathLight}/>
          <rect x="5" y="40" width="9" height="6" fill={GBC.pathLight}/>
          <rect x="20" y="42" width="14" height="6" fill={GBC.pathDark}/>
          <rect x="42" y="38" width="11" height="8" fill={GBC.pathDark}/>
        </svg>
      </div>
    );

    const WallTile = () => (
      <div style={{
        width: '100%',
        height: '100%',
        backgroundColor: GBC.wallDark,
        position: 'relative'
      }}>
        <svg width="56" height="56" style={{ position: 'absolute', top: 0, left: 0 }}>
          {/* Brick pattern */}
          <rect x="0" y="0" width="26" height="13" fill={GBC.wallMid} stroke={GBC.wallDark} strokeWidth="1"/>
          <rect x="28" y="0" width="28" height="13" fill={GBC.wallMid} stroke={GBC.wallDark} strokeWidth="1"/>
          <rect x="0" y="14" width="14" height="13" fill={GBC.wallLight} stroke={GBC.wallDark} strokeWidth="1"/>
          <rect x="16" y="14" width="26" height="13" fill={GBC.wallMid} stroke={GBC.wallDark} strokeWidth="1"/>
          <rect x="44" y="14" width="12" height="13" fill={GBC.wallLight} stroke={GBC.wallDark} strokeWidth="1"/>
          <rect x="0" y="28" width="22" height="13" fill={GBC.wallMid} stroke={GBC.wallDark} strokeWidth="1"/>
          <rect x="24" y="28" width="32" height="13" fill={GBC.wallLight} stroke={GBC.wallDark} strokeWidth="1"/>
          <rect x="0" y="42" width="12" height="14" fill={GBC.wallLight} stroke={GBC.wallDark} strokeWidth="1"/>
          <rect x="14" y="42" width="26" height="14" fill={GBC.wallMid} stroke={GBC.wallDark} strokeWidth="1"/>
          <rect x="42" y="42" width="14" height="14" fill={GBC.wallMid} stroke={GBC.wallDark} strokeWidth="1"/>
        </svg>
      </div>
    );

    const BonfireTile = () => (
      <div style={{
        width: '100%',
        height: '100%',
        backgroundColor: GBC.pathDark,
        position: 'relative',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }}>
        {/* Fire base */}
        <div style={{
          position: 'absolute',
          bottom: '6px',
          width: '32px',
          height: '10px',
          backgroundColor: '#4a3728',
          borderRadius: '2px'
        }}/>
        {/* Animated flames */}
        <svg width="44" height="44" style={{ animation: 'flicker 0.5s infinite', position: 'relative', zIndex: 1 }}>
          {/* Outer flame */}
          <rect x="10" y="22" width="24" height="16" fill="#ed8936"/>
          <rect x="13" y="16" width="18" height="8" fill="#f6ad55"/>
          <rect x="16" y="10" width="12" height="8" fill="#f6e05e"/>
          <rect x="19" y="4" width="6" height="8" fill="#faf089"/>
          {/* Inner bright core */}
          <rect x="16" y="26" width="12" height="8" fill="#faf089"/>
          <rect x="19" y="20" width="6" height="8" fill="#fffff0"/>
        </svg>
        {/* Embers */}
        <div style={{
          position: 'absolute',
          top: '10px',
          left: '16px',
          width: '5px',
          height: '5px',
          backgroundColor: '#f6e05e',
          animation: 'ember 1s infinite',
          animationDelay: '0s'
        }}/>
        <div style={{
          position: 'absolute',
          top: '12px',
          right: '18px',
          width: '4px',
          height: '4px',
          backgroundColor: '#ed8936',
          animation: 'ember 1.2s infinite',
          animationDelay: '0.3s'
        }}/>
      </div>
    );

    const GateTile = ({ isKeep = false }) => (
      <div style={{
        width: '100%',
        height: '100%',
        backgroundColor: isKeep ? GBC.wallMid : GBC.pathMid,
        position: 'relative',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }}>
        <svg width="50" height="50" style={{ imageRendering: 'pixelated' }}>
          {/* Torii gate / dungeon entrance */}
          {/* Pillars */}
          <rect x="6" y="12" width="6" height="38" fill="#742a2a"/>
          <rect x="38" y="12" width="6" height="38" fill="#742a2a"/>
          {/* Top beam */}
          <rect x="3" y="6" width="44" height="6" fill="#9b2c2c"/>
          <rect x="0" y="3" width="50" height="5" fill="#c53030"/>
          {/* Cross beam */}
          <rect x="6" y="16" width="38" height="4" fill="#742a2a"/>
          {/* Entrance darkness */}
          <rect x="14" y="22" width="22" height="28" fill="#0f0f1a"/>
        </svg>
      </div>
    );

    const BossRoomTile = () => (
      <div style={{
        width: '100%',
        height: '100%',
        backgroundColor: '#1a0a0a',
        position: 'relative',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }}>
        <svg width="50" height="50" style={{ imageRendering: 'pixelated' }}>
          {/* Skull */}
          <rect x="13" y="10" width="24" height="20" fill="#e8e8e8"/>
          <rect x="10" y="13" width="3" height="14" fill="#e8e8e8"/>
          <rect x="37" y="13" width="3" height="14" fill="#e8e8e8"/>
          {/* Eye sockets */}
          <rect x="16" y="16" width="6" height="7" fill="#1a0a0a"/>
          <rect x="28" y="16" width="6" height="7" fill="#1a0a0a"/>
          {/* Red glow in eyes */}
          <rect x="18" y="18" width="3" height="3" fill="#c53030"/>
          <rect x="30" y="18" width="3" height="3" fill="#c53030"/>
          {/* Nose */}
          <rect x="22" y="25" width="6" height="4" fill="#1a0a0a"/>
          {/* Teeth */}
          <rect x="16" y="30" width="18" height="6" fill="#e8e8e8"/>
          <rect x="19" y="30" width="3" height="6" fill="#1a0a0a"/>
          <rect x="25" y="30" width="3" height="6" fill="#1a0a0a"/>
          <rect x="31" y="30" width="3" height="6" fill="#1a0a0a"/>
          {/* Jaw */}
          <rect x="13" y="36" width="24" height="6" fill="#d4d4d4"/>
        </svg>
      </div>
    );

    const styles = {
      container: {
        fontFamily: '"Press Start 2P", monospace',
        fontSize: 'var(--font-base)',
        backgroundColor: GBC.bg,
        color: GBC.text,
        minHeight: '100vh',
        padding: 'var(--spacing-sm)',
        boxSizing: 'border-box',
        imageRendering: 'pixelated'
      },
      header: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        padding: 'var(--spacing-sm) var(--spacing-md)',
        backgroundColor: GBC.bgPanel,
        border: `3px solid ${GBC.border}`,
        borderRadius: '0',
        marginBottom: 'var(--spacing-sm)',
        boxShadow: `inset -2px -2px 0 ${GBC.borderLight}, inset 2px 2px 0 #0a0a14`
      },
      souls: {
        color: GBC.gold,
        textShadow: '1px 1px 0 #744210',
        fontSize: 'var(--font-base)'
      },
      mapContainer: {
        display: 'flex',
        justifyContent: 'center',
        marginBottom: 'var(--spacing-sm)'
      },
      grid: {
        display: 'grid',
        gap: '0px',
        backgroundColor: GBC.wallDark,
        padding: 'var(--spacing-xs)',
        border: `4px solid ${GBC.border}`,
        boxShadow: `inset -2px -2px 0 ${GBC.borderLight}, inset 2px 2px 0 #0a0a14, 0 4px 8px rgba(0,0,0,0.5)`
      },
      tile: {
        width: 'var(--tile-size)',
        height: 'var(--tile-size)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        position: 'relative',
        overflow: 'hidden'
      },
      teamStatus: {
        backgroundColor: GBC.bgPanel,
        padding: 'var(--spacing-sm)',
        border: `3px solid ${GBC.border}`,
        boxShadow: `inset -2px -2px 0 ${GBC.borderLight}, inset 2px 2px 0 #0a0a14`
      },
      creatureStatus: {
        marginBottom: 'var(--spacing-xs)',
        padding: 'var(--spacing-xs)',
        backgroundColor: GBC.bgLight,
        border: `2px solid ${GBC.border}`,
        fontSize: 'var(--font-sm)'
      },
      hpBar: {
        height: 'var(--spacing-sm)',
        backgroundColor: GBC.wallDark,
        marginTop: 'var(--spacing-xs)',
        position: 'relative',
        border: `2px solid ${GBC.border}`,
        boxShadow: 'inset 1px 1px 0 #0a0a14'
      },
      hpFill: {
        height: '100%',
        transition: 'width 0.2s',
        imageRendering: 'pixelated'
      },
      staminaBar: {
        height: 'var(--spacing-sm)',
        backgroundColor: GBC.wallDark,
        marginTop: 'var(--spacing-xs)',
        border: `2px solid ${GBC.border}`,
        boxShadow: 'inset 1px 1px 0 #0a0a14'
      },
      staminaFill: {
        height: '100%',
        backgroundColor: GBC.blue,
        transition: 'width 0.2s'
      },
      battleContainer: {
        padding: 'var(--spacing-sm)',
        backgroundColor: GBC.bg
      },
      battleCreature: {
        padding: 'var(--spacing-md)',
        backgroundColor: GBC.bgPanel,
        border: `3px solid ${GBC.border}`,
        marginBottom: 'var(--spacing-sm)',
        boxShadow: `inset -2px -2px 0 ${GBC.borderLight}, inset 2px 2px 0 #0a0a14`,
        fontSize: 'var(--font-sm)'
      },
      battleAnimation: {
        height: 'var(--battle-height)',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: GBC.bgLight,
        margin: 'var(--spacing-sm) 0',
        border: `3px solid ${GBC.border}`,
        fontSize: 'var(--font-sm)',
        textAlign: 'center',
        padding: 'var(--spacing-sm)',
        boxShadow: `inset -2px -2px 0 ${GBC.borderLight}, inset 2px 2px 0 #0a0a14`
      },
      moveButtons: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: 'var(--spacing-sm)',
        marginTop: 'var(--spacing-sm)'
      },
      moveButton: {
        padding: 'var(--spacing-md) var(--spacing-sm)',
        backgroundColor: GBC.bgPanel,
        border: `3px solid ${GBC.border}`,
        color: GBC.text,
        cursor: 'pointer',
        fontFamily: '"Press Start 2P", monospace',
        fontSize: 'var(--font-sm)',
        textAlign: 'left',
        boxShadow: `inset -2px -2px 0 ${GBC.borderLight}, inset 2px 2px 0 #0a0a14`,
        transition: 'transform 0.1s'
      },
      moveButtonDisabled: {
        opacity: 0.4,
        cursor: 'not-allowed'
      },
      starterSelect: {
        textAlign: 'center',
        padding: 'var(--spacing-xl) var(--spacing-lg)'
      },
      starterCard: {
        display: 'inline-block',
        width: 'clamp(150px, 25vw, 220px)',
        padding: 'var(--spacing-lg) var(--spacing-md)',
        margin: 'var(--spacing-sm)',
        backgroundColor: GBC.bgPanel,
        border: `4px solid ${GBC.border}`,
        cursor: 'pointer',
        verticalAlign: 'top',
        boxShadow: `inset -2px -2px 0 ${GBC.borderLight}, inset 2px 2px 0 #0a0a14`,
        transition: 'transform 0.1s'
      },
      scar: {
        display: 'inline-block',
        padding: '2px 4px',
        backgroundColor: '#3d1515',
        color: GBC.red,
        fontSize: 'var(--font-xs)',
        marginLeft: '3px',
        border: '2px solid #5a2020'
      },
      status: {
        display: 'inline-block',
        padding: '2px 4px',
        fontSize: 'var(--font-xs)',
        marginLeft: '3px'
      },
      winded: {
        backgroundColor: '#3d3215',
        color: GBC.gold,
        border: '2px solid #5a4a20'
      },
      burn: {
        backgroundColor: '#3d2015',
        color: '#f6ad55',
        border: '2px solid #5a3020'
      },
      victory: {
        textAlign: 'center',
        padding: 'var(--spacing-xl) var(--spacing-lg)',
        backgroundColor: '#0a1a0a',
        border: `4px solid ${GBC.green}`,
        margin: 'var(--spacing-lg)',
        boxShadow: `inset -3px -3px 0 #1a3a1a, inset 3px 3px 0 #051005`
      },
      gameOver: {
        textAlign: 'center',
        padding: 'var(--spacing-xl) var(--spacing-lg)',
        backgroundColor: '#1a0a0a',
        border: `4px solid ${GBC.red}`,
        margin: 'var(--spacing-lg)',
        boxShadow: `inset -3px -3px 0 #3a1a1a, inset 3px 3px 0 #100505`
      },
      button: {
        padding: 'var(--spacing-md) var(--spacing-xl)',
        backgroundColor: GBC.bgPanel,
        border: `4px solid ${GBC.border}`,
        color: GBC.text,
        cursor: 'pointer',
        fontFamily: '"Press Start 2P", monospace',
        fontSize: 'var(--font-base)',
        marginTop: 'var(--spacing-lg)',
        boxShadow: `inset -2px -2px 0 ${GBC.borderLight}, inset 2px 2px 0 #0a0a14`,
        outline: 'none'
      },
      typeIcon: {
        fontSize: 'var(--font-xl)'
      },
      log: {
        backgroundColor: GBC.bgLight,
        padding: 'var(--spacing-sm)',
        marginTop: 'var(--spacing-sm)',
        border: `3px solid ${GBC.border}`,
        maxHeight: 'clamp(70px, 10vh, 120px)',
        overflowY: 'auto',
        fontSize: 'var(--font-sm)',
        boxShadow: `inset 2px 2px 0 #0a0a14`
      },
      muteButton: {
        position: 'fixed',
        top: 'var(--spacing-sm)',
        right: 'var(--spacing-sm)',
        width: 'var(--button-size)',
        height: 'var(--button-size)',
        backgroundColor: GBC.bgPanel,
        border: `3px solid ${GBC.border}`,
        borderRadius: '0',
        color: GBC.textDim,
        cursor: 'pointer',
        fontFamily: '"Press Start 2P", monospace',
        fontSize: 'var(--font-lg)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000,
        boxShadow: `inset -2px -2px 0 ${GBC.borderLight}, inset 2px 2px 0 #0a0a14`
      },
      creatureSprite: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        marginRight: 'var(--spacing-sm)',
        transform: 'scale(var(--sprite-scale))'
      },
      battleSpriteArea: {
        display: 'flex',
        justifyContent: 'space-around',
        alignItems: 'center',
        padding: 'var(--spacing-md)',
        backgroundColor: GBC.grassDark,
        border: `3px solid ${GBC.border}`,
        marginBottom: 'var(--spacing-sm)',
        minHeight: 'var(--battle-height)'
      },
      bindButton: {
        padding: 'var(--spacing-md) var(--spacing-sm)',
        backgroundColor: '#2a1a3a',
        border: `3px solid #6b46c1`,
        color: '#d6bcfa',
        cursor: 'pointer',
        fontFamily: '"Press Start 2P", monospace',
        fontSize: 'var(--font-sm)',
        textAlign: 'center',
        boxShadow: `inset -2px -2px 0 #805ad5, inset 2px 2px 0 #1a0a2e`,
        gridColumn: 'span 2'
      },
      bindButtonDisabled: {
        backgroundColor: '#1a1a2a',
        borderColor: '#4a4a6a',
        color: '#6a6a8a',
        cursor: 'not-allowed'
      },
      bonfireMenu: {
        backgroundColor: GBC.bgPanel,
        border: `3px solid ${GBC.border}`,
        padding: 'var(--spacing-md)',
        marginTop: 'var(--spacing-sm)'
      },
      bonfireOption: {
        padding: 'var(--spacing-sm)',
        marginBottom: 'var(--spacing-xs)',
        backgroundColor: GBC.bgLight,
        border: `2px solid ${GBC.border}`,
        cursor: 'pointer',
        fontSize: 'var(--font-sm)'
      },
      helpButton: {
        position: 'fixed',
        top: 'var(--spacing-sm)',
        right: 'calc(var(--button-size) + var(--spacing-lg))',
        width: 'var(--button-size)',
        height: 'var(--button-size)',
        backgroundColor: GBC.bgPanel,
        border: `3px solid ${GBC.border}`,
        borderRadius: '0',
        color: GBC.textDim,
        cursor: 'pointer',
        fontFamily: '"Press Start 2P", monospace',
        fontSize: 'var(--font-md)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000,
        boxShadow: `inset -2px -2px 0 ${GBC.borderLight}, inset 2px 2px 0 #0a0a14`
      },
      helpOverlay: {
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(10, 10, 20, 0.95)',
        zIndex: 2000,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        padding: 'var(--spacing-lg)'
      },
      helpContent: {
        backgroundColor: GBC.bgPanel,
        border: `4px solid ${GBC.border}`,
        padding: 'var(--spacing-lg)',
        maxWidth: 'clamp(400px, 50vw, 600px)',
        maxHeight: '90vh',
        overflowY: 'auto',
        fontFamily: '"Press Start 2P", monospace',
        boxShadow: `inset -3px -3px 0 ${GBC.borderLight}, inset 3px 3px 0 #0a0a14, 0 0 40px rgba(0,0,0,0.8)`
      },
      helpTitle: {
        color: GBC.red,
        fontSize: 'var(--font-md)',
        textAlign: 'center',
        marginBottom: 'var(--spacing-lg)',
        textShadow: '2px 2px 0 #3d1515'
      },
      helpSection: {
        marginBottom: 'var(--spacing-md)'
      },
      helpSectionTitle: {
        color: GBC.gold,
        fontSize: 'var(--font-sm)',
        marginBottom: 'var(--spacing-xs)'
      },
      helpText: {
        color: GBC.textDim,
        fontSize: 'var(--font-xs)',
        lineHeight: '1.6'
      },
      helpClose: {
        display: 'block',
        width: '100%',
        padding: 'var(--spacing-md)',
        marginTop: 'var(--spacing-lg)',
        backgroundColor: GBC.bgLight,
        border: `3px solid ${GBC.border}`,
        color: GBC.text,
        cursor: 'pointer',
        fontFamily: '"Press Start 2P", monospace',
        fontSize: 'var(--font-sm)',
        textAlign: 'center',
        boxShadow: `inset -2px -2px 0 ${GBC.borderLight}, inset 2px 2px 0 #0a0a14`
      },
      helpQuote: {
        color: GBC.textDim,
        fontSize: 'var(--font-xs)',
        textAlign: 'center',
        fontStyle: 'italic',
        marginTop: 'var(--spacing-md)'
      },
      prologue: {
        textAlign: 'center',
        padding: 'var(--spacing-xl) var(--spacing-lg)',
        backgroundColor: GBC.bg,
        minHeight: 'clamp(400px, 50vh, 600px)',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center'
      },
      prologueLine: {
        color: GBC.textDim,
        fontSize: 'var(--font-sm)',
        marginBottom: 'var(--spacing-md)',
        lineHeight: '1.8'
      },
      prologueHighlight: {
        color: GBC.gold,
        fontSize: 'var(--font-sm)',
        marginBottom: 'var(--spacing-md)',
        lineHeight: '1.8'
      },
      examineOverlay: {
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(10, 10, 20, 0.9)',
        zIndex: 1500,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        padding: 'var(--spacing-lg)'
      },
      examineContent: {
        backgroundColor: GBC.bgPanel,
        border: `4px solid ${GBC.border}`,
        padding: 'var(--spacing-lg)',
        maxWidth: 'clamp(350px, 40vw, 500px)',
        fontFamily: '"Press Start 2P", monospace',
        boxShadow: `inset -3px -3px 0 ${GBC.borderLight}, inset 3px 3px 0 #0a0a14, 0 0 40px rgba(0,0,0,0.8)`
      },
      examineTitle: {
        color: GBC.gold,
        fontSize: 'var(--font-sm)',
        marginBottom: 'var(--spacing-md)',
        textAlign: 'center'
      },
      examineLine: {
        color: GBC.textDim,
        fontSize: 'var(--font-xs)',
        lineHeight: '1.8',
        marginBottom: 'var(--spacing-xs)'
      },
      examinePrompt: {
        color: GBC.border,
        fontSize: 'var(--font-xs)',
        textAlign: 'center',
        marginTop: 'var(--spacing-lg)'
      },
      credits: {
        textAlign: 'center',
        padding: 'var(--spacing-xl) var(--spacing-lg)',
        backgroundColor: GBC.bg,
        minHeight: 'clamp(400px, 50vh, 600px)'
      },
      creditsTitle: {
        color: GBC.red,
        fontSize: 'var(--font-lg)',
        marginBottom: 'var(--spacing-xl)',
        textShadow: '2px 2px 0 #3d1515'
      },
      creditsSection: {
        marginBottom: 'var(--spacing-lg)'
      },
      creditsLabel: {
        color: GBC.textDim,
        fontSize: 'var(--font-xs)',
        marginBottom: 'var(--spacing-xs)'
      },
      creditsValue: {
        color: GBC.text,
        fontSize: 'var(--font-sm)'
      },
      creditsQuote: {
        color: GBC.gold,
        fontSize: 'var(--font-xs)',
        fontStyle: 'italic',
        marginTop: 'var(--spacing-xl)',
        marginBottom: 'var(--spacing-sm)',
        lineHeight: '1.6'
      },
      victoryDialogue: {
        color: GBC.textDim,
        fontSize: 'var(--font-xs)',
        fontStyle: 'italic',
        marginBottom: 'var(--spacing-xs)',
        lineHeight: '1.6'
      },
      victoryTitle: {
        fontSize: 'var(--font-lg)',
        color: GBC.gold,
        marginBottom: 'var(--spacing-lg)',
        textShadow: '2px 2px 0 #744210'
      },
      victorySubtitle: {
        fontSize: 'var(--font-sm)',
        color: GBC.textDim,
        marginBottom: 'var(--spacing-lg)',
        fontStyle: 'italic'
      },
      pauseOverlay: {
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(10, 10, 20, 0.95)',
        zIndex: 2000,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      },
      pauseMenu: {
        backgroundColor: GBC.bgPanel,
        border: `4px solid ${GBC.border}`,
        padding: 'var(--spacing-xl)',
        minWidth: 'clamp(280px, 30vw, 400px)',
        fontFamily: '"Press Start 2P", monospace',
        boxShadow: `inset -3px -3px 0 ${GBC.borderLight}, inset 3px 3px 0 #0a0a14, 0 0 60px rgba(0,0,0,0.9)`
      },
      pauseTitle: {
        color: GBC.textDim,
        fontSize: 'var(--font-base)',
        textAlign: 'center',
        marginBottom: 'var(--spacing-lg)',
        letterSpacing: '2px'
      },
      pauseOption: {
        padding: 'var(--spacing-md) var(--spacing-lg)',
        marginBottom: 'var(--spacing-sm)',
        backgroundColor: GBC.bgLight,
        border: `3px solid ${GBC.border}`,
        color: GBC.text,
        cursor: 'pointer',
        fontSize: 'var(--font-sm)',
        textAlign: 'center',
        transition: 'border-color 0.1s'
      },
      pauseOptionDisabled: {
        opacity: 0.4,
        cursor: 'not-allowed'
      },
      gearButton: {
        position: 'fixed',
        top: 'var(--spacing-sm)',
        right: 'calc(var(--button-size) * 2 + var(--spacing-xl))',
        width: 'var(--button-size)',
        height: 'var(--button-size)',
        backgroundColor: GBC.bgPanel,
        border: `3px solid ${GBC.border}`,
        borderRadius: '0',
        color: GBC.textDim,
        cursor: 'pointer',
        fontFamily: '"Press Start 2P", monospace',
        fontSize: 'var(--font-lg)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000,
        boxShadow: `inset -2px -2px 0 ${GBC.borderLight}, inset 2px 2px 0 #0a0a14`
      },
      confirmOverlay: {
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(10, 10, 20, 0.95)',
        zIndex: 2500,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      },
      confirmDialog: {
        backgroundColor: GBC.bgPanel,
        border: `4px solid ${GBC.red}`,
        padding: 'var(--spacing-xl)',
        maxWidth: 'clamp(320px, 35vw, 450px)',
        fontFamily: '"Press Start 2P", monospace',
        boxShadow: `inset -3px -3px 0 #5a2020, inset 3px 3px 0 #0a0a14, 0 0 40px rgba(0,0,0,0.8)`
      },
      confirmText: {
        color: GBC.text,
        fontSize: 'var(--font-sm)',
        textAlign: 'center',
        marginBottom: 'var(--spacing-lg)',
        lineHeight: '1.6'
      },
      confirmButtons: {
        display: 'flex',
        gap: 'var(--spacing-md)',
        justifyContent: 'center'
      },
      confirmButton: {
        padding: 'var(--spacing-md) var(--spacing-lg)',
        backgroundColor: GBC.bgLight,
        border: `3px solid ${GBC.border}`,
        color: GBC.text,
        cursor: 'pointer',
        fontFamily: '"Press Start 2P", monospace',
        fontSize: 'var(--font-sm)'
      },
      confirmButtonDanger: {
        borderColor: GBC.red,
        color: GBC.red
      },
      loadScreen: {
        textAlign: 'center',
        padding: 'var(--spacing-xl) var(--spacing-lg)',
        backgroundColor: GBC.bg
      },
      loadTitle: {
        color: GBC.textDim,
        fontSize: 'var(--font-md)',
        marginBottom: 'var(--spacing-xl)'
      },
      saveSlot: {
        backgroundColor: GBC.bgPanel,
        border: `3px solid ${GBC.border}`,
        padding: 'var(--spacing-lg)',
        marginBottom: 'var(--spacing-lg)',
        textAlign: 'left'
      },
      saveSlotTitle: {
        color: GBC.gold,
        fontSize: 'var(--font-sm)',
        marginBottom: 'var(--spacing-md)'
      },
      saveSlotStat: {
        color: GBC.textDim,
        fontSize: 'var(--font-xs)',
        marginBottom: 'var(--spacing-xs)'
      },
      saveNotification: {
        position: 'fixed',
        bottom: 'var(--spacing-lg)',
        left: '50%',
        transform: 'translateX(-50%)',
        backgroundColor: GBC.bgPanel,
        border: `3px solid ${GBC.gold}`,
        padding: 'var(--spacing-md) var(--spacing-xl)',
        color: GBC.gold,
        fontSize: 'var(--font-sm)',
        fontFamily: '"Press Start 2P", monospace',
        zIndex: 1500,
        boxShadow: `0 0 20px rgba(246, 224, 94, 0.3)`
      },
      difficultySelect: {
        textAlign: 'center',
        padding: 'var(--spacing-lg)'
      },
      difficultyTitle: {
        color: GBC.textDim,
        fontSize: 'var(--font-lg)',
        marginBottom: 'var(--spacing-xl)',
        letterSpacing: '2px'
      },
      difficultyCard: {
        display: 'block',
        width: '100%',
        maxWidth: 'clamp(300px, 50vw, 500px)',
        margin: '0 auto var(--spacing-md)',
        padding: 'var(--spacing-lg)',
        backgroundColor: GBC.bgPanel,
        border: `3px solid ${GBC.border}`,
        cursor: 'pointer',
        textAlign: 'left',
        boxShadow: `inset -2px -2px 0 ${GBC.borderLight}, inset 2px 2px 0 #0a0a14`,
        transition: 'border-color 0.1s'
      },
      difficultyHeader: {
        display: 'flex',
        alignItems: 'center',
        marginBottom: 'var(--spacing-sm)'
      },
      difficultyIcon: {
        fontSize: 'var(--font-xl)',
        marginRight: 'var(--spacing-sm)'
      },
      difficultyName: {
        color: GBC.text,
        fontSize: 'var(--font-base)',
        marginRight: 'var(--spacing-sm)'
      },
      difficultySubtitle: {
        color: GBC.textDim,
        fontSize: 'var(--font-xs)'
      },
      difficultyDesc: {
        color: GBC.textDim,
        fontSize: 'var(--font-xs)',
        fontStyle: 'italic',
        marginBottom: 'var(--spacing-sm)'
      },
      difficultyDetails: {
        color: GBC.textDim,
        fontSize: 'var(--font-xs)',
        lineHeight: '1.6'
      },
      difficultyIndicator: {
        position: 'fixed',
        top: 'var(--spacing-sm)',
        left: 'var(--spacing-sm)',
        backgroundColor: GBC.bgPanel,
        border: `2px solid ${GBC.border}`,
        padding: 'var(--spacing-xs) var(--spacing-md)',
        fontSize: 'var(--font-base)',
        fontFamily: '"Press Start 2P", monospace',
        zIndex: 1000,
        display: 'flex',
        alignItems: 'center',
        gap: 'var(--spacing-xs)'
      },
      difficultyIndicatorName: {
        fontSize: 'var(--font-xs)',
        color: GBC.textDim
      }
    };

    const getTypeColor = (type) => {
      switch (type) {
        case 'fire': return GBC.fire;
        case 'water': return GBC.water;
        case 'grass': return GBC.grass;
        case 'dark': return GBC.dark;
        case 'light': return GBC.light;
        case 'darklight': return '#9f7aea'; // Purple blend of dark and light
        default: return GBC.textDim;
      }
    };

    const getTypeIcon = (type) => {
      switch (type) {
        case 'fire': return '';
        case 'water': return '';
        case 'grass': return '';
        case 'dark': return '';
        case 'light': return '';
        case 'darklight': return '';
        default: return '';
      }
    };

    const calculateDamage = (move, attacker, defender, attackerCreature, defenderCreature, difficultyMult = 1.0) => {
      if (move.damage === 0) return 0;
      let damage = move.damage;
      const effectiveness = TYPE_CHART[attackerCreature.type][defenderCreature.type];
      damage = Math.floor(damage * effectiveness);

      if (defender.isGuarding) {
        damage = Math.floor(damage * 0.5);
      }

      if (attacker.winded) {
        damage = Math.floor(damage * 1.25);
      }

      if (attacker.scars && attacker.scars.length >= 3) {
        damage = Math.floor(damage * 0.75);
      }

      // Apply difficulty multiplier for enemy attacks
      damage = Math.floor(damage * difficultyMult);

      return Math.max(1, damage);
    };

    const MAX_TEAM_SIZE = 3;
    const BIND_COST = 20;

    const getRandomWild = () => {
      const wilds = Object.values(WILD_CREATURES);
      const baseCreature = wilds[Math.floor(Math.random() * wilds.length)];

      // Add stat variance: +/- 5 HP, +/- 2 stamina
      const hpVariance = Math.floor(Math.random() * 11) - 5; // -5 to +5
      const staminaVariance = Math.floor(Math.random() * 5) - 2; // -2 to +2

      const creature = {
        ...baseCreature,
        maxHp: Math.max(20, baseCreature.maxHp + hpVariance),
        maxStamina: Math.max(10, baseCreature.maxStamina + staminaVariance),
        scars: []
      };

      // 10% chance of pre-scarred creature
      if (Math.random() < 0.1) {
        const scar = getRandomScar();
        creature.scars = [scar];
        creature.preScarred = true;
      }

      return creature;
    };

    // Get random creature for The Hollow Deep (Dark/Light types)
    const getRandomDeepWild = () => {
      // 60% Umbravine (Dark), 40% Solrath (Light)
      const typeRoll = Math.random();
      const isUmbravine = typeRoll < 0.6;

      const baseCreature = isUmbravine ? {
        id: 'wildUmbravine',
        name: 'Wild Umbravine',
        type: 'dark',
        maxHp: STARTERS.umbravine.maxHp + 5, // +5 HP for Deep creatures
        maxStamina: STARTERS.umbravine.maxStamina + 2, // +2 Stamina
        moves: STARTERS.umbravine.moves
      } : {
        id: 'wildSolrath',
        name: 'Wild Solrath',
        type: 'light',
        maxHp: STARTERS.solrath.maxHp + 5,
        maxStamina: STARTERS.solrath.maxStamina + 2,
        moves: STARTERS.solrath.moves
      };

      // Add stat variance
      const hpVariance = Math.floor(Math.random() * 11) - 5;
      const staminaVariance = Math.floor(Math.random() * 5) - 2;

      const creature = {
        ...baseCreature,
        maxHp: Math.max(25, baseCreature.maxHp + hpVariance),
        maxStamina: Math.max(12, baseCreature.maxStamina + staminaVariance),
        scars: []
      };

      // 20% chance of pre-scarred (higher than surface)
      if (Math.random() < 0.2) {
        const scar = getRandomScar();
        creature.scars = [scar];
        creature.preScarred = true;
      }

      return creature;
    };

    const getCaptureChance = (currentHp, maxHp, captureBonus = 0) => {
      const hpPercent = (currentHp / maxHp) * 100;
      let chance;
      if (hpPercent < 10) chance = 90;
      else if (hpPercent < 25) chance = 60;
      else if (hpPercent <= 50) chance = 30;
      else chance = 10;
      // Apply difficulty capture bonus (capped at 5-95%)
      return Math.max(5, Math.min(95, chance + captureBonus));
    };

    const getRandomScar = (difficulty) => {
      const baseScar = SCAR_TYPES[Math.floor(Math.random() * SCAR_TYPES.length)];
      // Apply difficulty-specific penalties
      if (difficulty && difficulty.scarPenalties) {
        if (baseScar.effect === 'maxHp') {
          return { ...baseScar, value: difficulty.scarPenalties.hp, description: `${difficulty.scarPenalties.hp} max HP` };
        }
        if (baseScar.effect === 'maxStamina') {
          return { ...baseScar, value: difficulty.scarPenalties.stamina, description: `${difficulty.scarPenalties.stamina} max Stamina` };
        }
      }
      return baseScar;
    };

    const applyScars = (creature, baseData, hollowedThreshold = 3) => {
      let maxHp = baseData.maxHp;
      let maxStamina = baseData.maxStamina;
      let hasFlinching = false;

      if (creature.scars) {
        creature.scars.forEach(scar => {
          if (scar.effect === 'maxHp') maxHp += scar.value;
          if (scar.effect === 'maxStamina') maxStamina += scar.value;
          if (scar.effect === 'noPriority') hasFlinching = true;
        });
      }

      if (creature.scars && creature.scars.length >= hollowedThreshold) {
        maxHp = Math.floor(maxHp * 0.75);
        maxStamina = Math.floor(maxStamina * 0.75);
      }

      return { maxHp: Math.max(1, maxHp), maxStamina: Math.max(1, maxStamina), hasFlinching };
    };

    // ============= LORE DATA =============
    const TILE_LORE = {
      ashenPath: {
        // Old signpost near start (3,1)
        '3,1': {
          name: 'Old Signpost',
          lines: [
            '"Cinder\'s Edge - 3 leagues east"',
            '',
            'The wood is burned. The arrow points to nothing but wall.'
          ]
        },
        // Collapsed statue in corner (6,1)
        '6,1': {
          name: 'Collapsed Statue',
          lines: [
            'A Healer\'s Sanctuary sign, half-buried.',
            '',
            'The red roof is faded to gray.'
          ]
        },
        // Near the gate
        '4,4': {
          name: 'Faded Marks',
          lines: [
            'Scratches in the stone. Tally marks.',
            '',
            'Dozens of them. Then nothing.'
          ]
        },
        // Abandoned Pack
        '2,3': {
          name: 'Abandoned Pack',
          lines: [
            'Scattered belongings. Someone left in a hurry.',
            '',
            'Or didn\'t leave at all.'
          ]
        },
        // Scorched Tree
        '5,2': {
          name: 'Scorched Tree',
          lines: [
            'The bark is burned clean through.',
            '',
            'Whatever did this wasn\'t trying to destroyit was trying to purify.'
          ]
        }
      },
      fallenKeep: {
        // Scratched message near entrance (2,7)
        '2,7': {
          name: 'Scratched Message',
          lines: [
            '"V. guards what remains. Do not wake him.',
            '',
            'He only wants it to end."'
          ]
        },
        // Broken soul spheres scattered (4,1)
        '4,1': {
          name: 'Broken Shells',
          lines: [
            'Empty shells. Dozens of them.',
            '',
            'Whatever was inside left long ago. Or never survived.'
          ]
        },
        // Near boss room (1,5)
        '3,5': {
          name: 'Old Banner',
          lines: [
            'A tattered gym banner. The emblem is unreadable.',
            '',
            'Someone was proud here, once.'
          ]
        },
        // Boss room entrance warning
        '3,6': {
          name: 'Charred Ground',
          lines: [
            'The stone is blackened. Still warm.',
            '',
            'Something burns eternal beyond this door.'
          ]
        },
        // Keeper's Quarters
        '4,3': {
          name: 'Keeper\'s Quarters',
          lines: [
            'A bedroll, long cold.',
            '',
            'The keeper hasn\'t slept in years.'
          ]
        },
        // Trophy Wall
        '2,5': {
          name: 'Trophy Wall',
          lines: [
            'Scratches in the stone. Names? Warnings?',
            '',
            'Each one ends mid-stroke.'
          ]
        }
      },
      hollowDeep: {
        // Shattered Altar
        '2,2': {
          name: 'Shattered Altar',
          lines: [
            'The light faded here first.',
            '',
            'Something older took its place.'
          ]
        },
        // Hollow Roots
        '5,3': {
          name: 'Hollow Roots',
          lines: [
            'Even the stone bleeds where the dark vines grew.',
            '',
            'They drink what light remains.'
          ]
        },
        // Keeper's Echo
        '3,5': {
          name: 'Keeper\'s Echo',
          lines: [
            'Varek was not the first.',
            '',
            'Nor the last.'
          ]
        },
        // The Final Gate
        '1,6': {
          name: 'The Final Gate',
          lines: [
            'Beyond this, only ending.',
            '',
            'Or beginning.'
          ]
        }
      }
    };

    // Boss dialogue collections
    const BOSS_DIALOGUE = {
      intro: [
        '"Another walks the ash. Another seeks the flame beyond."',
        '"I was a guardian once. Now I am a door."'
      ],
      phase2: [
        '"You fight like the ones before... but you haven\'t broken yet."',
        '"Fine. Let me show you why they stopped coming."'
      ],
      playerDeath: [
        '"Rest now. The bonfire remembers you."',
        '"Return when you\'re ready to fail again."'
      ],
      victory: [
        '"So. One finally passes."',
        '"Beyond this door... another keeper waits. Another path. Another fire."',
        '"The cycle doesn\'t end. It never ends."',
        '"But you... you carry scars and still stand."',
        '"Perhaps that is enough."'
      ]
    };

    // Hollow Warden dialogue (post-game boss)
    const HOLLOW_WARDEN_DIALOGUE = {
      intro: [
        '"You carry his flame. But flames die in the deep."',
        '"I was light once. Now I am the absence of it."'
      ],
      phase2: [
        '"Light and dark... two sides of the same void."',
        '"Let me show you what happens when they merge."'
      ],
      playerDeath: [
        '"The deep remembers all who fall."',
        '"Return... if you can find the way back."'
      ],
      victory: [
        '"The cycle continues. Another keeper rises. Another falls."',
        '"You have walked through shadow and emerged."',
        '"But the flame still burns. It always will."',
        '"Go now. The surface remembers you."'
      ]
    };

    // ============= DIFFICULTY SYSTEM =============
    const DIFFICULTIES = {
      ashen: {
        id: 'ashen',
        name: 'ASHEN',
        icon: '',
        subtitle: 'Easy',
        description: 'For those who wish to explore.',
        wildDamageMult: 0.5,
        bossDamageMult: 0.75,
        scarsHealAtBonfire: true,
        soulDropPercent: 0.5,
        dropBankedSouls: false,
        captureBonus: 20,
        bossHpMult: 1.0,
        hollowedThreshold: 3,
        bonfireHeals: true,
        permadeath: false,
        bossPhaseTransition: true,
        scarPenalties: { hp: -5, stamina: -2 }
      },
      scarred: {
        id: 'scarred',
        name: 'SCARRED',
        icon: '',
        subtitle: 'Normal',
        description: 'The path as intended.',
        wildDamageMult: 0.75,
        bossDamageMult: 1.0,
        scarsHealAtBonfire: false,
        soulDropPercent: 1.0,
        dropBankedSouls: false,
        captureBonus: 0,
        bossHpMult: 1.0,
        hollowedThreshold: 3,
        bonfireHeals: true,
        permadeath: false,
        bossPhaseTransition: true,
        scarPenalties: { hp: -5, stamina: -2 }
      },
      hollowed: {
        id: 'hollowed',
        name: 'HOLLOWED',
        icon: '',
        subtitle: 'Hard',
        description: 'For those who seek true suffering.',
        wildDamageMult: 1.0,
        bossDamageMult: 1.0,
        scarsHealAtBonfire: false,
        soulDropPercent: 1.0,
        dropBankedSouls: true,
        captureBonus: -20,
        bossHpMult: 1.25,
        hollowedThreshold: 3,
        bonfireHeals: true,
        permadeath: false,
        bossPhaseTransition: true,
        scarPenalties: { hp: -7, stamina: -3 }
      },
      broken: {
        id: 'broken',
        name: 'BROKEN',
        icon: '',
        subtitle: 'Nightmare',
        description: 'You will not survive.',
        wildDamageMult: 1.0,
        bossDamageMult: 1.0,
        scarsHealAtBonfire: false,
        soulDropPercent: 1.0,
        dropBankedSouls: true,
        captureBonus: -20,
        bossHpMult: 1.25,
        hollowedThreshold: 1,
        bonfireHeals: false,
        permadeath: true,
        bossPhaseTransition: false,
        scarPenalties: { hp: -7, stamina: -3 }
      }
    };

    const getDifficulty = (state) => {
      return DIFFICULTIES[state.difficulty] || DIFFICULTIES.scarred;
    };

    // ============= SAVE SYSTEM =============
    const SAVE_KEY = 'pokeSoulsSaveData';

    const getSaveData = (state) => {
      return {
        currentMap: state.currentMap,
        playerPos: state.playerPos,
        playerDir: state.playerDir,
        team: state.team,
        activeCreatureIndex: state.activeCreatureIndex,
        souls: state.souls,
        bankedSouls: state.bankedSouls,
        droppedSouls: state.droppedSouls,
        bossDefeated: state.bossDefeated,
        hollowWardenDefeated: state.hollowWardenDefeated,
        shortcutUnlocked: state.shortcutUnlocked,
        grassEncounters: state.grassEncounters,
        lastBonfire: state.lastBonfire,
        hasSeenPrologue: state.hasSeenPrologue,
        playTime: state.playTime,
        difficulty: state.difficulty,
        savedAt: Date.now()
      };
    };

    const saveGame = (state) => {
      try {
        const saveData = getSaveData(state);
        localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
        return true;
      } catch (e) {
        console.error('Failed to save:', e);
        return false;
      }
    };

    const loadSaveData = () => {
      try {
        const data = localStorage.getItem(SAVE_KEY);
        if (data) {
          return JSON.parse(data);
        }
      } catch (e) {
        console.error('Failed to load save:', e);
      }
      return null;
    };

    const deleteSaveData = () => {
      try {
        localStorage.removeItem(SAVE_KEY);
        return true;
      } catch (e) {
        console.error('Failed to delete save:', e);
        return false;
      }
    };

    // Run statistics storage
    const STATS_KEY = 'pokeSoulsStats';

    const getDefaultStats = () => ({
      totalRuns: 0,
      completedRuns: { ashen: 0, scarred: 0, hollowed: 0, broken: 0 },
      fastestClear: { ashen: null, scarred: null, hollowed: null, broken: null },
      lowestScars: { ashen: null, scarred: null, hollowed: null, broken: null },
      totalCreaturesCaptured: 0,
      totalDeaths: 0,
      totalScarsEarned: 0,
      hollowWardenDefeated: false,
      creaturesCollected: []
    });

    const loadStats = () => {
      try {
        const data = localStorage.getItem(STATS_KEY);
        if (data) {
          const stats = JSON.parse(data);
          // Merge with defaults in case new fields were added
          return { ...getDefaultStats(), ...stats };
        }
      } catch (e) {
        console.error('Failed to load stats:', e);
      }
      return getDefaultStats();
    };

    const saveStats = (stats) => {
      try {
        localStorage.setItem(STATS_KEY, JSON.stringify(stats));
        return true;
      } catch (e) {
        console.error('Failed to save stats:', e);
        return false;
      }
    };

    const updateStats = (updates) => {
      const stats = loadStats();
      const newStats = { ...stats, ...updates };
      saveStats(newStats);
      return newStats;
    };

    const recordRunStart = () => {
      const stats = loadStats();
      stats.totalRuns++;
      saveStats(stats);
    };

    const recordDeath = () => {
      const stats = loadStats();
      stats.totalDeaths++;
      saveStats(stats);
    };

    const recordScar = () => {
      const stats = loadStats();
      stats.totalScarsEarned++;
      saveStats(stats);
    };

    const recordCapture = (creatureId) => {
      const stats = loadStats();
      stats.totalCreaturesCaptured++;
      if (!stats.creaturesCollected.includes(creatureId)) {
        stats.creaturesCollected.push(creatureId);
      }
      saveStats(stats);
    };

    const recordVictory = (difficulty, playTime, totalScars, isHollowWarden = false) => {
      const stats = loadStats();
      stats.completedRuns[difficulty]++;

      // Track fastest clear
      if (stats.fastestClear[difficulty] === null || playTime < stats.fastestClear[difficulty]) {
        stats.fastestClear[difficulty] = playTime;
      }

      // Track lowest scars
      if (stats.lowestScars[difficulty] === null || totalScars < stats.lowestScars[difficulty]) {
        stats.lowestScars[difficulty] = totalScars;
      }

      if (isHollowWarden) {
        stats.hollowWardenDefeated = true;
      }

      saveStats(stats);
    };

    const formatPlayTime = (ms) => {
      const totalSeconds = Math.floor(ms / 1000);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      if (hours > 0) {
        return `${hours}h ${minutes}m`;
      }
      return `${minutes}m ${seconds}s`;
    };

    const initialState = {
      screen: 'difficulty',
      difficulty: 'scarred',
      currentMap: 'ashenPath',
      playerPos: { x: 1, y: 1 },
      playerDir: 'down',
      team: [],
      activeCreatureIndex: 0,
      souls: 0,
      bankedSouls: 0,
      droppedSouls: null,
      enemy: null,
      enemyCreature: null,
      battleLog: [],
      turnPhase: 'player',
      shortcutUnlocked: false,
      bossDefeated: false,
      bossPhase: 1,
      arenaEffect: null,
      grassEncounters: [
        // Ashen Path encounters
        { x: 3, y: 1, map: 'ashenPath', active: true },
        { x: 4, y: 1, map: 'ashenPath', active: true },
        { x: 4, y: 2, map: 'ashenPath', active: true },
        { x: 6, y: 3, map: 'ashenPath', active: true },
        // Hollow Deep encounters (Dark/Light creatures)
        { x: 4, y: 1, map: 'hollowDeep', active: true },
        { x: 6, y: 4, map: 'hollowDeep', active: true }
      ],
      lastBonfire: { map: 'ashenPath', pos: { x: 1, y: 1 } },
      bonfireMenuOpen: false,
      hasSeenPrologue: false,
      examineText: null,
      playTime: 0,
      saveNotification: null,
      hollowWardenDefeated: false,
      isHollowWardenFight: false
    };

    function handleCreatureFaint(state, team, enemy, log) {
      const difficulty = getDifficulty(state);
      const activeCreature = team[state.activeCreatureIndex];
      const scar = getRandomScar(difficulty);

      activeCreature.hp = 0;
      activeCreature.scars = [...(activeCreature.scars || []), scar];

      log.push(`${activeCreature.nickname || activeCreature.name} has fallen!`);
      log.push(`${activeCreature.nickname || activeCreature.name} gained scar: ${scar.name} (${scar.description})`);

      if (activeCreature.scars.length >= difficulty.hollowedThreshold) {
        log.push(`${activeCreature.nickname || activeCreature.name} has become Hollowed...`);
      }

      team[state.activeCreatureIndex] = activeCreature;

      const availableIndex = team.findIndex((c, i) => i !== state.activeCreatureIndex && c.hp > 0);

      if (availableIndex === -1) {
        // Calculate souls to drop based on difficulty
        let soulsToDrop = Math.floor(state.souls * difficulty.soulDropPercent);
        if (difficulty.dropBankedSouls) {
          soulsToDrop += state.bankedSouls;
        }

        const droppedSouls = soulsToDrop > 0 ? {
          map: state.currentMap,
          pos: { ...state.playerPos },
          amount: soulsToDrop
        } : state.droppedSouls;

        // Add boss death dialogue if dying to boss
        if (state.isBossFight) {
          BOSS_DIALOGUE.playerDeath.forEach(line => log.push(line));
        }

        return {
          ...state,
          screen: 'gameOver',
          team,
          enemy,
          battleLog: log,
          souls: 0,
          bankedSouls: difficulty.dropBankedSouls ? 0 : state.bankedSouls,
          droppedSouls,
          diedToBoss: state.isBossFight
        };
      }

      return {
        ...state,
        team,
        enemy,
        battleLog: log,
        activeCreatureIndex: availableIndex,
        turnPhase: 'player'
      };
    }

    function gameReducer(state, action) {
      switch (action.type) {
        case 'SELECT_DIFFICULTY': {
          return {
            ...state,
            difficulty: action.difficulty,
            screen: 'starter'
          };
        }

        case 'SELECT_STARTER': {
          const starterData = STARTERS[action.starter];
          const newCreature = {
            ...starterData,
            hp: starterData.maxHp,
            stamina: starterData.maxStamina,
            scars: [],
            winded: false,
            isGuarding: false,
            burnTurns: 0,
            poisonTurns: 0,
            chillTurns: 0
          };
          // Show prologue on first playthrough
          const nextScreen = state.hasSeenPrologue ? 'exploration' : 'prologue';
          return {
            ...state,
            screen: nextScreen,
            team: [newCreature]
          };
        }

        case 'CONTINUE_FROM_PROLOGUE': {
          return {
            ...state,
            screen: 'exploration',
            hasSeenPrologue: true
          };
        }

        case 'EXAMINE_TILE': {
          const key = `${state.playerPos.x},${state.playerPos.y}`;
          const lore = TILE_LORE[state.currentMap]?.[key];
          if (lore) {
            return {
              ...state,
              examineText: lore
            };
          }
          return state;
        }

        case 'CLOSE_EXAMINE': {
          return {
            ...state,
            examineText: null
          };
        }

        case 'MOVE_PLAYER': {
          const map = state.currentMap === 'ashenPath' ? ASHEN_PATH :
                      state.currentMap === 'hollowDeep' ? HOLLOW_DEEP : FALLEN_KEEP;
          const newX = state.playerPos.x + action.dx;
          const newY = state.playerPos.y + action.dy;

          // Determine direction
          let dir = state.playerDir;
          if (action.dy < 0) dir = 'up';
          else if (action.dy > 0) dir = 'down';
          else if (action.dx < 0) dir = 'left';
          else if (action.dx > 0) dir = 'right';

          if (newY < 0 || newY >= map.length || newX < 0 || newX >= map[0].length) {
            return { ...state, playerDir: dir };
          }

          const tile = map[newY][newX];

          if (tile === 'W') return { ...state, playerDir: dir };

          let newState = { ...state, playerPos: { x: newX, y: newY }, playerDir: dir, bonfireMenuOpen: false };

          if (tile === 'G' && (state.currentMap === 'ashenPath' || state.currentMap === 'hollowDeep')) {
            const encounter = state.grassEncounters.find(
              e => e.x === newX && e.y === newY && e.map === state.currentMap && e.active
            );
            if (encounter && !encounter.alerted && Math.random() < 0.6) {
              const wildData = state.currentMap === 'hollowDeep' ? getRandomDeepWild() : getRandomWild();
              // Apply scar penalties if pre-scarred
              let actualMaxHp = wildData.maxHp;
              let actualMaxStamina = wildData.maxStamina;
              if (wildData.scars) {
                wildData.scars.forEach(scar => {
                  if (scar.effect === 'maxHp') actualMaxHp = Math.max(15, actualMaxHp + scar.value);
                  if (scar.effect === 'maxStamina') actualMaxStamina = Math.max(8, actualMaxStamina + scar.value);
                });
              }
              // Show pre-battle preview instead of immediately starting battle
              newState = {
                ...newState,
                screen: 'encounterPreview',
                pendingEncounter: {
                  wildData,
                  actualMaxHp,
                  actualMaxStamina,
                  encounter: { x: newX, y: newY }
                }
              };
            }
          }

          if (tile === 'X') {
            newState = {
              ...newState,
              currentMap: 'fallenKeep',
              playerPos: { x: 2, y: 7 }
            };
          }

          if (tile === 'E' && state.currentMap === 'fallenKeep') {
            newState = {
              ...newState,
              currentMap: 'ashenPath',
              playerPos: { x: 4, y: 4 }
            };
          }

          if (tile === 'K' && state.currentMap === 'fallenKeep' && !state.bossDefeated) {
            const bossData = BOSS.obsidianHound;
            const difficulty = getDifficulty(state);
            const bossMaxHp = Math.floor(bossData.maxHp * difficulty.bossHpMult);
            newState = {
              ...newState,
              screen: 'battle',
              enemy: {
                ...bossData,
                maxHp: bossMaxHp,
                hp: bossMaxHp,
                stamina: bossData.maxStamina,
                winded: false,
                isGuarding: false
              },
              enemyCreature: { ...bossData, maxHp: bossMaxHp },
              battleLog: [
                'Keeper Varek blocks your path!',
                ...BOSS_DIALOGUE.intro
              ],
              turnPhase: 'player',
              bossPhase: 1,
              arenaEffect: null,
              isBossFight: true
            };
          }

          // Enter The Hollow Deep after defeating Varek
          if (tile === 'K' && state.currentMap === 'fallenKeep' && state.bossDefeated && !state.hollowWardenDefeated) {
            newState = {
              ...newState,
              currentMap: 'hollowDeep',
              playerPos: { x: 3, y: 7 }
            };
          }

          // Exit The Hollow Deep back to Fallen Keep
          if (tile === 'E' && state.currentMap === 'hollowDeep') {
            newState = {
              ...newState,
              currentMap: 'fallenKeep',
              playerPos: { x: 1, y: 6 }
            };
          }

          // Hollow Warden boss fight
          if (tile === 'K' && state.currentMap === 'hollowDeep' && !state.hollowWardenDefeated) {
            const bossData = BOSS.hollowWarden;
            const difficulty = getDifficulty(state);
            const bossMaxHp = Math.floor(bossData.maxHp * difficulty.bossHpMult);
            newState = {
              ...newState,
              screen: 'battle',
              enemy: {
                ...bossData,
                maxHp: bossMaxHp,
                hp: bossMaxHp,
                stamina: bossData.maxStamina,
                winded: false,
                isGuarding: false
              },
              enemyCreature: { ...bossData, maxHp: bossMaxHp },
              battleLog: [
                'The Hollow Warden awakens!',
                ...HOLLOW_WARDEN_DIALOGUE.intro
              ],
              turnPhase: 'player',
              bossPhase: 1,
              arenaEffect: null,
              isBossFight: true,
              isHollowWardenFight: true
            };
          }

          if (state.droppedSouls &&
              state.droppedSouls.map === state.currentMap &&
              state.droppedSouls.pos.x === newX &&
              state.droppedSouls.pos.y === newY) {
            newState = {
              ...newState,
              souls: state.souls + state.droppedSouls.amount,
              droppedSouls: null,
              battleLog: [`Recovered ${state.droppedSouls.amount} souls!`]
            };
          }

          if (state.currentMap === 'fallenKeep' && newY <= 3) {
            newState.shortcutUnlocked = true;
          }

          return newState;
        }

        case 'INTERACT_BONFIRE': {
          // Toggle bonfire menu
          return {
            ...state,
            bonfireMenuOpen: !state.bonfireMenuOpen
          };
        }

        case 'REST_AT_BONFIRE': {
          const difficulty = getDifficulty(state);

          const team = state.team.map(creature => {
            const baseData = STARTERS[creature.id];
            // Clear scars on Ashen difficulty
            const scars = difficulty.scarsHealAtBonfire ? [] : creature.scars;
            const creatureWithScars = { ...creature, scars };
            const { maxHp, maxStamina } = applyScars(creatureWithScars, baseData, difficulty.hollowedThreshold);

            // Broken difficulty: bonfire doesn't heal HP
            if (!difficulty.bonfireHeals) {
              return {
                ...creature,
                scars,
                stamina: maxStamina,
                winded: false,
                burnTurns: 0,
                poisonTurns: 0,
                chillTurns: 0
              };
            }

            return {
              ...creature,
              scars,
              hp: creature.hp === 0 ? 1 : maxHp,
              stamina: maxStamina,
              winded: false,
              burnTurns: 0,
              poisonTurns: 0,
              chillTurns: 0
            };
          });

          const grassEncounters = state.grassEncounters.map(e => ({ ...e, active: true }));

          const saveMessage = difficulty.bonfireHeals
            ? 'Bonfire lit. Progress saved.'
            : 'Bonfire lit. Progress saved. No healing.';

          const newState = {
            ...state,
            team,
            grassEncounters,
            bankedSouls: state.bankedSouls + state.souls,
            souls: 0,
            lastBonfire: { map: state.currentMap, pos: { ...state.playerPos } },
            bonfireMenuOpen: false,
            saveNotification: saveMessage
          };

          // Auto-save when resting
          saveGame(newState);

          return newState;
        }

        case 'CLEAR_NOTIFICATION': {
          return {
            ...state,
            saveNotification: null
          };
        }

        case 'SWITCH_ACTIVE_AT_BONFIRE': {
          // Can only switch to creatures with HP > 0
          const targetCreature = state.team[action.index];
          if (!targetCreature || targetCreature.hp <= 0) {
            return state;
          }
          return {
            ...state,
            activeCreatureIndex: action.index,
            bonfireMenuOpen: false
          };
        }

        case 'CLOSE_BONFIRE_MENU': {
          return {
            ...state,
            bonfireMenuOpen: false
          };
        }

        case 'SELECT_MOVE': {
          const activeCreature = state.team[state.activeCreatureIndex];
          const move = action.move;

          if (move.cost > activeCreature.stamina) return state;

          let newTeam = [...state.team];
          let newEnemy = { ...state.enemy };
          let log = [...state.battleLog];
          let turnPhase = 'enemy';

          if (move.effect === 'rest') {
            newTeam[state.activeCreatureIndex] = {
              ...activeCreature,
              stamina: Math.min(activeCreature.stamina + 8 + 4,
                applyScars(activeCreature, STARTERS[activeCreature.id]).maxStamina),
              winded: false,
              isGuarding: false
            };
            log.push(`${activeCreature.nickname || activeCreature.name} rests and recovers stamina.`);
            return { ...state, team: newTeam, battleLog: log, turnPhase };
          }

          // Purifying Light - removes all status effects and heals
          if (move.effect === 'purify') {
            const baseData = STARTERS[activeCreature.id];
            const { maxHp } = applyScars(activeCreature, baseData);
            newTeam[state.activeCreatureIndex] = {
              ...activeCreature,
              hp: Math.min(activeCreature.hp + (move.healAmount || 10), maxHp),
              stamina: activeCreature.stamina - move.cost,
              burnTurns: 0,
              poisonTurns: 0,
              chillTurns: 0,
              winded: false,
              isGuarding: false
            };
            log.push(`${activeCreature.nickname || activeCreature.name} used ${move.name}!`);
            log.push(`${activeCreature.nickname || activeCreature.name} is purified and healed!`);
            if (newTeam[state.activeCreatureIndex].stamina < 5) {
              newTeam[state.activeCreatureIndex].winded = true;
              log.push(`${activeCreature.nickname || activeCreature.name} is winded!`);
            }
            return { ...state, team: newTeam, battleLog: log, turnPhase };
          }

          if (move.effect === 'guard') {
            newTeam[state.activeCreatureIndex] = {
              ...activeCreature,
              stamina: activeCreature.stamina - move.cost,
              isGuarding: true
            };
            log.push(`${activeCreature.nickname || activeCreature.name} takes a defensive stance.`);

            if (activeCreature.stamina - move.cost < 5) {
              newTeam[state.activeCreatureIndex].winded = true;
              log.push(`${activeCreature.nickname || activeCreature.name} is winded!`);
            }

            return { ...state, team: newTeam, battleLog: log, turnPhase };
          }

          const damage = calculateDamage(move, activeCreature, newEnemy,
            STARTERS[activeCreature.id], state.enemyCreature);

          newEnemy.hp = Math.max(0, newEnemy.hp - damage);
          newEnemy.isGuarding = false;

          const effectiveness = TYPE_CHART[STARTERS[activeCreature.id].type][state.enemyCreature.type];
          let effectText = '';
          if (effectiveness > 1) effectText = " It's super effective!";
          if (effectiveness < 1) effectText = " It's not very effective...";

          log.push(`${activeCreature.nickname || activeCreature.name} used ${move.name}! ${damage} damage.${effectText}`);

          // Apply status effects to enemy based on move
          if (move.effect && move.effectChance && Math.random() * 100 < move.effectChance) {
            if (move.effect === 'burn' && (!newEnemy.burnTurns || newEnemy.burnTurns === 0)) {
              newEnemy.burnTurns = 2;
              log.push(`${state.enemyCreature.name} is burning!`);
            }
            if (move.effect === 'poison' && (!newEnemy.poisonTurns || newEnemy.poisonTurns === 0)) {
              newEnemy.poisonTurns = 3;
              log.push(`${state.enemyCreature.name} is poisoned!`);
            }
            if (move.effect === 'chill' && (!newEnemy.chillTurns || newEnemy.chillTurns === 0)) {
              newEnemy.chillTurns = 2;
              log.push(`${state.enemyCreature.name} is chilled!`);
            }
          }

          // Void Drain - drains stamina from enemy and heals self
          if (move.effect === 'drain') {
            const drainAmount = move.drainStamina || 4;
            const healAmount = move.drainHp || 4;
            newEnemy.stamina = Math.max(0, newEnemy.stamina - drainAmount);
            const baseData = STARTERS[activeCreature.id];
            const { maxHp } = applyScars(activeCreature, baseData);
            newTeam[state.activeCreatureIndex] = {
              ...newTeam[state.activeCreatureIndex],
              hp: Math.min(activeCreature.hp + healAmount, maxHp)
            };
            log.push(`${activeCreature.nickname || activeCreature.name} drains ${drainAmount} stamina and heals ${healAmount} HP!`);
          }

          newTeam[state.activeCreatureIndex] = {
            ...newTeam[state.activeCreatureIndex],
            stamina: activeCreature.stamina - move.cost,
            isGuarding: false
          };

          if (newTeam[state.activeCreatureIndex].stamina < 5) {
            newTeam[state.activeCreatureIndex].winded = true;
            log.push(`${activeCreature.nickname || activeCreature.name} is winded!`);
          }

          if (state.isBossFight && state.bossPhase === 1 &&
              newEnemy.hp <= state.enemyCreature.maxHp * 0.3 && newEnemy.hp > 0) {
            const difficulty = getDifficulty(state);
            // Broken difficulty: no phase transition pause (boss still transforms but no HP recovery)
            if (difficulty.bossPhaseTransition) {
              newEnemy.hp += state.isHollowWardenFight ? 25 : 20;
            }

            if (state.isHollowWardenFight) {
              HOLLOW_WARDEN_DIALOGUE.phase2.forEach(line => log.push(line));
              log.push('The Hollow Warden fractures! Light and dark merge into chaos!');
              return {
                ...state,
                team: newTeam,
                enemy: newEnemy,
                enemyCreature: { ...state.enemyCreature, type: 'darklight' },
                battleLog: log,
                bossPhase: 2,
                arenaEffect: 'fracturedAura',
                turnPhase
              };
            } else {
              BOSS_DIALOGUE.phase2.forEach(line => log.push(line));
              log.push('Obsidian Hound transforms! The arena ignites with scorched earth!');
              return {
                ...state,
                team: newTeam,
                enemy: newEnemy,
                battleLog: log,
                bossPhase: 2,
                arenaEffect: 'scorchedEarth',
                turnPhase
              };
            }
          }

          if (newEnemy.hp <= 0) {
            const soulsEarned = state.enemyCreature.souls || 10;
            log.push(`${state.enemyCreature.name} defeated! Gained ${soulsEarned} souls.`);

            if (state.isBossFight) {
              return {
                ...state,
                screen: 'victory',
                souls: state.souls + soulsEarned,
                bossDefeated: state.isHollowWardenFight ? state.bossDefeated : true,
                hollowWardenDefeated: state.isHollowWardenFight ? true : state.hollowWardenDefeated,
                team: newTeam,
                battleLog: log
              };
            }

            const grassEncounters = state.grassEncounters.map(e =>
              e.x === state.currentEncounter?.x && e.y === state.currentEncounter?.y
                ? { ...e, active: false }
                : e
            );

            return {
              ...state,
              screen: 'exploration',
              souls: state.souls + soulsEarned,
              enemy: null,
              enemyCreature: null,
              team: newTeam,
              battleLog: log,
              grassEncounters
            };
          }

          return { ...state, team: newTeam, enemy: newEnemy, battleLog: log, turnPhase };
        }

        case 'BIND_ATTEMPT': {
          // Can't bind bosses
          if (state.isBossFight) {
            return { ...state, battleLog: [...state.battleLog, "Can't bind a boss!"] };
          }

          // Check if team is full
          if (state.team.length >= MAX_TEAM_SIZE) {
            return { ...state, battleLog: [...state.battleLog, "Team is full!"] };
          }

          // Check if can afford
          if (state.souls < BIND_COST) {
            return { ...state, battleLog: [...state.battleLog, "Not enough souls!"] };
          }

          let log = [...state.battleLog];
          const difficulty = getDifficulty(state);
          const captureChance = getCaptureChance(state.enemy.hp, state.enemy.maxHp, difficulty.captureBonus);
          const roll = Math.random() * 100;

          log.push(`Attempting soul bind... (${captureChance}% chance)`);

          // Deduct souls regardless of outcome
          const newSouls = state.souls - BIND_COST;

          if (roll < captureChance) {
            // SUCCESS! Creature joins team
            const capturedCreature = {
              id: state.enemyCreature.id.replace('wild', '').toLowerCase(),
              name: state.enemyCreature.name.replace('Wild ', ''),
              type: state.enemyCreature.type,
              maxHp: state.enemy.maxHp,
              maxStamina: state.enemy.maxStamina,
              hp: state.enemy.hp,
              stamina: state.enemy.stamina,
              scars: state.enemy.scars || [],
              winded: false,
              isGuarding: false,
              burnTurns: 0,
              poisonTurns: 0,
              chillTurns: 0,
              moves: []
            };

            // Fix the id and moves to match STARTERS based on type
            const typeToStarter = {
              fire: 'cindrath',
              water: 'marshveil',
              grass: 'thornwick',
              dark: 'umbravine',
              light: 'solrath'
            };
            capturedCreature.id = typeToStarter[state.enemyCreature.type] || 'cindrath';
            capturedCreature.moves = STARTERS[capturedCreature.id].moves;
            capturedCreature.nickname = null; // Will be set in nickname screen

            log.push(`Success! ${capturedCreature.name} joined your team!`);

            const grassEncounters = state.grassEncounters.map(e =>
              e.x === state.currentEncounter?.x && e.y === state.currentEncounter?.y
                ? { ...e, active: false }
                : e
            );

            // Show nickname prompt
            return {
              ...state,
              screen: 'nickname',
              pendingCreature: capturedCreature,
              souls: newSouls,
              battleLog: log,
              grassEncounters
            };
          } else {
            // FAILED - enemy gets a free attack (moved from below)
            log.push("The binding failed! The creature breaks free!");

            // Enemy retaliates
            return {
              ...state,
              souls: newSouls,
              battleLog: log,
              turnPhase: 'enemy'
            };
          }
        }

        case 'SET_NICKNAME': {
          if (!state.pendingCreature) return state;

          const creature = {
            ...state.pendingCreature,
            nickname: action.nickname || null
          };

          return {
            ...state,
            screen: 'exploration',
            team: [...state.team, creature],
            pendingCreature: null,
            enemy: null,
            enemyCreature: null
          };
        }

        case 'RENAME_CREATURE': {
          const newTeam = [...state.team];
          newTeam[action.index] = {
            ...newTeam[action.index],
            nickname: action.nickname || null
          };
          return {
            ...state,
            team: newTeam
          };
        }


        case 'ENEMY_TURN': {
          let newTeam = [...state.team];
          let newEnemy = { ...state.enemy };
          let log = [...state.battleLog];
          let activeCreature = newTeam[state.activeCreatureIndex];
          const activeBase = STARTERS[activeCreature.id];
          const enemyDifficulty = getDifficulty(state);
          const { maxHp, maxStamina } = applyScars(activeCreature, activeBase, enemyDifficulty.hollowedThreshold);

          activeCreature = {
            ...activeCreature,
            stamina: Math.min(activeCreature.stamina + 4, maxStamina)
          };

          // Process burn damage
          if (activeCreature.burnTurns > 0) {
            activeCreature.hp = Math.max(0, activeCreature.hp - 3);
            activeCreature.burnTurns--;
            log.push(`${activeCreature.nickname || activeCreature.name} takes 3 burn damage!`);
          }

          // Process poison damage
          if (activeCreature.poisonTurns > 0) {
            activeCreature.hp = Math.max(0, activeCreature.hp - 2);
            activeCreature.poisonTurns--;
            log.push(`${activeCreature.nickname || activeCreature.name} takes 2 poison damage!`);
          }

          // Process chill effect (25% chance to skip turn)
          let chillSkip = false;
          if (activeCreature.chillTurns > 0) {
            activeCreature.chillTurns--;
            if (Math.random() < 0.25) {
              chillSkip = true;
              log.push(`${activeCreature.nickname || activeCreature.name} is frozen and can't move!`);
            }
          }

          if (state.arenaEffect === 'scorchedEarth' && activeBase.type !== 'fire') {
            activeCreature.hp = Math.max(0, activeCreature.hp - 2);
            log.push(`Scorched Earth burns ${activeCreature.nickname || activeCreature.name} for 2 damage!`);
          }

          // Fractured Aura damages non-Dark/Light creatures
          if (state.arenaEffect === 'fracturedAura' && activeBase.type !== 'dark' && activeBase.type !== 'light') {
            activeCreature.hp = Math.max(0, activeCreature.hp - 2);
            log.push(`Fractured Aura tears at ${activeCreature.nickname || activeCreature.name} for 2 damage!`);
          }

          newTeam[state.activeCreatureIndex] = activeCreature;

          if (activeCreature.hp <= 0) {
            return handleCreatureFaint(state, newTeam, newEnemy, log);
          }

          newEnemy.stamina = Math.min(newEnemy.stamina + 4, state.enemyCreature.maxStamina);
          newEnemy.winded = false;

          // Process enemy status effects
          if (newEnemy.burnTurns > 0) {
            newEnemy.hp = Math.max(0, newEnemy.hp - 3);
            newEnemy.burnTurns--;
            log.push(`${state.enemyCreature.name} takes 3 burn damage!`);
          }
          if (newEnemy.poisonTurns > 0) {
            newEnemy.hp = Math.max(0, newEnemy.hp - 2);
            newEnemy.poisonTurns--;
            log.push(`${state.enemyCreature.name} takes 2 poison damage!`);
          }

          // Check if enemy died from status effects
          if (newEnemy.hp <= 0) {
            const soulsEarned = state.enemyCreature.souls || 10;
            log.push(`${state.enemyCreature.name} defeated! Gained ${soulsEarned} souls.`);
            if (state.isBossFight) {
              return {
                ...state,
                screen: 'victory',
                souls: state.souls + soulsEarned,
                bossDefeated: state.isHollowWardenFight ? state.bossDefeated : true,
                hollowWardenDefeated: state.isHollowWardenFight ? true : state.hollowWardenDefeated,
                team: newTeam,
                battleLog: log
              };
            }
            return {
              ...state,
              screen: 'exploration',
              souls: state.souls + soulsEarned,
              enemy: null,
              team: newTeam,
              battleLog: log
            };
          }

          // Get available moves based on boss type and phase
          let bossData = state.isHollowWardenFight ? BOSS.hollowWarden : BOSS.obsidianHound;
          let availableMoves = (state.bossPhase === 2 ?
            bossData.phase2Moves : state.enemyCreature.moves)
            .filter(m => m.cost <= newEnemy.stamina);

          if (availableMoves.length === 0) {
            availableMoves = [{ name: 'Rest', cost: 0, damage: 0, effect: 'rest' }];
          }

          let selectedMove;
          if (state.isBossFight) {
            const playerHpPercent = activeCreature.hp / maxHp;
            if (state.isHollowWardenFight) {
              // Hollow Warden AI
              if (state.bossPhase === 2 && playerHpPercent < 0.4) {
                const despVoid = availableMoves.find(m => m.name === 'Desperate Void');
                if (despVoid) selectedMove = despVoid;
              }
              if (!selectedMove && activeCreature.stamina > 12) {
                const voidGrasp = availableMoves.find(m => m.name === 'Void Grasp');
                if (voidGrasp) selectedMove = voidGrasp;
              }
            } else {
              // Obsidian Hound AI
              if (state.bossPhase === 2 && playerHpPercent < 0.4) {
                const despFang = availableMoves.find(m => m.name === 'Desperation Fang');
                if (despFang) selectedMove = despFang;
              }
              if (!selectedMove && playerHpPercent > 0.7) {
                const flameWall = availableMoves.find(m => m.name === 'Flame Wall');
                if (flameWall) selectedMove = flameWall;
              }
            }
          }

          if (!selectedMove) {
            const attackMoves = availableMoves.filter(m => m.damage > 0);
            selectedMove = attackMoves.length > 0
              ? attackMoves[Math.floor(Math.random() * attackMoves.length)]
              : availableMoves[0];
          }

          if (selectedMove.effect === 'rest') {
            newEnemy.stamina = Math.min(newEnemy.stamina + 8, state.enemyCreature.maxStamina);
            log.push(`${state.enemyCreature.name} rests.`);
          } else if (selectedMove.effect === 'guard') {
            newEnemy.isGuarding = true;
            newEnemy.stamina -= selectedMove.cost;
            log.push(`${state.enemyCreature.name} guards.`);
          } else {
            const difficulty = getDifficulty(state);
            const damageMult = state.isBossFight ? difficulty.bossDamageMult : difficulty.wildDamageMult;
            const damage = calculateDamage(selectedMove, newEnemy, activeCreature,
              state.enemyCreature, activeBase, damageMult);

            activeCreature.hp = Math.max(0, activeCreature.hp - damage);
            activeCreature.isGuarding = false;
            newEnemy.stamina -= selectedMove.cost;

            log.push(`${state.enemyCreature.name} used ${selectedMove.name}! ${damage} damage.`);

            // Apply status effects from enemy attacks
            if (selectedMove.effect === 'burn' && (!activeCreature.burnTurns || activeCreature.burnTurns === 0)) {
              activeCreature.burnTurns = 2;
              log.push(`${activeCreature.nickname || activeCreature.name} is burning!`);
            }
            if (selectedMove.effect === 'poison' && (!activeCreature.poisonTurns || activeCreature.poisonTurns === 0)) {
              activeCreature.poisonTurns = 3;
              log.push(`${activeCreature.nickname || activeCreature.name} is poisoned!`);
            }
            if (selectedMove.effect === 'chill' && (!activeCreature.chillTurns || activeCreature.chillTurns === 0)) {
              activeCreature.chillTurns = 2;
              log.push(`${activeCreature.nickname || activeCreature.name} is chilled!`);
            }

            if (selectedMove.effect === 'recoil') {
              newEnemy.hp = Math.max(0, newEnemy.hp - selectedMove.recoilDamage);
              log.push(`${state.enemyCreature.name} takes ${selectedMove.recoilDamage} recoil!`);
            }

            // Void Grasp drains stamina
            if (selectedMove.effect === 'drainStamina') {
              activeCreature.stamina = Math.max(0, activeCreature.stamina - selectedMove.drainAmount);
              log.push(`${activeCreature.nickname || activeCreature.name} loses ${selectedMove.drainAmount} stamina!`);
            }

            if (newEnemy.stamina < 5) {
              newEnemy.winded = true;
              log.push(`${state.enemyCreature.name} is winded!`);
            }
          }

          newTeam[state.activeCreatureIndex] = activeCreature;

          if (newEnemy.hp <= 0) {
            const soulsEarned = state.enemyCreature.souls || 10;
            log.push(`${state.enemyCreature.name} defeated! Gained ${soulsEarned} souls.`);

            if (state.isBossFight) {
              return {
                ...state,
                screen: 'victory',
                souls: state.souls + soulsEarned,
                bossDefeated: state.isHollowWardenFight ? state.bossDefeated : true,
                hollowWardenDefeated: state.isHollowWardenFight ? true : state.hollowWardenDefeated,
                team: newTeam,
                battleLog: log
              };
            }

            return {
              ...state,
              screen: 'exploration',
              souls: state.souls + soulsEarned,
              enemy: null,
              team: newTeam,
              battleLog: log
            };
          }

          if (activeCreature.hp <= 0) {
            return handleCreatureFaint(state, newTeam, newEnemy, log);
          }

          return {
            ...state,
            team: newTeam,
            enemy: newEnemy,
            battleLog: log,
            turnPhase: 'player'
          };
        }

        case 'SWITCH_CREATURE': {
          if (state.team[action.index].hp <= 0) return state;
          return {
            ...state,
            activeCreatureIndex: action.index,
            battleLog: [...state.battleLog, `Go, ${state.team[action.index].name}!`]
          };
        }

        case 'RESPAWN': {
          const respawnDifficulty = getDifficulty(state);
          const team = state.team.map(creature => {
            const baseData = STARTERS[creature.id];
            const { maxHp, maxStamina } = applyScars(creature, baseData, respawnDifficulty.hollowedThreshold);
            return {
              ...creature,
              hp: creature.hp === 0 ? 1 : Math.max(creature.hp, 1),
              stamina: maxStamina,
              winded: false,
              burnTurns: 0,
              isGuarding: false
            };
          });

          return {
            ...state,
            screen: 'exploration',
            currentMap: state.lastBonfire.map,
            playerPos: { ...state.lastBonfire.pos },
            team,
            activeCreatureIndex: team.findIndex(c => c.hp > 0) || 0,
            enemy: null,
            enemyCreature: null,
            battleLog: [],
            turnPhase: 'player',
            bossPhase: 1,
            arenaEffect: null,
            isBossFight: false,
            diedToBoss: false
          };
        }

        case 'RESTART': {
          return {
            ...initialState,
            hasSeenPrologue: true // Skip prologue on subsequent playthroughs
          };
        }

        case 'SHOW_CREDITS': {
          return {
            ...state,
            screen: 'credits'
          };
        }

        case 'RETURN_TO_TITLE': {
          return initialState;
        }

        case 'MANUAL_SAVE': {
          const success = saveGame(state);
          return {
            ...state,
            saveNotification: success ? 'Progress saved.' : 'Save failed!'
          };
        }

        case 'LOAD_GAME': {
          const saveData = action.saveData;
          if (!saveData) return state;

          return {
            ...initialState,
            screen: 'exploration',
            difficulty: saveData.difficulty || 'scarred',
            currentMap: saveData.currentMap,
            playerPos: saveData.playerPos,
            playerDir: saveData.playerDir,
            team: saveData.team,
            activeCreatureIndex: saveData.activeCreatureIndex,
            souls: saveData.souls,
            bankedSouls: saveData.bankedSouls,
            droppedSouls: saveData.droppedSouls,
            bossDefeated: saveData.bossDefeated,
            hollowWardenDefeated: saveData.hollowWardenDefeated || false,
            shortcutUnlocked: saveData.shortcutUnlocked,
            grassEncounters: saveData.grassEncounters,
            lastBonfire: saveData.lastBonfire,
            hasSeenPrologue: saveData.hasSeenPrologue,
            playTime: saveData.playTime || 0,
            saveNotification: 'Journey resumed.'
          };
        }

        case 'NEW_GAME_CONFIRMED': {
          deleteSaveData();
          return initialState;
        }

        case 'UPDATE_PLAY_TIME': {
          return {
            ...state,
            playTime: state.playTime + action.delta
          };
        }

        default:
        case 'CONFIRM_ENCOUNTER': {
          if (!state.pendingEncounter) return state;
          const { wildData, actualMaxHp, actualMaxStamina, encounter } = state.pendingEncounter;
          return {
            ...state,
            screen: 'battle',
            enemy: {
              ...wildData,
              maxHp: actualMaxHp,
              maxStamina: actualMaxStamina,
              hp: actualMaxHp,
              stamina: wildData.maxStamina,
              winded: false,
              isGuarding: false
            },
            enemyCreature: wildData,
            battleLog: [`A ${wildData.name} appeared!`],
            turnPhase: 'player',
            currentEncounter: encounter,
            pendingEncounter: null
          };
        }

        case 'FLEE_ENCOUNTER': {
          if (!state.pendingEncounter) return state;
          const { encounter } = state.pendingEncounter;
          // Mark grass as alerted - can't flee twice
          const grassEncounters = state.grassEncounters.map(e =>
            e.x === encounter.x && e.y === encounter.y && e.map === state.currentMap
              ? { ...e, alerted: true }
              : e
          );
          return {
            ...state,
            screen: 'exploration',
            pendingEncounter: null,
            grassEncounters
          };
        }

          return state;
      }
    }

    function DifficultySelect({ dispatch, onShowStats }) {
      const difficultyInfo = {
        ashen: [
          ' Wild damage reduced 50%',
          ' Scars heal at bonfire',
          ' Souls only drop 50% on death',
          ' Capture chance +20%'
        ],
        scarred: [
          ' Standard damage (wild -25%)',
          ' Permanent scars',
          ' Full soul drop on death',
          ' Standard capture rates'
        ],
        hollowed: [
          ' Full damage from all enemies',
          ' Worse scar penalties (-7 HP, -3 STA)',
          ' Drop ALL souls including banked',
          ' Capture chance -20%',
          ' Boss has 25% more HP'
        ],
        broken: [
          ' All Hollowed settings plus:',
          ' No bonfire healing (save only)',
          ' One scar = Hollowed status',
          ' Boss has no phase pause',
          ' PERMADEATH: Save deleted on wipe'
        ]
      };

      return (
        <div style={styles.difficultySelect}>
          <h1 style={{ color: GBC.textDim, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-2xl)' }}>POKE SOULS</h1>
          <div style={styles.difficultyTitle}>CHOOSE YOUR FATE</div>

          {Object.values(DIFFICULTIES).map(diff => (
            <div
              key={diff.id}
              style={styles.difficultyCard}
              onClick={() => dispatch({ type: 'SELECT_DIFFICULTY', difficulty: diff.id })}
              onMouseOver={e => {
                const colors = { ashen: GBC.gold, scarred: GBC.textDim, hollowed: GBC.red, broken: '#8b0000' };
                e.currentTarget.style.borderColor = colors[diff.id] || GBC.border;
              }}
              onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
            >
              <div style={styles.difficultyHeader}>
                <span style={styles.difficultyIcon}>{diff.icon}</span>
                <span style={styles.difficultyName}>{diff.name}</span>
                <span style={styles.difficultySubtitle}>({diff.subtitle})</span>
              </div>
              <div style={styles.difficultyDesc}>"{diff.description}"</div>
              <div style={styles.difficultyDetails}>
                {difficultyInfo[diff.id].map((line, i) => (
                  <div key={i}>{line}</div>
                ))}
              </div>
            </div>
          ))}

          <button
            style={{
              ...styles.button,
              marginTop: 'var(--spacing-lg)',
              padding: 'var(--spacing-sm) var(--spacing-xl)'
            }}
            onClick={onShowStats}
          >
            STATS
          </button>
        </div>
      );
    }

    function DifficultyIndicator({ difficulty }) {
      const diff = DIFFICULTIES[difficulty] || DIFFICULTIES.scarred;
      return (
        <div style={styles.difficultyIndicator}>
          <span>{diff.icon}</span>
          <span style={styles.difficultyIndicatorName}>{diff.name}</span>
        </div>
      );
    }

    function StarterSelect({ dispatch }) {
      return (
        <div style={styles.starterSelect}>
          <h1 style={{ color: GBC.textDim, marginBottom: 'var(--spacing-sm)', fontSize: 'var(--font-2xl)' }}>POKE SOULS</h1>
          <p style={{ color: GBC.text, marginBottom: 'var(--spacing-lg)', fontSize: 'var(--font-sm)' }}>Choose your survivor</p>
          <div>
            {Object.values(STARTERS).map(starter => (
              <div
                key={starter.id}
                style={styles.starterCard}
                onClick={() => dispatch({ type: 'SELECT_STARTER', starter: starter.id })}
                onMouseOver={e => e.currentTarget.style.borderColor = getTypeColor(starter.type)}
                onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
              >
                <div style={{ display: 'flex', justifyContent: 'center', marginBottom: 'var(--spacing-sm)' }}>
                  <CreatureSprite type={starter.type} size={48} />
                </div>
                <div style={{ margin: 'var(--spacing-sm) 0 var(--spacing-xs)', color: GBC.text, fontSize: 'var(--font-base)' }}>{starter.name}</div>
                <div style={{ fontSize: 'var(--font-sm)', color: getTypeColor(starter.type), margin: 'var(--spacing-xs) 0' }}>
                  {starter.type.toUpperCase()}
                </div>
                <div style={{ fontSize: 'var(--font-xs)', color: GBC.textDim }}>
                  HP {starter.maxHp}
                </div>
                <div style={{ fontSize: 'var(--font-xs)', color: GBC.textDim }}>
                  STA {starter.maxStamina}
                </div>
                <div style={{ fontSize: 'var(--font-xs)', color: getTypeColor(starter.type), marginTop: 'var(--spacing-xs)' }}>
                  {starter.moves[0].name}
                </div>
              </div>
            ))}
          </div>
        </div>
      );
    }

    function Exploration({ state, dispatch }) {
      const map = state.currentMap === 'ashenPath' ? ASHEN_PATH : state.currentMap === 'hollowDeep' ? HOLLOW_DEEP : FALLEN_KEEP;
      const mapName = state.currentMap === 'ashenPath' ? 'Ashen Path' : 'Fallen Keep';

      const handleKeyDown = useCallback((e) => {
        const key = e.key.toLowerCase();
        let dx = 0, dy = 0;

        // Close examine overlay first if open
        if (state.examineText && (key === 'x' || key === 'escape' || key === 'enter' || key === 'e')) {
          dispatch({ type: 'CLOSE_EXAMINE' });
          return;
        }

        if (key === 'arrowup' || key === 'w') dy = -1;
        else if (key === 'arrowdown' || key === 's') dy = 1;
        else if (key === 'arrowleft' || key === 'a') dx = -1;
        else if (key === 'arrowright' || key === 'd') dx = 1;
        else if (key === 'e' || key === 'enter') {
          const tile = map[state.playerPos.y][state.playerPos.x];
          if (tile === 'B') {
            dispatch({ type: 'INTERACT_BONFIRE' });
          }
          return;
        }
        else if (key === 'x') {
          dispatch({ type: 'EXAMINE_TILE' });
          return;
        }

        if (dx !== 0 || dy !== 0) {
          dispatch({ type: 'MOVE_PLAYER', dx, dy });
        }
      }, [dispatch, map, state.playerPos, state.examineText]);

      useEffect(() => {
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [handleKeyDown]);

      const currentTile = map[state.playerPos.y][state.playerPos.x];

      // Render tile background
      const renderTileBackground = (tile) => {
        switch(tile) {
          case 'W': return <WallTile />;
          case 'P': return <PathTile />;
          case 'G': return <GrassTile />;
          case 'B': return <BonfireTile />;
          case 'X': return <GateTile />;
          case 'E': return <GateTile isKeep={true} />;
          case 'K': return <BossRoomTile />;
          default: return <PathTile />;
        }
      };

      return (
        <div>
          <div style={styles.header}>
            <span style={styles.souls}>SOULS {state.souls}</span>
            <span style={{ color: GBC.textDim }}>{mapName}</span>
            <span style={{ color: GBC.textDim, fontSize: 'var(--font-sm)' }}>TEAM {state.team.length}/{MAX_TEAM_SIZE}</span>
          </div>

          <div style={styles.mapContainer}>
            <div style={{
              ...styles.grid,
              gridTemplateColumns: `repeat(${map[0].length}, var(--tile-size))`
            }}>
              {map.map((row, y) =>
                row.map((tile, x) => {
                  const isPlayer = x === state.playerPos.x && y === state.playerPos.y;
                  const hasSouls = state.droppedSouls &&
                    state.droppedSouls.map === state.currentMap &&
                    state.droppedSouls.pos.x === x &&
                    state.droppedSouls.pos.y === y;

                  return (
                    <div
                      key={`${x}-${y}`}
                      style={styles.tile}
                    >
                      {renderTileBackground(tile)}
                      {isPlayer && (
                        <div style={{ position: 'absolute', zIndex: 10 }}>
                          <PlayerSprite direction={state.playerDir} />
                        </div>
                      )}
                      {hasSouls && !isPlayer && (
                        <div style={{
                          position: 'absolute',
                          zIndex: 5,
                          display: 'flex',
                          flexDirection: 'column',
                          alignItems: 'center',
                          justifyContent: 'center'
                        }}>
                          <div style={{
                            width: '28px',
                            height: '28px',
                            backgroundColor: GBC.gold,
                            border: '3px solid #744210',
                            animation: 'flicker 1s infinite',
                            boxShadow: '0 0 10px rgba(246, 224, 94, 0.5)'
                          }} />
                          <div style={{
                            fontSize: '8px',
                            color: GBC.gold,
                            fontFamily: '"Press Start 2P", monospace',
                            marginTop: '2px',
                            textShadow: '1px 1px 0 #000'
                          }}>SOULS</div>
                        </div>
                      )}
                    </div>
                  );
                })
              )}
            </div>
          </div>

          {currentTile === 'B' && !state.bonfireMenuOpen && (
            <div style={{
              textAlign: 'center',
              color: GBC.gold,
              marginBottom: 'var(--spacing-sm)',
              padding: 'var(--spacing-xs)',
              backgroundColor: GBC.bgPanel,
              border: `2px solid ${GBC.border}`,
              fontSize: 'var(--font-sm)'
            }}>
              Press E to rest at bonfire
            </div>
          )}

          {state.bonfireMenuOpen && (
            <div style={styles.bonfireMenu}>
              <div style={{ color: GBC.gold, marginBottom: 'var(--spacing-sm)', fontSize: 'var(--font-sm)' }}>BONFIRE</div>

              <div
                style={styles.bonfireOption}
                onClick={() => { playSfx('bonfireRest'); dispatch({ type: 'REST_AT_BONFIRE' }); }}
                onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
                onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
              >
                REST - Heal all, bank souls, respawn enemies
              </div>

              {state.team.length > 1 && (
                <div style={{ marginTop: 'var(--spacing-sm)' }}>
                  <div style={{ color: GBC.textDim, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-xs)' }}>SWITCH ACTIVE:</div>
                  {state.team.map((creature, i) => {
                    const isActive = i === state.activeCreatureIndex;
                    const baseData = STARTERS[creature.id];
                    const { maxHp } = applyScars(creature, baseData);
                    const isAlive = creature.hp > 0;

                    return (
                      <div
                        key={i}
                        style={{
                          ...styles.bonfireOption,
                          opacity: isAlive ? 1 : 0.5,
                          cursor: isAlive && !isActive ? 'pointer' : 'default',
                          borderColor: isActive ? getTypeColor(creature.type) : GBC.border
                        }}
                        onClick={() => {
                          if (isAlive && !isActive) {
                            dispatch({ type: 'SWITCH_ACTIVE_AT_BONFIRE', index: i });
                          }
                        }}
                      >
                        <span style={{ color: getTypeColor(creature.type) }}>{getTypeIcon(creature.type)}</span>
                        {' '}{creature.nickname || creature.name} - {creature.hp}/{maxHp} HP
                        {isActive && <span style={{ color: GBC.gold, marginLeft: '6px' }}>(ACTIVE)</span>}
                        {!isAlive && <span style={{ color: GBC.red, marginLeft: '6px' }}>(FAINTED)</span>}
                        {creature.scars?.length > 0 && (
                          <span style={{ color: GBC.red, marginLeft: '6px' }}>({creature.scars.length} scars)</span>
                        )}
                      </div>
                    );
                  })}
                </div>
              )}

              <div
                style={{ ...styles.bonfireOption, marginTop: '8px', color: GBC.textDim }}
                onClick={() => dispatch({ type: 'CLOSE_BONFIRE_MENU' })}
              >
                LEAVE
              </div>
            </div>
          )}

          <TeamStatus team={state.team} activeIndex={state.activeCreatureIndex} bankedSouls={state.bankedSouls} />

          {/* Examine prompt when on lore tile */}
          {(() => {
            const key = `${state.playerPos.x},${state.playerPos.y}`;
            const hasLore = TILE_LORE[state.currentMap]?.[key];
            if (hasLore && !state.examineText) {
              return (
                <div style={{
                  textAlign: 'center',
                  color: GBC.gold,
                  marginBottom: 'var(--spacing-sm)',
                  padding: 'var(--spacing-xs)',
                  backgroundColor: GBC.bgPanel,
                  border: `2px solid ${GBC.border}`,
                  fontSize: 'var(--font-sm)'
                }}>
                  Press X to examine
                </div>
              );
            }
            return null;
          })()}

          {/* Examine overlay */}
          {state.examineText && (
            <div style={styles.examineOverlay} onClick={() => dispatch({ type: 'CLOSE_EXAMINE' })}>
              <div style={styles.examineContent} onClick={e => e.stopPropagation()}>
                <div style={styles.examineTitle}>{state.examineText.name}</div>
                {state.examineText.lines.map((line, i) => (
                  <div key={i} style={styles.examineLine}>{line || '\u00A0'}</div>
                ))}
                <div style={styles.examinePrompt}>[Press X to close]</div>
              </div>
            </div>
          )}

          <div style={{
            padding: 'var(--spacing-xs) var(--spacing-sm)',
            backgroundColor: GBC.bgPanel,
            marginTop: 'var(--spacing-sm)',
            fontSize: 'var(--font-xs)',
            color: GBC.textDim,
            border: `2px solid ${GBC.border}`
          }}>
            WASD: Move | E: Rest | X: Examine | ESC: Menu
          </div>
        </div>
      );
    }

    function TeamStatus({ team, activeIndex, bankedSouls }) {
      return (
        <div style={styles.teamStatus}>
          <div style={{ display: 'flex', justifyContent: 'space-between', margin: '0 0 var(--spacing-xs)' }}>
            <span style={{ color: GBC.textDim, fontSize: 'var(--font-sm)' }}>TEAM</span>
            {bankedSouls !== undefined && (
              <span style={{ color: GBC.gold, fontSize: 'var(--font-xs)' }}>BANKED: {bankedSouls}</span>
            )}
          </div>
          {team.map((creature, i) => {
            const baseData = STARTERS[creature.id];
            const { maxHp, maxStamina } = applyScars(creature, baseData);
            const hpPercent = (creature.hp / maxHp) * 100;
            const staminaPercent = (creature.stamina / maxStamina) * 100;
            const isActive = i === activeIndex;
            const isHollowed = creature.scars && creature.scars.length >= 3;

            return (
              <div
                key={i}
                style={{
                  ...styles.creatureStatus,
                  borderColor: isActive ? getTypeColor(creature.type) : GBC.border,
                  display: 'flex',
                  alignItems: 'center'
                }}
              >
                <div style={styles.creatureSprite}>
                  <CreatureSprite type={creature.type} size={32} />
                </div>
                <div style={{ flex: 1 }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2px' }}>
                    <span style={{ fontSize: 'var(--font-sm)' }}>
                      {creature.name}
                      {isHollowed && <span style={styles.scar}>HOLLOW</span>}
                      {creature.winded && <span style={{ ...styles.status, ...styles.winded }}>WIND</span>}
                      {creature.burnTurns > 0 && (
                        <span style={{ ...styles.status, ...styles.burn }}>BURN</span>
                      )}
                    </span>
                    <span style={{ fontSize: 'var(--font-sm)', color: GBC.textDim }}>
                      {creature.hp}/{maxHp}
                    </span>
                  </div>
                  <div style={styles.hpBar}>
                    <div style={{
                    ...styles.hpFill,
                    width: `${hpPercent}%`,
                    backgroundColor: hpPercent > 50 ? '#4a4' : hpPercent > 25 ? '#aa4' : '#a44'
                  }} />
                </div>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginTop: '2px' }}>
                    <span style={{ fontSize: 'var(--font-xs)', color: GBC.textDim }}>
                      STA {creature.stamina}/{maxStamina}
                    </span>
                    {creature.scars && creature.scars.length > 0 && (
                      <span>
                        {creature.scars.slice(0, 2).map((scar, j) => (
                          <span key={j} style={styles.scar}>{scar.name.slice(0, 4)}</span>
                        ))}
                        {creature.scars.length > 2 && <span style={styles.scar}>+{creature.scars.length - 2}</span>}
                      </span>
                    )}
                  </div>
                  <div style={styles.staminaBar}>
                    <div style={{
                      ...styles.staminaFill,
                      width: `${staminaPercent}%`
                    }} />
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      );
    }

    // Damage number component for combat juice
    function DamageNumber({ damage, type, position, onComplete }) {
      useEffect(() => {
        const timer = setTimeout(onComplete, 1000);
        return () => clearTimeout(timer);
      }, [onComplete]);

      const colors = {
        normal: '#ffffff',
        effective: '#68d391',
        resisted: '#a0aec0',
        player: '#fc8181'
      };

      return (
        <div style={{
          position: 'absolute',
          top: position === 'enemy' ? '20%' : '60%',
          left: position === 'enemy' ? '70%' : '30%',
          transform: 'translateX(-50%)',
          color: colors[type] || colors.normal,
          fontSize: 'var(--font-lg)',
          fontFamily: '"Press Start 2P", monospace',
          textShadow: '2px 2px 0 #000',
          animation: 'damageNumber 1s ease-out forwards',
          pointerEvents: 'none',
          zIndex: 100
        }}>
          {damage}
        </div>
      );
    }

    function Battle({ state, dispatch }) {
      const activeCreature = state.team[state.activeCreatureIndex];
      const activeBase = STARTERS[activeCreature.id];
      const { maxHp, maxStamina, hasFlinching } = applyScars(activeCreature, activeBase);

      const enemyHpPercent = (state.enemy.hp / state.enemyCreature.maxHp) * 100;
      const playerHpPercent = (activeCreature.hp / maxHp) * 100;
      const prevLogLengthRef = useRef(state.battleLog.length);
      const [damageNumbers, setDamageNumbers] = useState([]);
      const [screenShake, setScreenShake] = useState(false);
      const [criticalFlash, setCriticalFlash] = useState(false);
      const damageIdRef = useRef(0);

      // Play sound effects and visual effects based on battle log changes
      useEffect(() => {
        const newLogs = state.battleLog.slice(prevLogLengthRef.current);
        prevLogLengthRef.current = state.battleLog.length;

        newLogs.forEach(log => {
          // Check for damage messages
          const damageMatch = log.match(/(\d+) damage/);
          if (damageMatch) {
            const damage = parseInt(damageMatch[1]);
            const isEffective = log.includes('super effective');
            const isResisted = log.includes('not very effective');
            const isEnemyDamage = log.includes(state.enemyCreature?.name + ' used');

            // Play sound effects
            if (isEffective) {
              playSfx('critical');
              setCriticalFlash(true);
              setTimeout(() => setCriticalFlash(false), 100);
            } else if (damage >= 15) {
              playSfx('hitHeavy');
              setScreenShake(true);
              setTimeout(() => setScreenShake(false), 200);
            } else if (damage >= 8) {
              playSfx('hitMedium');
            } else {
              playSfx('hitLight');
            }

            // Add damage number
            const dmgType = isEffective ? 'effective' : isResisted ? 'resisted' : isEnemyDamage ? 'player' : 'normal';
            const position = isEnemyDamage ? 'player' : 'enemy';
            const newDamage = {
              id: damageIdRef.current++,
              damage,
              type: dmgType,
              position
            };
            setDamageNumbers(prev => [...prev, newDamage]);
          }

          // Check for status effects
          if (log.includes('is burning')) playSfx('burn');
          if (log.includes('is poisoned')) playSfx('poison');
          if (log.includes('is chilled')) playSfx('chill');
          if (log.includes('poison damage')) playSfx('poison');
          if (log.includes('chill damage') || log.includes('frozen')) playSfx('chill');
          if (log.includes('burn damage')) playSfx('burn');

          // Check for faint
          if (log.includes('has fallen') || log.includes('defeated')) {
            playSfx('faint');
          }

          // Check for souls
          if (log.includes('Gained') && log.includes('souls')) {
            playSfx('soulsGained');
          }

          // Capture attempts
          if (log.includes('Attempting soul bind')) playSfx('bindAttempt');
          if (log.includes('joined your team')) playSfx('captureSuccess');
          if (log.includes('binding failed')) playSfx('captureFail');
        });
      }, [state.battleLog, state.enemyCreature?.name]);

      const removeDamageNumber = useCallback((id) => {
        setDamageNumbers(prev => prev.filter(d => d.id !== id));
      }, []);

      useEffect(() => {
        if (state.turnPhase === 'enemy') {
          const timer = setTimeout(() => {
            dispatch({ type: 'ENEMY_TURN' });
          }, 1000);
          return () => clearTimeout(timer);
        }
      }, [state.turnPhase, dispatch]);

      const getMoveWithPriority = (move) => {
        if (move.priority && hasFlinching) {
          return { ...move, priority: false };
        }
        return move;
      };

      // Keyboard controls for battle
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (state.turnPhase !== 'player') return;

          const moves = activeBase.moves;

          // Number keys 1-4 for moves
          if (e.key >= '1' && e.key <= '4') {
            const moveIndex = parseInt(e.key) - 1;
            if (moveIndex < moves.length) {
              const move = getMoveWithPriority(moves[moveIndex]);
              if (move.cost <= activeCreature.stamina) {
                dispatch({ type: 'SELECT_MOVE', move });
              }
            }
          }

          // B for bind/capture
          if (e.key.toLowerCase() === 'b' && !state.isBossFight) {
            dispatch({ type: 'BIND_ATTEMPT' });
          }

          // Tab to cycle through team
          if (e.key === 'Tab') {
            e.preventDefault();
            const aliveCreatures = state.team
              .map((c, i) => ({ creature: c, index: i }))
              .filter(({ creature, index }) => creature.hp > 0 && index !== state.activeCreatureIndex);
            if (aliveCreatures.length > 0) {
              dispatch({ type: 'SWITCH_CREATURE', index: aliveCreatures[0].index });
            }
          }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [state.turnPhase, state.team, state.activeCreatureIndex, activeBase.moves, activeCreature.stamina, state.isBossFight, dispatch]);

      const enemyType = state.isBossFight ? (state.isHollowWardenFight ? 'hollowWarden' : 'boss') : state.enemyCreature.type;

      return (
        <div style={styles.battleContainer}>
          <div style={styles.header}>
            <span style={styles.souls}>SOULS {state.souls}</span>
            <span style={{ color: state.isBossFight ? GBC.red : GBC.textDim, fontSize: 'var(--font-sm)' }}>
              {state.isBossFight ? 'BOSS' : 'BATTLE'}
            </span>
          </div>

          {state.arenaEffect === 'scorchedEarth' && (
            <div style={{
              textAlign: 'center',
              padding: 'var(--spacing-xs)',
              backgroundColor: '#2a1510',
              color: GBC.fire,
              marginBottom: 'var(--spacing-sm)',
              border: `2px solid ${GBC.fire}`,
              fontSize: 'var(--font-sm)',
              animation: 'flicker 0.5s infinite'
            }}>
              SCORCHED EARTH - 2 DMG/TURN
            </div>
          )}

          {/* Battle sprite arena */}
          <div
            style={styles.battleSpriteArea}
            className={`${screenShake ? 'screen-shake' : ''} ${criticalFlash ? 'critical-flash' : ''}`}
          >
            <div style={{ textAlign: 'center', position: 'relative' }}>
              <CreatureSprite type={activeCreature.type} size={48} />
              <div style={{ fontSize: 'var(--font-xs)', color: GBC.text, marginTop: 'var(--spacing-xs)' }}>
                {activeCreature.nickname || activeCreature.name}
              </div>
            </div>
            <div style={{ fontSize: 'var(--font-xl)', color: GBC.textDim }}>VS</div>
            <div style={{ textAlign: 'center', position: 'relative' }}>
              <CreatureSprite type={enemyType} size={state.isBossFight ? 56 : 48} isEnemy={true} />
              <div style={{ fontSize: 'var(--font-xs)', color: GBC.text, marginTop: 'var(--spacing-xs)' }}>{state.enemyCreature.name}</div>
            </div>
            {/* Damage numbers */}
            {damageNumbers.map(dn => (
              <DamageNumber
                key={dn.id}
                damage={dn.damage}
                type={dn.type}
                position={dn.position}
                onComplete={() => removeDamageNumber(dn.id)}
              />
            ))}
          </div>

          {/* Enemy stats */}
          <div style={styles.battleCreature}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 'var(--spacing-xs)' }}>
              <span style={{ fontSize: 'var(--font-sm)' }}>
                {state.enemyCreature.name}
                {state.bossPhase === 2 && <span style={{ color: GBC.red, marginLeft: 'var(--spacing-xs)' }}>P2</span>}
                {state.enemy.burnTurns > 0 && <span style={{ ...styles.status, ...styles.burn }}>BRN</span>}
                {state.enemy.poisonTurns > 0 && <span style={{ ...styles.status, backgroundColor: '#1a3a1a', border: '2px solid #48bb78', color: '#48bb78' }}>PSN</span>}
                {state.enemy.chillTurns > 0 && <span style={{ ...styles.status, backgroundColor: '#1a2a3a', border: '2px solid #63b3ed', color: '#63b3ed' }}>CHL</span>}
              </span>
              <span style={{ fontSize: 'var(--font-sm)', color: GBC.textDim }}>
                {state.enemy.hp}/{state.enemyCreature.maxHp}
              </span>
            </div>
            <div style={styles.hpBar}>
              <div style={{
                ...styles.hpFill,
                width: `${enemyHpPercent}%`,
                backgroundColor: GBC.red
              }} />
            </div>
            <div style={{ fontSize: 'var(--font-xs)', color: GBC.textDim, marginTop: '3px' }}>
              STA {state.enemy.stamina}/{state.enemyCreature.maxStamina}
              {state.enemy.winded && <span style={{ ...styles.status, ...styles.winded }}>WIND</span>}
              {state.enemy.isGuarding && <span style={{ ...styles.status, backgroundColor: '#1a2a3a', border: `1px solid ${GBC.blue}`, color: GBC.blue }}>GRD</span>}
            </div>
          </div>

          {/* Battle log */}
          <div style={styles.battleAnimation}>
            {state.battleLog.slice(-2).map((log, i) => (
              <div key={i} style={{ marginBottom: '4px' }}>{log}</div>
            ))}
          </div>

          {/* Player stats */}
          <div style={styles.battleCreature}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 'var(--spacing-xs)' }}>
              <span style={{ fontSize: 'var(--font-sm)' }}>
                {activeCreature.nickname || activeCreature.name}
                {activeCreature.winded && <span style={{ ...styles.status, ...styles.winded }}>WIND +25%</span>}
                {activeCreature.burnTurns > 0 && <span style={{ ...styles.status, ...styles.burn }}>BURN</span>}
                {activeCreature.poisonTurns > 0 && <span style={{ ...styles.status, backgroundColor: '#1a3a1a', border: '2px solid #48bb78', color: '#48bb78' }}>PSN</span>}
                {activeCreature.chillTurns > 0 && <span style={{ ...styles.status, backgroundColor: '#1a2a3a', border: '2px solid #63b3ed', color: '#63b3ed' }}>CHL</span>}
                {activeCreature.isGuarding && <span style={{ ...styles.status, backgroundColor: '#1a2a3a', border: `1px solid ${GBC.blue}`, color: GBC.blue }}>GRD</span>}
              </span>
              <span style={{ fontSize: 'var(--font-sm)', color: GBC.textDim }}>
                {activeCreature.hp}/{maxHp}
              </span>
            </div>
            <div style={styles.hpBar} className={playerHpPercent <= 25 ? 'hp-low' : ''}>
              <div style={{
                ...styles.hpFill,
                width: `${playerHpPercent}%`,
                backgroundColor: playerHpPercent > 50 ? GBC.green : playerHpPercent > 25 ? GBC.gold : GBC.red
              }} />
            </div>
            <div style={{ fontSize: 'var(--font-xs)', color: GBC.textDim, marginTop: '3px' }}>
              STA {activeCreature.stamina}/{maxStamina}
              {activeCreature.scars && activeCreature.scars.length > 0 && (
                <span style={{ marginLeft: 'var(--spacing-xs)' }}>
                  {activeCreature.scars.slice(0, 2).map((scar, j) => (
                    <span key={j} style={styles.scar}>{scar.name.slice(0, 4)}</span>
                  ))}
                </span>
              )}
            </div>
            <div
              style={{
                ...styles.staminaBar,
                borderColor: activeCreature.stamina < 5 ? GBC.red : activeCreature.stamina < 8 ? GBC.gold : GBC.border
              }}
              className={activeCreature.stamina < 5 ? 'stamina-warning' : ''}
            >
              <div style={{
                ...styles.staminaFill,
                width: `${(activeCreature.stamina / maxStamina) * 100}%`,
                backgroundColor: activeCreature.stamina < 5 ? GBC.red : activeCreature.stamina < 8 ? GBC.gold : GBC.blue
              }} />
            </div>
          </div>

          {/* Move buttons */}
          <div style={styles.moveButtons}>
            {activeBase.moves.map((move, i) => {
              const adjustedMove = getMoveWithPriority(move);
              const canUse = adjustedMove.cost <= activeCreature.stamina && state.turnPhase === 'player';

              return (
                <button
                  key={i}
                  style={{
                    ...styles.moveButton,
                    ...(canUse ? {} : styles.moveButtonDisabled),
                    position: 'relative'
                  }}
                  disabled={!canUse}
                  onClick={() => { playSfx('menuClick'); dispatch({ type: 'SELECT_MOVE', move: adjustedMove }); }}
                >
                  <span style={{
                    position: 'absolute',
                    top: '2px',
                    left: '4px',
                    fontSize: 'var(--font-xs)',
                    color: GBC.textDim,
                    opacity: 0.6
                  }}>{i + 1}</span>
                  <div>{adjustedMove.name}</div>
                  <div style={{ fontSize: 'var(--font-xs)', color: GBC.textDim, marginTop: '3px' }}>
                    {adjustedMove.cost}SP
                    {adjustedMove.damage > 0 ? ` ${adjustedMove.damage}DMG` : ` ${adjustedMove.effect?.toUpperCase()}`}
                    {adjustedMove.priority && !hasFlinching && ' PRI'}
                  </div>
                </button>
              );
            })}

            {/* Bind button - only for wild creatures, not bosses */}
            {!state.isBossFight && (() => {
              const canBind = state.souls >= BIND_COST &&
                              state.team.length < MAX_TEAM_SIZE &&
                              state.turnPhase === 'player';
              const difficulty = getDifficulty(state);
              const captureChance = getCaptureChance(state.enemy.hp, state.enemy.maxHp, difficulty.captureBonus);

              return (
                <button
                  style={{
                    ...styles.bindButton,
                    ...(canBind ? {} : styles.bindButtonDisabled),
                    position: 'relative'
                  }}
                  disabled={!canBind}
                  onClick={() => dispatch({ type: 'BIND_ATTEMPT' })}
                  title={`${captureChance}% capture chance`}
                >
                  <span style={{
                    position: 'absolute',
                    top: '2px',
                    left: '4px',
                    fontSize: 'var(--font-xs)',
                    color: GBC.textDim,
                    opacity: 0.6
                  }}>B</span>
                  <div>SOUL BIND ({BIND_COST} souls)</div>
                  <div style={{ fontSize: 'var(--font-xs)', marginTop: '3px' }}>
                    {state.team.length >= MAX_TEAM_SIZE ? 'TEAM FULL' :
                     state.souls < BIND_COST ? `NEED ${BIND_COST - state.souls} MORE SOULS` :
                     `${captureChance}% CHANCE`}
                  </div>
                </button>
              );
            })()}
          </div>

          {state.team.length > 1 && (
            <div style={{ marginTop: 'var(--spacing-sm)' }}>
              <div style={{ fontSize: 'var(--font-xs)', color: GBC.textDim, marginBottom: 'var(--spacing-xs)' }}>SWITCH:</div>
              <div style={{ display: 'flex', gap: 'var(--spacing-xs)' }}>
                {state.team.map((creature, i) => {
                  if (i === state.activeCreatureIndex) return null;
                  const base = STARTERS[creature.id];
                  const stats = applyScars(creature, base);
                  return (
                    <button
                      key={i}
                      style={{
                        ...styles.moveButton,
                        flex: 1,
                        opacity: creature.hp <= 0 ? 0.5 : 1
                      }}
                      disabled={creature.hp <= 0 || state.turnPhase !== 'player'}
                      onClick={() => dispatch({ type: 'SWITCH_CREATURE', index: i })}
                    >
                      {getTypeIcon(creature.type)} {creature.nickname || creature.name} ({creature.hp}/{stats.maxHp})
                    </button>
                  );
                })}
              </div>
            </div>
          )}

          <div style={styles.log}>
            {state.battleLog.map((log, i) => (
              <div key={i} style={{ marginBottom: '2px' }}>{log}</div>
            ))}
          </div>
        </div>
      );
    }

    function Victory({ state, dispatch }) {
      const totalScars = state.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0);
      const survivingCreatures = state.team.filter(c => c.hp > 0).length;
      const isHollowWarden = state.hollowWardenDefeated && state.currentMap === 'hollowDeep';

      // Play victory sound on mount
      useEffect(() => {
        playSfx('victory');
      }, []);

      return (
        <div style={styles.victory}>
          {/* Boss final words */}
          <div style={{ marginBottom: 'var(--spacing-lg)' }}>
            <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-sm)' }}>
              {isHollowWarden
                ? 'The Hollow Warden fractures into light and shadow. A voice echoes:'
                : 'The Obsidian Hound collapses. Varek speaks one last time:'}
            </div>
            {(isHollowWarden ? HOLLOW_WARDEN_DIALOGUE.victory : BOSS_DIALOGUE.victory).map((line, i) => (
              <div key={i} style={styles.victoryDialogue}>{line}</div>
            ))}
          </div>

          <div style={{
            margin: 'var(--spacing-lg) 0',
            padding: 'var(--spacing-md)',
            backgroundColor: isHollowWarden ? 'rgba(159, 122, 234, 0.1)' : 'rgba(104, 211, 145, 0.1)',
            border: `2px solid ${isHollowWarden ? GBC.dark : GBC.green}`
          }}>
            <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-sm)' }}>
              {isHollowWarden
                ? 'The deep falls silent. The surface awaits.'
                : 'The gate opens. Light pours through.'}
            </div>
          </div>

          <div style={styles.victoryTitle}>
            {isHollowWarden ? 'THE HOLLOW DEEP - CLEARED' : 'YOU SURVIVED'}
          </div>

          <div style={{ margin: 'var(--spacing-lg) 0', textAlign: 'left', display: 'inline-block' }}>
            <p style={{ color: GBC.red, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-sm)' }}>
              Scars earned: {totalScars}
            </p>
            <p style={{ color: GBC.gold, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-sm)' }}>
              Souls banked: {state.souls + state.bankedSouls}
            </p>
            <p style={{ color: GBC.green, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-sm)' }}>
              Creatures bound: {state.team.length}
            </p>
            <p style={{ color: GBC.textDim, marginBottom: 'var(--spacing-xs)', fontSize: 'var(--font-sm)' }}>
              Time: {formatPlayTime(state.playTime)}
            </p>
          </div>

          <div style={styles.victorySubtitle}>
            {isHollowWarden
              ? '"You have walked through shadow and emerged."'
              : '"Scarred but not broken."'}
          </div>

          <div style={{ display: 'flex', gap: 'var(--spacing-md)', justifyContent: 'center', marginTop: 'var(--spacing-lg)' }}>
            <button
              style={styles.button}
              onClick={() => dispatch({ type: 'RESTART' })}
            >
              NEW GAME+
            </button>
            <button
              style={styles.button}
              onClick={() => dispatch({ type: 'SHOW_CREDITS' })}
            >
              CREDITS
            </button>
          </div>
        </div>
      );
    }

    function GameOver({ state, dispatch }) {
      const difficulty = getDifficulty(state);
      const isPermadeath = difficulty.permadeath;

      // Play death sound and delete save on permadeath
      useEffect(() => {
        playSfx('death');
        if (isPermadeath) {
          deleteSaveData();
        }
      }, [isPermadeath]);

      return (
        <div style={styles.gameOver}>
          <div style={{ fontSize: 'var(--font-lg)', color: GBC.red, marginBottom: 'var(--spacing-lg)' }}>YOU DIED</div>

          {isPermadeath && (
            <div style={{
              marginBottom: 'var(--spacing-lg)',
              padding: 'var(--spacing-md)',
              backgroundColor: 'rgba(252, 129, 129, 0.1)',
              border: `2px solid ${GBC.red}`
            }}>
              <p style={{ color: GBC.red, fontSize: 'var(--font-sm)', marginBottom: 'var(--spacing-xs)' }}>PERMADEATH</p>
              <p style={{ color: GBC.textDim, fontSize: 'var(--font-xs)' }}>Your save has been erased.</p>
            </div>
          )}

          {state.diedToBoss && (
            <div style={{ marginBottom: 'var(--spacing-lg)' }}>
              {BOSS_DIALOGUE.playerDeath.map((line, i) => (
                <p key={i} style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', fontStyle: 'italic', marginBottom: 'var(--spacing-xs)' }}>
                  {line}
                </p>
              ))}
            </div>
          )}

          {state.droppedSouls && !isPermadeath && (
            <p style={{ color: GBC.gold, marginBottom: 'var(--spacing-lg)', fontSize: 'var(--font-sm)' }}>
              {state.droppedSouls.amount} souls dropped
            </p>
          )}

          <p style={{ color: GBC.textDim, marginBottom: 'var(--spacing-lg)', fontSize: 'var(--font-sm)' }}>
            {isPermadeath ? 'Broken beyond repair.' : 'Scarred but not broken.'}
          </p>

          <button
            style={styles.button}
            onClick={() => dispatch({ type: isPermadeath ? 'RESTART' : 'RESPAWN' })}
          >
            {isPermadeath ? 'NEW GAME' : 'RETURN'}
          </button>
        </div>
      );
    }

    function Prologue({ dispatch }) {
      const prologueLines = [
        { text: 'The bonfire wars ended long ago.', highlight: false },
        { text: '', highlight: false },
        { text: 'Binders and their companions fell, one by one.', highlight: false },
        { text: '', highlight: false },
        { text: 'The creatures that survived... changed.', highlight: false },
        { text: '', highlight: false },
        { text: 'Now they wander the ashen paths, feral and scarred.', highlight: false },
        { text: '', highlight: false },
        { text: 'You are not the first to wake at this flame.', highlight: true },
        { text: '', highlight: false },
        { text: 'You will not be the last.', highlight: false },
        { text: '', highlight: false },
        { text: 'But perhaps you will be the one who endures.', highlight: true }
      ];

      return (
        <div style={styles.prologue}>
          <div style={{ marginBottom: 'var(--spacing-xl)' }}>
            {prologueLines.map((line, i) => (
              <div
                key={i}
                style={line.highlight ? styles.prologueHighlight : styles.prologueLine}
              >
                {line.text || '\u00A0'}
              </div>
            ))}
          </div>

          <button
            style={styles.button}
            onClick={() => dispatch({ type: 'CONTINUE_FROM_PROLOGUE' })}
          >
            CONTINUE
          </button>
        </div>
      );
    }

    function Credits({ dispatch }) {
      return (
        <div style={styles.credits}>
          <div style={styles.creditsTitle}>POKE SOULS</div>

          <div style={{ marginBottom: 'var(--spacing-xl)' }}>
            <div style={{ color: GBC.textDim, fontSize: 'var(--font-sm)', fontStyle: 'italic' }}>
              A game about persistence.
            </div>
          </div>

          <div style={styles.creditsSection}>
            <div style={styles.creditsLabel}>Created by</div>
            <div style={styles.creditsValue}>Zamphere</div>
          </div>

          <div style={styles.creditsSection}>
            <div style={styles.creditsLabel}>Built with</div>
            <div style={styles.creditsValue}>Claude Code</div>
          </div>

          <div style={styles.creditsSection}>
            <div style={styles.creditsLabel}>Music</div>
            <div style={styles.creditsValue}>Procedural chiptune via Tone.js</div>
          </div>

          <div style={styles.creditsQuote}>
            "The bonfire wars are over.<br/>
            But the flames still burn.<br/>
            And someone must carry them forward."
          </div>

          <div style={{ marginTop: 'var(--spacing-lg)', marginBottom: 'var(--spacing-lg)' }}>
            <div style={{ color: GBC.text, fontSize: 'var(--font-sm)' }}>
              Thank you for playing.
            </div>
          </div>

          <button
            style={styles.button}
            onClick={() => dispatch({ type: 'RETURN_TO_TITLE' })}
          >
            RETURN TO TITLE
          </button>
        </div>
      );
    }

    function NicknameScreen({ creature, dispatch }) {
      const [nickname, setNickname] = useState('');
      const inputRef = useRef(null);

      useEffect(() => {
        if (inputRef.current) {
          inputRef.current.focus();
        }
      }, []);

      const handleSubmit = (e) => {
        e.preventDefault();
        playSfx('captureSuccess');
        dispatch({ type: 'SET_NICKNAME', nickname: nickname.trim() || null });
      };

      const handleSkip = () => {
        playSfx('menuClick');
        dispatch({ type: 'SET_NICKNAME', nickname: null });
      };

      return (
        <div style={{
          ...styles.starterSelect,
          minHeight: 'clamp(400px, 60vh, 600px)',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          alignItems: 'center'
        }}>
          <div style={{ marginBottom: 'var(--spacing-lg)' }}>
            <CreatureSprite type={creature.type} size={64} />
          </div>

          <div style={{ color: GBC.gold, fontSize: 'var(--font-md)', marginBottom: 'var(--spacing-sm)' }}>
            {creature.name} joined your team!
          </div>

          <div style={{ color: GBC.textDim, fontSize: 'var(--font-sm)', marginBottom: 'var(--spacing-lg)' }}>
            Give your new companion a name?
          </div>

          <form onSubmit={handleSubmit} style={{ width: '100%', maxWidth: '300px' }}>
            <input
              ref={inputRef}
              type="text"
              value={nickname}
              onChange={(e) => setNickname(e.target.value.slice(0, 12))}
              placeholder={creature.name}
              maxLength={12}
              style={{
                width: '100%',
                padding: 'var(--spacing-md)',
                backgroundColor: GBC.bgLight,
                border: `3px solid ${GBC.border}`,
                color: GBC.text,
                fontFamily: '"Press Start 2P", monospace',
                fontSize: 'var(--font-sm)',
                textAlign: 'center',
                marginBottom: 'var(--spacing-md)'
              }}
            />

            <div style={{ display: 'flex', gap: 'var(--spacing-md)', justifyContent: 'center' }}>
              <button
                type="button"
                style={{ ...styles.button, padding: 'var(--spacing-sm) var(--spacing-lg)' }}
                onClick={handleSkip}
              >
                SKIP
              </button>
              <button
                type="submit"
                style={{
                  ...styles.button,
                  padding: 'var(--spacing-sm) var(--spacing-lg)',
                  borderColor: GBC.gold,
                  color: GBC.gold
                }}
              >
                CONFIRM
              </button>
            </div>
          </form>
        </div>
      );
    }

    function EncounterPreview({ encounter, dispatch }) {
      if (!encounter) return null;
      const { wildData } = encounter;

      const handleFight = () => {
        playSfx('menuClick');
        dispatch({ type: 'CONFIRM_ENCOUNTER' });
      };

      const handleFlee = () => {
        playSfx('menuClick');
        dispatch({ type: 'FLEE_ENCOUNTER' });
      };

      return (
        <div style={{
          ...styles.starterSelect,
          minHeight: 'clamp(300px, 50vh, 400px)',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          alignItems: 'center'
        }}>
          <div style={{ color: GBC.textDim, fontSize: 'var(--font-sm)', marginBottom: 'var(--spacing-lg)' }}>
            Something stirs in the grass...
          </div>

          <div style={{ marginBottom: 'var(--spacing-lg)' }}>
            <div style={{
              width: '80px',
              height: '80px',
              backgroundColor: GBC.bgLight,
              border: `3px solid ${getTypeColor(wildData.type)}`,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: 'var(--font-2xl)'
            }}>
              {getTypeIcon(wildData.type)}
            </div>
          </div>

          <div style={{ color: getTypeColor(wildData.type), fontSize: 'var(--font-md)', marginBottom: 'var(--spacing-xs)' }}>
            {wildData.type.toUpperCase()} TYPE
          </div>

          <div style={{ color: GBC.textDim, fontSize: 'var(--font-xs)', marginBottom: 'var(--spacing-lg)' }}>
            Wild creature detected
          </div>

          <div style={{ display: 'flex', gap: 'var(--spacing-md)' }}>
            <button
              style={{ ...styles.button, padding: 'var(--spacing-sm) var(--spacing-xl)' }}
              onClick={handleFlee}
            >
              FLEE
            </button>
            <button
              style={{
                ...styles.button,
                padding: 'var(--spacing-sm) var(--spacing-xl)',
                borderColor: GBC.gold,
                color: GBC.gold
              }}
              onClick={handleFight}
            >
              FIGHT
            </button>
          </div>
        </div>
      );
    }

    function StatsScreen({ onClose }) {
      const stats = loadStats();
      const allCreatures = ['cindrath', 'marshveil', 'thornwick', 'umbravine', 'solrath'];

      const achievements = [
        {
          id: 'unscarred',
          name: 'Unscarred',
          desc: 'Beat the game with 0 scars',
          unlocked: Object.values(stats.lowestScars).some(s => s === 0)
        },
        {
          id: 'collector',
          name: 'Collector',
          desc: 'Capture all 5 creature types',
          unlocked: allCreatures.every(c => stats.creaturesCollected.includes(c))
        },
        {
          id: 'trueHollow',
          name: 'True Hollow',
          desc: 'Defeat the Hollow Warden on Broken',
          unlocked: stats.hollowWardenDefeated && stats.completedRuns.broken > 0
        },
        {
          id: 'speedrunner',
          name: 'Speedrunner',
          desc: 'Clear in under 20 minutes',
          unlocked: Object.values(stats.fastestClear).some(t => t !== null && t < 20 * 60 * 1000)
        }
      ];

      return (
        <div style={{
          ...styles.starterSelect,
          minHeight: 'clamp(400px, 70vh, 700px)',
          overflowY: 'auto'
        }}>
          <h1 style={{ color: GBC.gold, marginBottom: 'var(--spacing-lg)', fontSize: 'var(--font-xl)' }}>
            STATISTICS
          </h1>

          <div style={{ marginBottom: 'var(--spacing-lg)', textAlign: 'left', width: '100%', maxWidth: '400px' }}>
            <div style={{ color: GBC.textDim, marginBottom: 'var(--spacing-sm)', fontSize: 'var(--font-sm)' }}>
              OVERALL
            </div>
            <div style={{ color: GBC.text, fontSize: 'var(--font-xs)', marginBottom: '4px' }}>
              Total Runs: {stats.totalRuns}
            </div>
            <div style={{ color: GBC.text, fontSize: 'var(--font-xs)', marginBottom: '4px' }}>
              Total Deaths: {stats.totalDeaths}
            </div>
            <div style={{ color: GBC.text, fontSize: 'var(--font-xs)', marginBottom: '4px' }}>
              Total Scars: {stats.totalScarsEarned}
            </div>
            <div style={{ color: GBC.text, fontSize: 'var(--font-xs)', marginBottom: '4px' }}>
              Creatures Captured: {stats.totalCreaturesCaptured}
            </div>
          </div>

          <div style={{ marginBottom: 'var(--spacing-lg)', textAlign: 'left', width: '100%', maxWidth: '400px' }}>
            <div style={{ color: GBC.textDim, marginBottom: 'var(--spacing-sm)', fontSize: 'var(--font-sm)' }}>
              CLEARS BY DIFFICULTY
            </div>
            {Object.entries(DIFFICULTIES).map(([id, diff]) => (
              <div key={id} style={{ color: GBC.text, fontSize: 'var(--font-xs)', marginBottom: '4px' }}>
                {diff.icon} {diff.name}: {stats.completedRuns[id] || 0}
                {stats.fastestClear[id] && (
                  <span style={{ color: GBC.textDim }}> (Best: {formatPlayTime(stats.fastestClear[id])})</span>
                )}
              </div>
            ))}
          </div>

          <div style={{ marginBottom: 'var(--spacing-lg)', textAlign: 'left', width: '100%', maxWidth: '400px' }}>
            <div style={{ color: GBC.textDim, marginBottom: 'var(--spacing-sm)', fontSize: 'var(--font-sm)' }}>
              ACHIEVEMENTS
            </div>
            {achievements.map(ach => (
              <div
                key={ach.id}
                style={{
                  color: ach.unlocked ? GBC.gold : GBC.textDim,
                  fontSize: 'var(--font-xs)',
                  marginBottom: '4px',
                  opacity: ach.unlocked ? 1 : 0.6
                }}
              >
                {ach.unlocked ? '' : ''} {ach.name}
                <span style={{ color: GBC.textDim, marginLeft: '8px' }}>
                  - {ach.desc}
                </span>
              </div>
            ))}
          </div>

          <button
            style={styles.button}
            onClick={onClose}
          >
            BACK
          </button>
        </div>
      );
    }

    function MuteButton({ muted, onToggle }) {
      return (
        <button
          style={styles.muteButton}
          onClick={onToggle}
          title={muted ? 'Unmute' : 'Mute'}
        >
          {muted ? '' : ''}
        </button>
      );
    }

    function HelpButton({ onClick }) {
      return (
        <button
          style={styles.helpButton}
          onClick={onClick}
          title="How to Play"
        >
          ?
        </button>
      );
    }

    function GearButton({ onClick }) {
      return (
        <button
          style={styles.gearButton}
          onClick={onClick}
          title="Menu (ESC)"
        >
          
        </button>
      );
    }

    function ConfirmDialog({ message, onConfirm, onCancel, confirmText = 'YES', cancelText = 'NO', danger = true }) {
      return (
        <div style={styles.confirmOverlay} onClick={onCancel}>
          <div style={styles.confirmDialog} onClick={e => e.stopPropagation()}>
            <div style={styles.confirmText}>{message}</div>
            <div style={styles.confirmButtons}>
              <button
                style={styles.confirmButton}
                onClick={onCancel}
              >
                {cancelText}
              </button>
              <button
                style={{
                  ...styles.confirmButton,
                  ...(danger ? styles.confirmButtonDanger : {})
                }}
                onClick={onConfirm}
              >
                {confirmText}
              </button>
            </div>
          </div>
        </div>
      );
    }

    function SaveSlotDisplay({ saveData }) {
      if (!saveData) return null;

      const totalScars = saveData.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0);
      const leadCreature = saveData.team[saveData.activeCreatureIndex] || saveData.team[0];
      const mapName = saveData.currentMap === 'ashenPath' ? 'Ashen Path' : 'Fallen Keep';
      const diff = DIFFICULTIES[saveData.difficulty] || DIFFICULTIES.scarred;

      return (
        <div style={styles.saveSlot}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 'var(--spacing-sm)' }}>
            <div style={styles.saveSlotTitle}>SAVED JOURNEY</div>
            <div style={{ fontSize: 'var(--font-base)' }}>
              {diff.icon} <span style={{ fontSize: 'var(--font-xs)', color: GBC.textDim }}>{diff.name}</span>
            </div>
          </div>
          <div style={styles.saveSlotStat}>
            Lead: {leadCreature?.name || 'Unknown'} ({saveData.team.length} creature{saveData.team.length > 1 ? 's' : ''})
          </div>
          <div style={styles.saveSlotStat}>
            Location: {mapName}
          </div>
          <div style={styles.saveSlotStat}>
            Souls banked: {saveData.bankedSouls}
          </div>
          <div style={styles.saveSlotStat}>
            Scars: {totalScars}
          </div>
          <div style={styles.saveSlotStat}>
            Time played: {formatPlayTime(saveData.playTime || 0)}
          </div>
          {saveData.bossDefeated && (
            <div style={{ ...styles.saveSlotStat, color: GBC.gold }}>
              Boss defeated
            </div>
          )}
        </div>
      );
    }

    function PauseMenu({ onResume, onSave, onLoad, onNewGame, onHelp, hasSave }) {
      return (
        <div style={styles.pauseOverlay}>
          <div style={styles.pauseMenu}>
            <div style={styles.pauseTitle}>PAUSED</div>

            <div
              style={styles.pauseOption}
              onClick={onResume}
              onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
              onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
            >
              RESUME
            </div>

            <div
              style={styles.pauseOption}
              onClick={onSave}
              onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
              onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
            >
              SAVE GAME
            </div>

            <div
              style={{
                ...styles.pauseOption,
                ...(hasSave ? {} : styles.pauseOptionDisabled)
              }}
              onClick={hasSave ? onLoad : undefined}
              onMouseOver={e => hasSave && (e.currentTarget.style.borderColor = GBC.gold)}
              onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
            >
              LOAD GAME
            </div>

            <div
              style={styles.pauseOption}
              onClick={onNewGame}
              onMouseOver={e => e.currentTarget.style.borderColor = GBC.red}
              onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
            >
              NEW GAME
            </div>

            <div
              style={styles.pauseOption}
              onClick={onHelp}
              onMouseOver={e => e.currentTarget.style.borderColor = GBC.gold}
              onMouseOut={e => e.currentTarget.style.borderColor = GBC.border}
            >
              HELP
            </div>
          </div>
        </div>
      );
    }

    function LoadScreen({ saveData, onContinue, onNewGame }) {
      return (
        <div style={styles.loadScreen}>
          <div style={styles.loadTitle}>Continue your journey?</div>

          <SaveSlotDisplay saveData={saveData} />

          <div style={{ display: 'flex', gap: '12px', justifyContent: 'center', marginTop: '20px' }}>
            <button
              style={styles.button}
              onClick={onNewGame}
            >
              NEW GAME
            </button>
            <button
              style={{ ...styles.button, borderColor: GBC.gold, color: GBC.gold }}
              onClick={onContinue}
            >
              CONTINUE
            </button>
          </div>
        </div>
      );
    }

    function SaveNotification({ message, onDismiss }) {
      useEffect(() => {
        const timer = setTimeout(onDismiss, 2500);
        return () => clearTimeout(timer);
      }, [onDismiss]);

      return (
        <div style={styles.saveNotification}>
          {message}
        </div>
      );
    }

    function HelpOverlay({ onClose }) {
      return (
        <div style={styles.helpOverlay} onClick={onClose}>
          <div style={styles.helpContent} onClick={e => e.stopPropagation()}>
            <div style={styles.helpTitle}>HOW TO SURVIVE</div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>CONTROLS</div>
              <div style={styles.helpText}>
                WASD/Arrows - Move<br/>
                E - Rest at bonfire<br/>
                X - Examine surroundings<br/>
                ESC - Pause menu<br/>
                Click - Select moves
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>STAMINA</div>
              <div style={styles.helpText}>
                Every move costs stamina.<br/>
                End turn below 5 = "Winded" (take +25% damage)<br/>
                Use REST to recover stamina (skips your attack)
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>SOULS</div>
              <div style={styles.helpText}>
                Earn from victories. Drop ALL on death.<br/>
                Die again before reclaiming = gone forever.<br/>
                Bank at bonfires for safety.
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>SCARS</div>
              <div style={styles.helpText}>
                Creatures gain permanent scars when they faint.<br/>
                Three scars = Hollowed (75% stats)
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>BONFIRE</div>
              <div style={styles.helpText}>
                Heals team. Banks souls. BUT respawns all enemies.
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>CAPTURE</div>
              <div style={styles.helpText}>
                SOUL BIND costs 20 souls. Lower HP = better odds.
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>TYPE MATCHUPS</div>
              <div style={styles.helpText}>
                <span style={{ color: GBC.fire }}>Fire</span> &gt; <span style={{ color: GBC.grass }}>Grass</span> &gt; <span style={{ color: GBC.water }}>Water</span> &gt; <span style={{ color: GBC.fire }}>Fire</span>
              </div>
            </div>

            <div style={styles.helpSection}>
              <div style={styles.helpSectionTitle}>GOAL</div>
              <div style={styles.helpText}>
                Defeat Keeper Varek in the Fallen Keep.
              </div>
            </div>

            <div style={styles.helpQuote}>"Scarred but not broken."</div>

            <button style={styles.helpClose} onClick={onClose}>
              CLOSE
            </button>
          </div>
        </div>
      );
    }

    function PokeSouls() {
      const [state, dispatch] = useReducer(gameReducer, initialState);
      const [muted, setMuted] = useState(true);
      const [audioStarted, setAudioStarted] = useState(false);
      const [showHelp, setShowHelp] = useState(false);
      const [showPauseMenu, setShowPauseMenu] = useState(false);
      const [showStats, setShowStats] = useState(false);
      const [confirmDialog, setConfirmDialog] = useState(null);
      const [checkingSave, setCheckingSave] = useState(true);
      const [existingSave, setExistingSave] = useState(null);
      const prevBonfireRef = useRef(null);
      const playTimeRef = useRef(Date.now());

      // Check for existing save on mount
      useEffect(() => {
        const save = loadSaveData();
        if (save && save.team && save.team.length > 0) {
          setExistingSave(save);
        }
        setCheckingSave(false);
      }, []);

      // Show help on first visit (only if no save screen)
      useEffect(() => {
        if (!checkingSave && !existingSave) {
          const hasSeenHelp = localStorage.getItem('pokeSoulsHelpSeen');
          if (!hasSeenHelp) {
            setShowHelp(true);
          }
        }
      }, [checkingSave, existingSave]);

      // Track play time
      useEffect(() => {
        if (state.screen === 'exploration' || state.screen === 'battle') {
          const interval = setInterval(() => {
            const now = Date.now();
            const delta = now - playTimeRef.current;
            playTimeRef.current = now;
            dispatch({ type: 'UPDATE_PLAY_TIME', delta });
          }, 1000);
          return () => clearInterval(interval);
        }
        playTimeRef.current = Date.now();
      }, [state.screen]);

      // Handle ESC key for pause menu
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (e.key === 'Escape') {
            // Don't open pause in certain screens
            if (state.screen === 'starter' || state.screen === 'victory' ||
                state.screen === 'credits' || state.screen === 'gameOver') {
              return;
            }
            // Close help first if open
            if (showHelp) {
              setShowHelp(false);
              return;
            }
            // Close confirm dialog if open
            if (confirmDialog) {
              setConfirmDialog(null);
              return;
            }
            // Toggle pause menu
            setShowPauseMenu(prev => !prev);
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [state.screen, showHelp, confirmDialog]);

      const handleCloseHelp = () => {
        setShowHelp(false);
        localStorage.setItem('pokeSoulsHelpSeen', 'true');
      };

      // Check if player is currently on a bonfire tile
      const isOnBonfire = useCallback(() => {
        const map = state.currentMap === 'ashenPath' ? ASHEN_PATH : state.currentMap === 'hollowDeep' ? HOLLOW_DEEP : FALLEN_KEEP;
        const tile = map[state.playerPos.y]?.[state.playerPos.x];
        return tile === 'B';
      }, [state.currentMap, state.playerPos]);

      // Compute the desired track based on game state
      const desiredTrack = (() => {
        if (state.screen === 'difficulty' || state.screen === 'starter') return null;
        if (state.screen === 'prologue') return 'bonfire';
        if (state.screen === 'victory') return 'victory';
        if (state.screen === 'credits') return 'bonfire';
        if (state.screen === 'gameOver') return 'gameOver';
        if (state.screen === 'battle') {
          if (state.isBossFight && state.bossPhase === 2) return 'bossPhase2';
          return 'battle';
        }
        if (state.screen === 'exploration') {
          return isOnBonfire() ? 'bonfire' : 'exploration';
        }
        return null;
      })();

      // Handle music transitions
      useEffect(() => {
        if (!audioStarted || muted) return;
        if (desiredTrack) {
          musicManager.switchTrack(desiredTrack);
        }
      }, [desiredTrack, audioStarted, muted]);

      const getTrackForState = useCallback(() => desiredTrack, [desiredTrack]);

      const handleToggleMute = async () => {
        if (!audioStarted) {
          await musicManager.init();
          await sfxManager.init();
          setAudioStarted(true);
          setMuted(false);
          sfxManager.setMuted(false);
          const track = getTrackForState();
          if (track) {
            musicManager.switchTrack(track);
          }
        } else {
          const newMuted = musicManager.toggleMute();
          setMuted(newMuted);
          sfxManager.setMuted(newMuted);
        }
      };

      // Track statistics
      const prevScreenRef = useRef(state.screen);
      const prevTeamLengthRef = useRef(state.team.length);
      const prevScarsRef = useRef(state.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0));

      useEffect(() => {
        // Track run start when moving from starter to exploration
        if (prevScreenRef.current === 'starter' && state.screen === 'exploration') {
          recordRunStart();
        }
        // Track death when going to gameOver
        if (state.screen === 'gameOver' && prevScreenRef.current !== 'gameOver') {
          recordDeath();
        }
        // Track victory
        if (state.screen === 'victory' && prevScreenRef.current !== 'victory') {
          const totalScars = state.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0);
          recordVictory(state.difficulty, state.playTime, totalScars, state.currentMap === 'hollowDeep');
        }
        prevScreenRef.current = state.screen;
      }, [state.screen, state.difficulty, state.playTime, state.team, state.currentMap]);

      useEffect(() => {
        // Track capture when team grows
        if (state.team.length > prevTeamLengthRef.current) {
          const newCreature = state.team[state.team.length - 1];
          if (newCreature) {
            recordCapture(newCreature.id);
          }
        }
        prevTeamLengthRef.current = state.team.length;
      }, [state.team.length, state.team]);

      useEffect(() => {
        // Track scar when total increases
        const currentScars = state.team.reduce((sum, c) => sum + (c.scars?.length || 0), 0);
        if (currentScars > prevScarsRef.current) {
          for (let i = 0; i < currentScars - prevScarsRef.current; i++) {
            recordScar();
          }
        }
        prevScarsRef.current = currentScars;
      }, [state.team]);

      // Pause menu handlers
      const handleResume = () => setShowPauseMenu(false);

      const handleSave = () => {
        dispatch({ type: 'MANUAL_SAVE' });
        setShowPauseMenu(false);
      };

      const handleLoadRequest = () => {
        const save = loadSaveData();
        if (save) {
          setConfirmDialog({
            message: 'Load saved game? Unsaved progress will be lost.',
            onConfirm: () => {
              dispatch({ type: 'LOAD_GAME', saveData: save });
              setConfirmDialog(null);
              setShowPauseMenu(false);
            },
            onCancel: () => setConfirmDialog(null)
          });
        }
      };

      const handleNewGameRequest = () => {
        setConfirmDialog({
          message: 'Abandon this run? All progress will be lost.',
          onConfirm: () => {
            dispatch({ type: 'NEW_GAME_CONFIRMED' });
            setConfirmDialog(null);
            setShowPauseMenu(false);
            setExistingSave(null);
          },
          onCancel: () => setConfirmDialog(null)
        });
      };

      const handleHelpFromPause = () => {
        setShowPauseMenu(false);
        setShowHelp(true);
      };

      // Load screen handlers
      const handleContinueSave = () => {
        if (existingSave) {
          dispatch({ type: 'LOAD_GAME', saveData: existingSave });
          setExistingSave(null);
        }
      };

      const handleNewGameFromLoad = () => {
        setConfirmDialog({
          message: 'Start new game? Saved progress will be lost.',
          onConfirm: () => {
            deleteSaveData();
            setExistingSave(null);
            setConfirmDialog(null);
          },
          onCancel: () => setConfirmDialog(null)
        });
      };

      // Show loading state
      if (checkingSave) {
        return (
          <div style={styles.container}>
            <div style={{ textAlign: 'center', padding: '40px', color: GBC.textDim }}>
              ...
            </div>
          </div>
        );
      }

      // Show load screen if save exists and we're at starter screen
      if (existingSave && state.screen === 'difficulty') {
        return (
          <div style={styles.container}>
            <LoadScreen
              saveData={existingSave}
              onContinue={handleContinueSave}
              onNewGame={handleNewGameFromLoad}
            />
            {confirmDialog && (
              <ConfirmDialog
                message={confirmDialog.message}
                onConfirm={confirmDialog.onConfirm}
                onCancel={confirmDialog.onCancel}
              />
            )}
          </div>
        );
      }

      // Check if pause menu is allowed
      const canPause = state.screen === 'exploration' || state.screen === 'battle' || state.screen === 'prologue';
      const hasSave = !!loadSaveData();

      return (
        <div style={styles.container}>
          {canPause && <GearButton onClick={() => setShowPauseMenu(true)} />}
          <HelpButton onClick={() => setShowHelp(true)} />
          <MuteButton muted={muted} onToggle={handleToggleMute} />

          {showHelp && <HelpOverlay onClose={handleCloseHelp} />}

          {showPauseMenu && canPause && (
            <PauseMenu
              onResume={handleResume}
              onSave={handleSave}
              onLoad={handleLoadRequest}
              onNewGame={handleNewGameRequest}
              onHelp={handleHelpFromPause}
              hasSave={hasSave}
            />
          )}

          {confirmDialog && (
            <ConfirmDialog
              message={confirmDialog.message}
              onConfirm={confirmDialog.onConfirm}
              onCancel={confirmDialog.onCancel}
            />
          )}

          {state.saveNotification && (
            <SaveNotification
              message={state.saveNotification}
              onDismiss={() => dispatch({ type: 'CLEAR_NOTIFICATION' })}
            />
          )}

          {/* Difficulty indicator during gameplay */}
          {(state.screen === 'exploration' || state.screen === 'battle') && (
            <DifficultyIndicator difficulty={state.difficulty} />
          )}

          {state.screen === 'difficulty' && !showStats && (
            <DifficultySelect dispatch={dispatch} onShowStats={() => setShowStats(true)} />
          )}
          {state.screen === 'difficulty' && showStats && (
            <StatsScreen onClose={() => setShowStats(false)} />
          )}
          {state.screen === 'starter' && (
            <StarterSelect dispatch={dispatch} />
          )}
          {state.screen === 'prologue' && (
            <Prologue dispatch={dispatch} />
          )}
          {state.screen === 'exploration' && (
            <Exploration state={state} dispatch={dispatch} />
          )}
          {state.screen === 'battle' && (
            <Battle state={state} dispatch={dispatch} />
          )}
          {state.screen === 'victory' && (
            <Victory state={state} dispatch={dispatch} />
          )}
          {state.screen === 'gameOver' && (
            <GameOver state={state} dispatch={dispatch} />
          )}
          {state.screen === 'nickname' && (
            <NicknameScreen creature={state.pendingCreature} dispatch={dispatch} />
          )}
          {state.screen === 'encounterPreview' && (
            <EncounterPreview encounter={state.pendingEncounter} dispatch={dispatch} />
          )}
          {state.screen === 'credits' && (
            <Credits dispatch={dispatch} />
          )}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<PokeSouls />);
  </script>
</body>
</html>
